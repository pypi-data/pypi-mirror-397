"""
AWS CloudFormation GameLift Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service GameLift
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AcceptanceType:
    """AcceptanceType enum values."""

    ACCEPT = "ACCEPT"
    REJECT = "REJECT"


class BackfillMode:
    """BackfillMode enum values."""

    AUTOMATIC = "AUTOMATIC"
    MANUAL = "MANUAL"


class BalancingStrategy:
    """BalancingStrategy enum values."""

    SPOT_ONLY = "SPOT_ONLY"
    SPOT_PREFERRED = "SPOT_PREFERRED"
    ON_DEMAND_ONLY = "ON_DEMAND_ONLY"


class BuildStatus:
    """BuildStatus enum values."""

    INITIALIZED = "INITIALIZED"
    READY = "READY"
    FAILED = "FAILED"


class CertificateType:
    """CertificateType enum values."""

    DISABLED = "DISABLED"
    GENERATED = "GENERATED"


class ComparisonOperatorType:
    """ComparisonOperatorType enum values."""

    GREATERTHANOREQUALTOTHRESHOLD = "GreaterThanOrEqualToThreshold"
    GREATERTHANTHRESHOLD = "GreaterThanThreshold"
    LESSTHANTHRESHOLD = "LessThanThreshold"
    LESSTHANOREQUALTOTHRESHOLD = "LessThanOrEqualToThreshold"


class ComputeStatus:
    """ComputeStatus enum values."""

    PENDING = "PENDING"
    ACTIVE = "ACTIVE"
    TERMINATING = "TERMINATING"
    IMPAIRED = "IMPAIRED"


class ComputeType:
    """ComputeType enum values."""

    EC2 = "EC2"
    ANYWHERE = "ANYWHERE"


class ContainerDependencyCondition:
    """ContainerDependencyCondition enum values."""

    START = "START"
    COMPLETE = "COMPLETE"
    SUCCESS = "SUCCESS"
    HEALTHY = "HEALTHY"


class ContainerFleetBillingType:
    """ContainerFleetBillingType enum values."""

    ON_DEMAND = "ON_DEMAND"
    SPOT = "SPOT"


class ContainerFleetLocationStatus:
    """ContainerFleetLocationStatus enum values."""

    PENDING = "PENDING"
    CREATING = "CREATING"
    CREATED = "CREATED"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    DELETING = "DELETING"


class ContainerFleetRemoveAttribute:
    """ContainerFleetRemoveAttribute enum values."""

    PER_INSTANCE_CONTAINER_GROUP_DEFINITION = "PER_INSTANCE_CONTAINER_GROUP_DEFINITION"


class ContainerFleetStatus:
    """ContainerFleetStatus enum values."""

    PENDING = "PENDING"
    CREATING = "CREATING"
    CREATED = "CREATED"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    DELETING = "DELETING"


class ContainerGroupDefinitionStatus:
    """ContainerGroupDefinitionStatus enum values."""

    READY = "READY"
    COPYING = "COPYING"
    FAILED = "FAILED"


class ContainerGroupType:
    """ContainerGroupType enum values."""

    GAME_SERVER = "GAME_SERVER"
    PER_INSTANCE = "PER_INSTANCE"


class ContainerMountPointAccessLevel:
    """ContainerMountPointAccessLevel enum values."""

    READ_ONLY = "READ_ONLY"
    READ_AND_WRITE = "READ_AND_WRITE"


class ContainerOperatingSystem:
    """ContainerOperatingSystem enum values."""

    AMAZON_LINUX_2023 = "AMAZON_LINUX_2023"


class DeploymentImpairmentStrategy:
    """DeploymentImpairmentStrategy enum values."""

    MAINTAIN = "MAINTAIN"
    ROLLBACK = "ROLLBACK"


class DeploymentProtectionStrategy:
    """DeploymentProtectionStrategy enum values."""

    WITH_PROTECTION = "WITH_PROTECTION"
    IGNORE_PROTECTION = "IGNORE_PROTECTION"


class DeploymentStatus:
    """DeploymentStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    IMPAIRED = "IMPAIRED"
    COMPLETE = "COMPLETE"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"
    ROLLBACK_COMPLETE = "ROLLBACK_COMPLETE"
    CANCELLED = "CANCELLED"
    PENDING = "PENDING"


class EC2InstanceType:
    """EC2InstanceType enum values."""

    T2_MICRO = "t2.micro"
    T2_SMALL = "t2.small"
    T2_MEDIUM = "t2.medium"
    T2_LARGE = "t2.large"
    C3_LARGE = "c3.large"
    C3_XLARGE = "c3.xlarge"
    C3_2XLARGE = "c3.2xlarge"
    C3_4XLARGE = "c3.4xlarge"
    C3_8XLARGE = "c3.8xlarge"
    C4_LARGE = "c4.large"
    C4_XLARGE = "c4.xlarge"
    C4_2XLARGE = "c4.2xlarge"
    C4_4XLARGE = "c4.4xlarge"
    C4_8XLARGE = "c4.8xlarge"
    C5_LARGE = "c5.large"
    C5_XLARGE = "c5.xlarge"
    C5_2XLARGE = "c5.2xlarge"
    C5_4XLARGE = "c5.4xlarge"
    C5_9XLARGE = "c5.9xlarge"
    C5_12XLARGE = "c5.12xlarge"
    C5_18XLARGE = "c5.18xlarge"
    C5_24XLARGE = "c5.24xlarge"
    C5A_LARGE = "c5a.large"
    C5A_XLARGE = "c5a.xlarge"
    C5A_2XLARGE = "c5a.2xlarge"
    C5A_4XLARGE = "c5a.4xlarge"
    C5A_8XLARGE = "c5a.8xlarge"
    C5A_12XLARGE = "c5a.12xlarge"
    C5A_16XLARGE = "c5a.16xlarge"
    C5A_24XLARGE = "c5a.24xlarge"
    R3_LARGE = "r3.large"
    R3_XLARGE = "r3.xlarge"
    R3_2XLARGE = "r3.2xlarge"
    R3_4XLARGE = "r3.4xlarge"
    R3_8XLARGE = "r3.8xlarge"
    R4_LARGE = "r4.large"
    R4_XLARGE = "r4.xlarge"
    R4_2XLARGE = "r4.2xlarge"
    R4_4XLARGE = "r4.4xlarge"
    R4_8XLARGE = "r4.8xlarge"
    R4_16XLARGE = "r4.16xlarge"
    R5_LARGE = "r5.large"
    R5_XLARGE = "r5.xlarge"
    R5_2XLARGE = "r5.2xlarge"
    R5_4XLARGE = "r5.4xlarge"
    R5_8XLARGE = "r5.8xlarge"
    R5_12XLARGE = "r5.12xlarge"
    R5_16XLARGE = "r5.16xlarge"
    R5_24XLARGE = "r5.24xlarge"
    R5A_LARGE = "r5a.large"
    R5A_XLARGE = "r5a.xlarge"
    R5A_2XLARGE = "r5a.2xlarge"
    R5A_4XLARGE = "r5a.4xlarge"
    R5A_8XLARGE = "r5a.8xlarge"
    R5A_12XLARGE = "r5a.12xlarge"
    R5A_16XLARGE = "r5a.16xlarge"
    R5A_24XLARGE = "r5a.24xlarge"
    M3_MEDIUM = "m3.medium"
    M3_LARGE = "m3.large"
    M3_XLARGE = "m3.xlarge"
    M3_2XLARGE = "m3.2xlarge"
    M4_LARGE = "m4.large"
    M4_XLARGE = "m4.xlarge"
    M4_2XLARGE = "m4.2xlarge"
    M4_4XLARGE = "m4.4xlarge"
    M4_10XLARGE = "m4.10xlarge"
    M5_LARGE = "m5.large"
    M5_XLARGE = "m5.xlarge"
    M5_2XLARGE = "m5.2xlarge"
    M5_4XLARGE = "m5.4xlarge"
    M5_8XLARGE = "m5.8xlarge"
    M5_12XLARGE = "m5.12xlarge"
    M5_16XLARGE = "m5.16xlarge"
    M5_24XLARGE = "m5.24xlarge"
    M5A_LARGE = "m5a.large"
    M5A_XLARGE = "m5a.xlarge"
    M5A_2XLARGE = "m5a.2xlarge"
    M5A_4XLARGE = "m5a.4xlarge"
    M5A_8XLARGE = "m5a.8xlarge"
    M5A_12XLARGE = "m5a.12xlarge"
    M5A_16XLARGE = "m5a.16xlarge"
    M5A_24XLARGE = "m5a.24xlarge"
    C5D_LARGE = "c5d.large"
    C5D_XLARGE = "c5d.xlarge"
    C5D_2XLARGE = "c5d.2xlarge"
    C5D_4XLARGE = "c5d.4xlarge"
    C5D_9XLARGE = "c5d.9xlarge"
    C5D_12XLARGE = "c5d.12xlarge"
    C5D_18XLARGE = "c5d.18xlarge"
    C5D_24XLARGE = "c5d.24xlarge"
    C6A_LARGE = "c6a.large"
    C6A_XLARGE = "c6a.xlarge"
    C6A_2XLARGE = "c6a.2xlarge"
    C6A_4XLARGE = "c6a.4xlarge"
    C6A_8XLARGE = "c6a.8xlarge"
    C6A_12XLARGE = "c6a.12xlarge"
    C6A_16XLARGE = "c6a.16xlarge"
    C6A_24XLARGE = "c6a.24xlarge"
    C6I_LARGE = "c6i.large"
    C6I_XLARGE = "c6i.xlarge"
    C6I_2XLARGE = "c6i.2xlarge"
    C6I_4XLARGE = "c6i.4xlarge"
    C6I_8XLARGE = "c6i.8xlarge"
    C6I_12XLARGE = "c6i.12xlarge"
    C6I_16XLARGE = "c6i.16xlarge"
    C6I_24XLARGE = "c6i.24xlarge"
    R5D_LARGE = "r5d.large"
    R5D_XLARGE = "r5d.xlarge"
    R5D_2XLARGE = "r5d.2xlarge"
    R5D_4XLARGE = "r5d.4xlarge"
    R5D_8XLARGE = "r5d.8xlarge"
    R5D_12XLARGE = "r5d.12xlarge"
    R5D_16XLARGE = "r5d.16xlarge"
    R5D_24XLARGE = "r5d.24xlarge"
    M6G_MEDIUM = "m6g.medium"
    M6G_LARGE = "m6g.large"
    M6G_XLARGE = "m6g.xlarge"
    M6G_2XLARGE = "m6g.2xlarge"
    M6G_4XLARGE = "m6g.4xlarge"
    M6G_8XLARGE = "m6g.8xlarge"
    M6G_12XLARGE = "m6g.12xlarge"
    M6G_16XLARGE = "m6g.16xlarge"
    C6G_MEDIUM = "c6g.medium"
    C6G_LARGE = "c6g.large"
    C6G_XLARGE = "c6g.xlarge"
    C6G_2XLARGE = "c6g.2xlarge"
    C6G_4XLARGE = "c6g.4xlarge"
    C6G_8XLARGE = "c6g.8xlarge"
    C6G_12XLARGE = "c6g.12xlarge"
    C6G_16XLARGE = "c6g.16xlarge"
    R6G_MEDIUM = "r6g.medium"
    R6G_LARGE = "r6g.large"
    R6G_XLARGE = "r6g.xlarge"
    R6G_2XLARGE = "r6g.2xlarge"
    R6G_4XLARGE = "r6g.4xlarge"
    R6G_8XLARGE = "r6g.8xlarge"
    R6G_12XLARGE = "r6g.12xlarge"
    R6G_16XLARGE = "r6g.16xlarge"
    C6GN_MEDIUM = "c6gn.medium"
    C6GN_LARGE = "c6gn.large"
    C6GN_XLARGE = "c6gn.xlarge"
    C6GN_2XLARGE = "c6gn.2xlarge"
    C6GN_4XLARGE = "c6gn.4xlarge"
    C6GN_8XLARGE = "c6gn.8xlarge"
    C6GN_12XLARGE = "c6gn.12xlarge"
    C6GN_16XLARGE = "c6gn.16xlarge"
    C7G_MEDIUM = "c7g.medium"
    C7G_LARGE = "c7g.large"
    C7G_XLARGE = "c7g.xlarge"
    C7G_2XLARGE = "c7g.2xlarge"
    C7G_4XLARGE = "c7g.4xlarge"
    C7G_8XLARGE = "c7g.8xlarge"
    C7G_12XLARGE = "c7g.12xlarge"
    C7G_16XLARGE = "c7g.16xlarge"
    R7G_MEDIUM = "r7g.medium"
    R7G_LARGE = "r7g.large"
    R7G_XLARGE = "r7g.xlarge"
    R7G_2XLARGE = "r7g.2xlarge"
    R7G_4XLARGE = "r7g.4xlarge"
    R7G_8XLARGE = "r7g.8xlarge"
    R7G_12XLARGE = "r7g.12xlarge"
    R7G_16XLARGE = "r7g.16xlarge"
    M7G_MEDIUM = "m7g.medium"
    M7G_LARGE = "m7g.large"
    M7G_XLARGE = "m7g.xlarge"
    M7G_2XLARGE = "m7g.2xlarge"
    M7G_4XLARGE = "m7g.4xlarge"
    M7G_8XLARGE = "m7g.8xlarge"
    M7G_12XLARGE = "m7g.12xlarge"
    M7G_16XLARGE = "m7g.16xlarge"
    G5G_XLARGE = "g5g.xlarge"
    G5G_2XLARGE = "g5g.2xlarge"
    G5G_4XLARGE = "g5g.4xlarge"
    G5G_8XLARGE = "g5g.8xlarge"
    G5G_16XLARGE = "g5g.16xlarge"
    R6I_LARGE = "r6i.large"
    R6I_XLARGE = "r6i.xlarge"
    R6I_2XLARGE = "r6i.2xlarge"
    R6I_4XLARGE = "r6i.4xlarge"
    R6I_8XLARGE = "r6i.8xlarge"
    R6I_12XLARGE = "r6i.12xlarge"
    R6I_16XLARGE = "r6i.16xlarge"
    C6GD_MEDIUM = "c6gd.medium"
    C6GD_LARGE = "c6gd.large"
    C6GD_XLARGE = "c6gd.xlarge"
    C6GD_2XLARGE = "c6gd.2xlarge"
    C6GD_4XLARGE = "c6gd.4xlarge"
    C6GD_8XLARGE = "c6gd.8xlarge"
    C6GD_12XLARGE = "c6gd.12xlarge"
    C6GD_16XLARGE = "c6gd.16xlarge"
    C6IN_LARGE = "c6in.large"
    C6IN_XLARGE = "c6in.xlarge"
    C6IN_2XLARGE = "c6in.2xlarge"
    C6IN_4XLARGE = "c6in.4xlarge"
    C6IN_8XLARGE = "c6in.8xlarge"
    C6IN_12XLARGE = "c6in.12xlarge"
    C6IN_16XLARGE = "c6in.16xlarge"
    C7A_MEDIUM = "c7a.medium"
    C7A_LARGE = "c7a.large"
    C7A_XLARGE = "c7a.xlarge"
    C7A_2XLARGE = "c7a.2xlarge"
    C7A_4XLARGE = "c7a.4xlarge"
    C7A_8XLARGE = "c7a.8xlarge"
    C7A_12XLARGE = "c7a.12xlarge"
    C7A_16XLARGE = "c7a.16xlarge"
    C7GD_MEDIUM = "c7gd.medium"
    C7GD_LARGE = "c7gd.large"
    C7GD_XLARGE = "c7gd.xlarge"
    C7GD_2XLARGE = "c7gd.2xlarge"
    C7GD_4XLARGE = "c7gd.4xlarge"
    C7GD_8XLARGE = "c7gd.8xlarge"
    C7GD_12XLARGE = "c7gd.12xlarge"
    C7GD_16XLARGE = "c7gd.16xlarge"
    C7GN_MEDIUM = "c7gn.medium"
    C7GN_LARGE = "c7gn.large"
    C7GN_XLARGE = "c7gn.xlarge"
    C7GN_2XLARGE = "c7gn.2xlarge"
    C7GN_4XLARGE = "c7gn.4xlarge"
    C7GN_8XLARGE = "c7gn.8xlarge"
    C7GN_12XLARGE = "c7gn.12xlarge"
    C7GN_16XLARGE = "c7gn.16xlarge"
    C7I_LARGE = "c7i.large"
    C7I_XLARGE = "c7i.xlarge"
    C7I_2XLARGE = "c7i.2xlarge"
    C7I_4XLARGE = "c7i.4xlarge"
    C7I_8XLARGE = "c7i.8xlarge"
    C7I_12XLARGE = "c7i.12xlarge"
    C7I_16XLARGE = "c7i.16xlarge"
    M6A_LARGE = "m6a.large"
    M6A_XLARGE = "m6a.xlarge"
    M6A_2XLARGE = "m6a.2xlarge"
    M6A_4XLARGE = "m6a.4xlarge"
    M6A_8XLARGE = "m6a.8xlarge"
    M6A_12XLARGE = "m6a.12xlarge"
    M6A_16XLARGE = "m6a.16xlarge"
    M6GD_MEDIUM = "m6gd.medium"
    M6GD_LARGE = "m6gd.large"
    M6GD_XLARGE = "m6gd.xlarge"
    M6GD_2XLARGE = "m6gd.2xlarge"
    M6GD_4XLARGE = "m6gd.4xlarge"
    M6GD_8XLARGE = "m6gd.8xlarge"
    M6GD_12XLARGE = "m6gd.12xlarge"
    M6GD_16XLARGE = "m6gd.16xlarge"
    M6I_LARGE = "m6i.large"
    M6I_XLARGE = "m6i.xlarge"
    M6I_2XLARGE = "m6i.2xlarge"
    M6I_4XLARGE = "m6i.4xlarge"
    M6I_8XLARGE = "m6i.8xlarge"
    M6I_12XLARGE = "m6i.12xlarge"
    M6I_16XLARGE = "m6i.16xlarge"
    M7A_MEDIUM = "m7a.medium"
    M7A_LARGE = "m7a.large"
    M7A_XLARGE = "m7a.xlarge"
    M7A_2XLARGE = "m7a.2xlarge"
    M7A_4XLARGE = "m7a.4xlarge"
    M7A_8XLARGE = "m7a.8xlarge"
    M7A_12XLARGE = "m7a.12xlarge"
    M7A_16XLARGE = "m7a.16xlarge"
    M7GD_MEDIUM = "m7gd.medium"
    M7GD_LARGE = "m7gd.large"
    M7GD_XLARGE = "m7gd.xlarge"
    M7GD_2XLARGE = "m7gd.2xlarge"
    M7GD_4XLARGE = "m7gd.4xlarge"
    M7GD_8XLARGE = "m7gd.8xlarge"
    M7GD_12XLARGE = "m7gd.12xlarge"
    M7GD_16XLARGE = "m7gd.16xlarge"
    M7I_LARGE = "m7i.large"
    M7I_XLARGE = "m7i.xlarge"
    M7I_2XLARGE = "m7i.2xlarge"
    M7I_4XLARGE = "m7i.4xlarge"
    M7I_8XLARGE = "m7i.8xlarge"
    M7I_12XLARGE = "m7i.12xlarge"
    M7I_16XLARGE = "m7i.16xlarge"
    R6GD_MEDIUM = "r6gd.medium"
    R6GD_LARGE = "r6gd.large"
    R6GD_XLARGE = "r6gd.xlarge"
    R6GD_2XLARGE = "r6gd.2xlarge"
    R6GD_4XLARGE = "r6gd.4xlarge"
    R6GD_8XLARGE = "r6gd.8xlarge"
    R6GD_12XLARGE = "r6gd.12xlarge"
    R6GD_16XLARGE = "r6gd.16xlarge"
    R7A_MEDIUM = "r7a.medium"
    R7A_LARGE = "r7a.large"
    R7A_XLARGE = "r7a.xlarge"
    R7A_2XLARGE = "r7a.2xlarge"
    R7A_4XLARGE = "r7a.4xlarge"
    R7A_8XLARGE = "r7a.8xlarge"
    R7A_12XLARGE = "r7a.12xlarge"
    R7A_16XLARGE = "r7a.16xlarge"
    R7GD_MEDIUM = "r7gd.medium"
    R7GD_LARGE = "r7gd.large"
    R7GD_XLARGE = "r7gd.xlarge"
    R7GD_2XLARGE = "r7gd.2xlarge"
    R7GD_4XLARGE = "r7gd.4xlarge"
    R7GD_8XLARGE = "r7gd.8xlarge"
    R7GD_12XLARGE = "r7gd.12xlarge"
    R7GD_16XLARGE = "r7gd.16xlarge"
    R7I_LARGE = "r7i.large"
    R7I_XLARGE = "r7i.xlarge"
    R7I_2XLARGE = "r7i.2xlarge"
    R7I_4XLARGE = "r7i.4xlarge"
    R7I_8XLARGE = "r7i.8xlarge"
    R7I_12XLARGE = "r7i.12xlarge"
    R7I_16XLARGE = "r7i.16xlarge"
    R7I_24XLARGE = "r7i.24xlarge"
    R7I_48XLARGE = "r7i.48xlarge"
    C5AD_LARGE = "c5ad.large"
    C5AD_XLARGE = "c5ad.xlarge"
    C5AD_2XLARGE = "c5ad.2xlarge"
    C5AD_4XLARGE = "c5ad.4xlarge"
    C5AD_8XLARGE = "c5ad.8xlarge"
    C5AD_12XLARGE = "c5ad.12xlarge"
    C5AD_16XLARGE = "c5ad.16xlarge"
    C5AD_24XLARGE = "c5ad.24xlarge"
    C5N_LARGE = "c5n.large"
    C5N_XLARGE = "c5n.xlarge"
    C5N_2XLARGE = "c5n.2xlarge"
    C5N_4XLARGE = "c5n.4xlarge"
    C5N_9XLARGE = "c5n.9xlarge"
    C5N_18XLARGE = "c5n.18xlarge"
    R5AD_LARGE = "r5ad.large"
    R5AD_XLARGE = "r5ad.xlarge"
    R5AD_2XLARGE = "r5ad.2xlarge"
    R5AD_4XLARGE = "r5ad.4xlarge"
    R5AD_8XLARGE = "r5ad.8xlarge"
    R5AD_12XLARGE = "r5ad.12xlarge"
    R5AD_16XLARGE = "r5ad.16xlarge"
    R5AD_24XLARGE = "r5ad.24xlarge"
    C6ID_LARGE = "c6id.large"
    C6ID_XLARGE = "c6id.xlarge"
    C6ID_2XLARGE = "c6id.2xlarge"
    C6ID_4XLARGE = "c6id.4xlarge"
    C6ID_8XLARGE = "c6id.8xlarge"
    C6ID_12XLARGE = "c6id.12xlarge"
    C6ID_16XLARGE = "c6id.16xlarge"
    C6ID_24XLARGE = "c6id.24xlarge"
    C6ID_32XLARGE = "c6id.32xlarge"
    C8G_MEDIUM = "c8g.medium"
    C8G_LARGE = "c8g.large"
    C8G_XLARGE = "c8g.xlarge"
    C8G_2XLARGE = "c8g.2xlarge"
    C8G_4XLARGE = "c8g.4xlarge"
    C8G_8XLARGE = "c8g.8xlarge"
    C8G_12XLARGE = "c8g.12xlarge"
    C8G_16XLARGE = "c8g.16xlarge"
    C8G_24XLARGE = "c8g.24xlarge"
    C8G_48XLARGE = "c8g.48xlarge"
    M5AD_LARGE = "m5ad.large"
    M5AD_XLARGE = "m5ad.xlarge"
    M5AD_2XLARGE = "m5ad.2xlarge"
    M5AD_4XLARGE = "m5ad.4xlarge"
    M5AD_8XLARGE = "m5ad.8xlarge"
    M5AD_12XLARGE = "m5ad.12xlarge"
    M5AD_16XLARGE = "m5ad.16xlarge"
    M5AD_24XLARGE = "m5ad.24xlarge"
    M5D_LARGE = "m5d.large"
    M5D_XLARGE = "m5d.xlarge"
    M5D_2XLARGE = "m5d.2xlarge"
    M5D_4XLARGE = "m5d.4xlarge"
    M5D_8XLARGE = "m5d.8xlarge"
    M5D_12XLARGE = "m5d.12xlarge"
    M5D_16XLARGE = "m5d.16xlarge"
    M5D_24XLARGE = "m5d.24xlarge"
    M5DN_LARGE = "m5dn.large"
    M5DN_XLARGE = "m5dn.xlarge"
    M5DN_2XLARGE = "m5dn.2xlarge"
    M5DN_4XLARGE = "m5dn.4xlarge"
    M5DN_8XLARGE = "m5dn.8xlarge"
    M5DN_12XLARGE = "m5dn.12xlarge"
    M5DN_16XLARGE = "m5dn.16xlarge"
    M5DN_24XLARGE = "m5dn.24xlarge"
    M5N_LARGE = "m5n.large"
    M5N_XLARGE = "m5n.xlarge"
    M5N_2XLARGE = "m5n.2xlarge"
    M5N_4XLARGE = "m5n.4xlarge"
    M5N_8XLARGE = "m5n.8xlarge"
    M5N_12XLARGE = "m5n.12xlarge"
    M5N_16XLARGE = "m5n.16xlarge"
    M5N_24XLARGE = "m5n.24xlarge"
    M6ID_LARGE = "m6id.large"
    M6ID_XLARGE = "m6id.xlarge"
    M6ID_2XLARGE = "m6id.2xlarge"
    M6ID_4XLARGE = "m6id.4xlarge"
    M6ID_8XLARGE = "m6id.8xlarge"
    M6ID_12XLARGE = "m6id.12xlarge"
    M6ID_16XLARGE = "m6id.16xlarge"
    M6ID_24XLARGE = "m6id.24xlarge"
    M6ID_32XLARGE = "m6id.32xlarge"
    M6IDN_LARGE = "m6idn.large"
    M6IDN_XLARGE = "m6idn.xlarge"
    M6IDN_2XLARGE = "m6idn.2xlarge"
    M6IDN_4XLARGE = "m6idn.4xlarge"
    M6IDN_8XLARGE = "m6idn.8xlarge"
    M6IDN_12XLARGE = "m6idn.12xlarge"
    M6IDN_16XLARGE = "m6idn.16xlarge"
    M6IDN_24XLARGE = "m6idn.24xlarge"
    M6IDN_32XLARGE = "m6idn.32xlarge"
    M6IN_LARGE = "m6in.large"
    M6IN_XLARGE = "m6in.xlarge"
    M6IN_2XLARGE = "m6in.2xlarge"
    M6IN_4XLARGE = "m6in.4xlarge"
    M6IN_8XLARGE = "m6in.8xlarge"
    M6IN_12XLARGE = "m6in.12xlarge"
    M6IN_16XLARGE = "m6in.16xlarge"
    M6IN_24XLARGE = "m6in.24xlarge"
    M6IN_32XLARGE = "m6in.32xlarge"
    M8G_MEDIUM = "m8g.medium"
    M8G_LARGE = "m8g.large"
    M8G_XLARGE = "m8g.xlarge"
    M8G_2XLARGE = "m8g.2xlarge"
    M8G_4XLARGE = "m8g.4xlarge"
    M8G_8XLARGE = "m8g.8xlarge"
    M8G_12XLARGE = "m8g.12xlarge"
    M8G_16XLARGE = "m8g.16xlarge"
    M8G_24XLARGE = "m8g.24xlarge"
    M8G_48XLARGE = "m8g.48xlarge"
    R5DN_LARGE = "r5dn.large"
    R5DN_XLARGE = "r5dn.xlarge"
    R5DN_2XLARGE = "r5dn.2xlarge"
    R5DN_4XLARGE = "r5dn.4xlarge"
    R5DN_8XLARGE = "r5dn.8xlarge"
    R5DN_12XLARGE = "r5dn.12xlarge"
    R5DN_16XLARGE = "r5dn.16xlarge"
    R5DN_24XLARGE = "r5dn.24xlarge"
    R5N_LARGE = "r5n.large"
    R5N_XLARGE = "r5n.xlarge"
    R5N_2XLARGE = "r5n.2xlarge"
    R5N_4XLARGE = "r5n.4xlarge"
    R5N_8XLARGE = "r5n.8xlarge"
    R5N_12XLARGE = "r5n.12xlarge"
    R5N_16XLARGE = "r5n.16xlarge"
    R5N_24XLARGE = "r5n.24xlarge"
    R6A_LARGE = "r6a.large"
    R6A_XLARGE = "r6a.xlarge"
    R6A_2XLARGE = "r6a.2xlarge"
    R6A_4XLARGE = "r6a.4xlarge"
    R6A_8XLARGE = "r6a.8xlarge"
    R6A_12XLARGE = "r6a.12xlarge"
    R6A_16XLARGE = "r6a.16xlarge"
    R6A_24XLARGE = "r6a.24xlarge"
    R6A_32XLARGE = "r6a.32xlarge"
    R6A_48XLARGE = "r6a.48xlarge"
    R6ID_LARGE = "r6id.large"
    R6ID_XLARGE = "r6id.xlarge"
    R6ID_2XLARGE = "r6id.2xlarge"
    R6ID_4XLARGE = "r6id.4xlarge"
    R6ID_8XLARGE = "r6id.8xlarge"
    R6ID_12XLARGE = "r6id.12xlarge"
    R6ID_16XLARGE = "r6id.16xlarge"
    R6ID_24XLARGE = "r6id.24xlarge"
    R6ID_32XLARGE = "r6id.32xlarge"
    R6IDN_LARGE = "r6idn.large"
    R6IDN_XLARGE = "r6idn.xlarge"
    R6IDN_2XLARGE = "r6idn.2xlarge"
    R6IDN_4XLARGE = "r6idn.4xlarge"
    R6IDN_8XLARGE = "r6idn.8xlarge"
    R6IDN_12XLARGE = "r6idn.12xlarge"
    R6IDN_16XLARGE = "r6idn.16xlarge"
    R6IDN_24XLARGE = "r6idn.24xlarge"
    R6IDN_32XLARGE = "r6idn.32xlarge"
    R6IN_LARGE = "r6in.large"
    R6IN_XLARGE = "r6in.xlarge"
    R6IN_2XLARGE = "r6in.2xlarge"
    R6IN_4XLARGE = "r6in.4xlarge"
    R6IN_8XLARGE = "r6in.8xlarge"
    R6IN_12XLARGE = "r6in.12xlarge"
    R6IN_16XLARGE = "r6in.16xlarge"
    R6IN_24XLARGE = "r6in.24xlarge"
    R6IN_32XLARGE = "r6in.32xlarge"
    R8G_MEDIUM = "r8g.medium"
    R8G_LARGE = "r8g.large"
    R8G_XLARGE = "r8g.xlarge"
    R8G_2XLARGE = "r8g.2xlarge"
    R8G_4XLARGE = "r8g.4xlarge"
    R8G_8XLARGE = "r8g.8xlarge"
    R8G_12XLARGE = "r8g.12xlarge"
    R8G_16XLARGE = "r8g.16xlarge"
    R8G_24XLARGE = "r8g.24xlarge"
    R8G_48XLARGE = "r8g.48xlarge"
    M4_16XLARGE = "m4.16xlarge"
    C6A_32XLARGE = "c6a.32xlarge"
    C6A_48XLARGE = "c6a.48xlarge"
    C6I_32XLARGE = "c6i.32xlarge"
    R6I_24XLARGE = "r6i.24xlarge"
    R6I_32XLARGE = "r6i.32xlarge"
    C6IN_24XLARGE = "c6in.24xlarge"
    C6IN_32XLARGE = "c6in.32xlarge"
    C7A_24XLARGE = "c7a.24xlarge"
    C7A_32XLARGE = "c7a.32xlarge"
    C7A_48XLARGE = "c7a.48xlarge"
    C7I_24XLARGE = "c7i.24xlarge"
    C7I_48XLARGE = "c7i.48xlarge"
    M6A_24XLARGE = "m6a.24xlarge"
    M6A_32XLARGE = "m6a.32xlarge"
    M6A_48XLARGE = "m6a.48xlarge"
    M6I_24XLARGE = "m6i.24xlarge"
    M6I_32XLARGE = "m6i.32xlarge"
    M7A_24XLARGE = "m7a.24xlarge"
    M7A_32XLARGE = "m7a.32xlarge"
    M7A_48XLARGE = "m7a.48xlarge"
    M7I_24XLARGE = "m7i.24xlarge"
    M7I_48XLARGE = "m7i.48xlarge"
    R7A_24XLARGE = "r7a.24xlarge"
    R7A_32XLARGE = "r7a.32xlarge"
    R7A_48XLARGE = "r7a.48xlarge"


class EventCode:
    """EventCode enum values."""

    GENERIC_EVENT = "GENERIC_EVENT"
    FLEET_CREATED = "FLEET_CREATED"
    FLEET_DELETED = "FLEET_DELETED"
    FLEET_SCALING_EVENT = "FLEET_SCALING_EVENT"
    FLEET_STATE_DOWNLOADING = "FLEET_STATE_DOWNLOADING"
    FLEET_STATE_VALIDATING = "FLEET_STATE_VALIDATING"
    FLEET_STATE_BUILDING = "FLEET_STATE_BUILDING"
    FLEET_STATE_ACTIVATING = "FLEET_STATE_ACTIVATING"
    FLEET_STATE_ACTIVE = "FLEET_STATE_ACTIVE"
    FLEET_STATE_ERROR = "FLEET_STATE_ERROR"
    FLEET_STATE_PENDING = "FLEET_STATE_PENDING"
    FLEET_STATE_CREATING = "FLEET_STATE_CREATING"
    FLEET_STATE_CREATED = "FLEET_STATE_CREATED"
    FLEET_STATE_UPDATING = "FLEET_STATE_UPDATING"
    FLEET_INITIALIZATION_FAILED = "FLEET_INITIALIZATION_FAILED"
    FLEET_BINARY_DOWNLOAD_FAILED = "FLEET_BINARY_DOWNLOAD_FAILED"
    FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND = "FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND"
    FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE = "FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE"
    FLEET_VALIDATION_TIMED_OUT = "FLEET_VALIDATION_TIMED_OUT"
    FLEET_ACTIVATION_FAILED = "FLEET_ACTIVATION_FAILED"
    FLEET_ACTIVATION_FAILED_NO_INSTANCES = "FLEET_ACTIVATION_FAILED_NO_INSTANCES"
    FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED = "FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED"
    SERVER_PROCESS_INVALID_PATH = "SERVER_PROCESS_INVALID_PATH"
    SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT = "SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT"
    SERVER_PROCESS_PROCESS_READY_TIMEOUT = "SERVER_PROCESS_PROCESS_READY_TIMEOUT"
    SERVER_PROCESS_CRASHED = "SERVER_PROCESS_CRASHED"
    SERVER_PROCESS_TERMINATED_UNHEALTHY = "SERVER_PROCESS_TERMINATED_UNHEALTHY"
    SERVER_PROCESS_FORCE_TERMINATED = "SERVER_PROCESS_FORCE_TERMINATED"
    SERVER_PROCESS_PROCESS_EXIT_TIMEOUT = "SERVER_PROCESS_PROCESS_EXIT_TIMEOUT"
    SERVER_PROCESS_SDK_INITIALIZATION_FAILED = "SERVER_PROCESS_SDK_INITIALIZATION_FAILED"
    SERVER_PROCESS_MISCONFIGURED_CONTAINER_PORT = "SERVER_PROCESS_MISCONFIGURED_CONTAINER_PORT"
    GAME_SESSION_ACTIVATION_TIMEOUT = "GAME_SESSION_ACTIVATION_TIMEOUT"
    FLEET_CREATION_EXTRACTING_BUILD = "FLEET_CREATION_EXTRACTING_BUILD"
    FLEET_CREATION_RUNNING_INSTALLER = "FLEET_CREATION_RUNNING_INSTALLER"
    FLEET_CREATION_VALIDATING_RUNTIME_CONFIG = "FLEET_CREATION_VALIDATING_RUNTIME_CONFIG"
    FLEET_VPC_PEERING_SUCCEEDED = "FLEET_VPC_PEERING_SUCCEEDED"
    FLEET_VPC_PEERING_FAILED = "FLEET_VPC_PEERING_FAILED"
    FLEET_VPC_PEERING_DELETED = "FLEET_VPC_PEERING_DELETED"
    INSTANCE_INTERRUPTED = "INSTANCE_INTERRUPTED"
    INSTANCE_RECYCLED = "INSTANCE_RECYCLED"
    INSTANCE_REPLACED_UNHEALTHY = "INSTANCE_REPLACED_UNHEALTHY"
    FLEET_CREATION_COMPLETED_INSTALLER = "FLEET_CREATION_COMPLETED_INSTALLER"
    FLEET_CREATION_FAILED_INSTALLER = "FLEET_CREATION_FAILED_INSTALLER"
    COMPUTE_LOG_UPLOAD_FAILED = "COMPUTE_LOG_UPLOAD_FAILED"
    GAME_SERVER_CONTAINER_GROUP_CRASHED = "GAME_SERVER_CONTAINER_GROUP_CRASHED"
    PER_INSTANCE_CONTAINER_GROUP_CRASHED = "PER_INSTANCE_CONTAINER_GROUP_CRASHED"
    GAME_SERVER_CONTAINER_GROUP_REPLACED_UNHEALTHY = "GAME_SERVER_CONTAINER_GROUP_REPLACED_UNHEALTHY"
    LOCATION_STATE_PENDING = "LOCATION_STATE_PENDING"
    LOCATION_STATE_CREATING = "LOCATION_STATE_CREATING"
    LOCATION_STATE_CREATED = "LOCATION_STATE_CREATED"
    LOCATION_STATE_ACTIVATING = "LOCATION_STATE_ACTIVATING"
    LOCATION_STATE_ACTIVE = "LOCATION_STATE_ACTIVE"
    LOCATION_STATE_UPDATING = "LOCATION_STATE_UPDATING"
    LOCATION_STATE_ERROR = "LOCATION_STATE_ERROR"
    LOCATION_STATE_DELETING = "LOCATION_STATE_DELETING"
    LOCATION_STATE_DELETED = "LOCATION_STATE_DELETED"


class FilterInstanceStatus:
    """FilterInstanceStatus enum values."""

    ACTIVE = "ACTIVE"
    DRAINING = "DRAINING"


class FleetAction:
    """FleetAction enum values."""

    AUTO_SCALING = "AUTO_SCALING"


class FleetStatus:
    """FleetStatus enum values."""

    NEW = "NEW"
    DOWNLOADING = "DOWNLOADING"
    VALIDATING = "VALIDATING"
    BUILDING = "BUILDING"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DELETING = "DELETING"
    ERROR = "ERROR"
    TERMINATED = "TERMINATED"
    NOT_FOUND = "NOT_FOUND"


class FleetType:
    """FleetType enum values."""

    ON_DEMAND = "ON_DEMAND"
    SPOT = "SPOT"


class FlexMatchMode:
    """FlexMatchMode enum values."""

    STANDALONE = "STANDALONE"
    WITH_QUEUE = "WITH_QUEUE"


class GameServerClaimStatus:
    """GameServerClaimStatus enum values."""

    CLAIMED = "CLAIMED"


class GameServerGroupAction:
    """GameServerGroupAction enum values."""

    REPLACE_INSTANCE_TYPES = "REPLACE_INSTANCE_TYPES"


class GameServerGroupDeleteOption:
    """GameServerGroupDeleteOption enum values."""

    SAFE_DELETE = "SAFE_DELETE"
    FORCE_DELETE = "FORCE_DELETE"
    RETAIN = "RETAIN"


class GameServerGroupInstanceType:
    """GameServerGroupInstanceType enum values."""

    C4_LARGE = "c4.large"
    C4_XLARGE = "c4.xlarge"
    C4_2XLARGE = "c4.2xlarge"
    C4_4XLARGE = "c4.4xlarge"
    C4_8XLARGE = "c4.8xlarge"
    C5_LARGE = "c5.large"
    C5_XLARGE = "c5.xlarge"
    C5_2XLARGE = "c5.2xlarge"
    C5_4XLARGE = "c5.4xlarge"
    C5_9XLARGE = "c5.9xlarge"
    C5_12XLARGE = "c5.12xlarge"
    C5_18XLARGE = "c5.18xlarge"
    C5_24XLARGE = "c5.24xlarge"
    C5A_LARGE = "c5a.large"
    C5A_XLARGE = "c5a.xlarge"
    C5A_2XLARGE = "c5a.2xlarge"
    C5A_4XLARGE = "c5a.4xlarge"
    C5A_8XLARGE = "c5a.8xlarge"
    C5A_12XLARGE = "c5a.12xlarge"
    C5A_16XLARGE = "c5a.16xlarge"
    C5A_24XLARGE = "c5a.24xlarge"
    C6G_MEDIUM = "c6g.medium"
    C6G_LARGE = "c6g.large"
    C6G_XLARGE = "c6g.xlarge"
    C6G_2XLARGE = "c6g.2xlarge"
    C6G_4XLARGE = "c6g.4xlarge"
    C6G_8XLARGE = "c6g.8xlarge"
    C6G_12XLARGE = "c6g.12xlarge"
    C6G_16XLARGE = "c6g.16xlarge"
    R4_LARGE = "r4.large"
    R4_XLARGE = "r4.xlarge"
    R4_2XLARGE = "r4.2xlarge"
    R4_4XLARGE = "r4.4xlarge"
    R4_8XLARGE = "r4.8xlarge"
    R4_16XLARGE = "r4.16xlarge"
    R5_LARGE = "r5.large"
    R5_XLARGE = "r5.xlarge"
    R5_2XLARGE = "r5.2xlarge"
    R5_4XLARGE = "r5.4xlarge"
    R5_8XLARGE = "r5.8xlarge"
    R5_12XLARGE = "r5.12xlarge"
    R5_16XLARGE = "r5.16xlarge"
    R5_24XLARGE = "r5.24xlarge"
    R5A_LARGE = "r5a.large"
    R5A_XLARGE = "r5a.xlarge"
    R5A_2XLARGE = "r5a.2xlarge"
    R5A_4XLARGE = "r5a.4xlarge"
    R5A_8XLARGE = "r5a.8xlarge"
    R5A_12XLARGE = "r5a.12xlarge"
    R5A_16XLARGE = "r5a.16xlarge"
    R5A_24XLARGE = "r5a.24xlarge"
    R6G_MEDIUM = "r6g.medium"
    R6G_LARGE = "r6g.large"
    R6G_XLARGE = "r6g.xlarge"
    R6G_2XLARGE = "r6g.2xlarge"
    R6G_4XLARGE = "r6g.4xlarge"
    R6G_8XLARGE = "r6g.8xlarge"
    R6G_12XLARGE = "r6g.12xlarge"
    R6G_16XLARGE = "r6g.16xlarge"
    M4_LARGE = "m4.large"
    M4_XLARGE = "m4.xlarge"
    M4_2XLARGE = "m4.2xlarge"
    M4_4XLARGE = "m4.4xlarge"
    M4_10XLARGE = "m4.10xlarge"
    M5_LARGE = "m5.large"
    M5_XLARGE = "m5.xlarge"
    M5_2XLARGE = "m5.2xlarge"
    M5_4XLARGE = "m5.4xlarge"
    M5_8XLARGE = "m5.8xlarge"
    M5_12XLARGE = "m5.12xlarge"
    M5_16XLARGE = "m5.16xlarge"
    M5_24XLARGE = "m5.24xlarge"
    M5A_LARGE = "m5a.large"
    M5A_XLARGE = "m5a.xlarge"
    M5A_2XLARGE = "m5a.2xlarge"
    M5A_4XLARGE = "m5a.4xlarge"
    M5A_8XLARGE = "m5a.8xlarge"
    M5A_12XLARGE = "m5a.12xlarge"
    M5A_16XLARGE = "m5a.16xlarge"
    M5A_24XLARGE = "m5a.24xlarge"
    M6G_MEDIUM = "m6g.medium"
    M6G_LARGE = "m6g.large"
    M6G_XLARGE = "m6g.xlarge"
    M6G_2XLARGE = "m6g.2xlarge"
    M6G_4XLARGE = "m6g.4xlarge"
    M6G_8XLARGE = "m6g.8xlarge"
    M6G_12XLARGE = "m6g.12xlarge"
    M6G_16XLARGE = "m6g.16xlarge"


class GameServerGroupStatus:
    """GameServerGroupStatus enum values."""

    NEW = "NEW"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DELETE_SCHEDULED = "DELETE_SCHEDULED"
    DELETING = "DELETING"
    DELETED = "DELETED"
    ERROR = "ERROR"


class GameServerHealthCheck:
    """GameServerHealthCheck enum values."""

    HEALTHY = "HEALTHY"


class GameServerInstanceStatus:
    """GameServerInstanceStatus enum values."""

    ACTIVE = "ACTIVE"
    DRAINING = "DRAINING"
    SPOT_TERMINATING = "SPOT_TERMINATING"


class GameServerProtectionPolicy:
    """GameServerProtectionPolicy enum values."""

    NO_PROTECTION = "NO_PROTECTION"
    FULL_PROTECTION = "FULL_PROTECTION"


class GameServerUtilizationStatus:
    """GameServerUtilizationStatus enum values."""

    AVAILABLE = "AVAILABLE"
    UTILIZED = "UTILIZED"


class GameSessionPlacementState:
    """GameSessionPlacementState enum values."""

    PENDING = "PENDING"
    FULFILLED = "FULFILLED"
    CANCELLED = "CANCELLED"
    TIMED_OUT = "TIMED_OUT"
    FAILED = "FAILED"


class GameSessionStatus:
    """GameSessionStatus enum values."""

    ACTIVE = "ACTIVE"
    ACTIVATING = "ACTIVATING"
    TERMINATED = "TERMINATED"
    TERMINATING = "TERMINATING"
    ERROR = "ERROR"


class GameSessionStatusReason:
    """GameSessionStatusReason enum values."""

    INTERRUPTED = "INTERRUPTED"
    TRIGGERED_ON_PROCESS_TERMINATE = "TRIGGERED_ON_PROCESS_TERMINATE"
    FORCE_TERMINATED = "FORCE_TERMINATED"


class InstanceRoleCredentialsProvider:
    """InstanceRoleCredentialsProvider enum values."""

    SHARED_CREDENTIAL_FILE = "SHARED_CREDENTIAL_FILE"


class InstanceStatus:
    """InstanceStatus enum values."""

    PENDING = "PENDING"
    ACTIVE = "ACTIVE"
    TERMINATING = "TERMINATING"


class IpProtocol:
    """IpProtocol enum values."""

    TCP = "TCP"
    UDP = "UDP"


class ListComputeInputStatus:
    """ListComputeInputStatus enum values."""

    ACTIVE = "ACTIVE"
    IMPAIRED = "IMPAIRED"


class LocationFilter:
    """LocationFilter enum values."""

    AWS = "AWS"
    CUSTOM = "CUSTOM"


class LocationUpdateStatus:
    """LocationUpdateStatus enum values."""

    PENDING_UPDATE = "PENDING_UPDATE"


class LogDestination:
    """LogDestination enum values."""

    NONE = "NONE"
    CLOUDWATCH = "CLOUDWATCH"
    S3 = "S3"


class MatchmakingConfigurationStatus:
    """MatchmakingConfigurationStatus enum values."""

    CANCELLED = "CANCELLED"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    PLACING = "PLACING"
    QUEUED = "QUEUED"
    REQUIRES_ACCEPTANCE = "REQUIRES_ACCEPTANCE"
    SEARCHING = "SEARCHING"
    TIMED_OUT = "TIMED_OUT"


class MetricName:
    """MetricName enum values."""

    ACTIVATINGGAMESESSIONS = "ActivatingGameSessions"
    ACTIVEGAMESESSIONS = "ActiveGameSessions"
    ACTIVEINSTANCES = "ActiveInstances"
    AVAILABLEGAMESESSIONS = "AvailableGameSessions"
    AVAILABLEPLAYERSESSIONS = "AvailablePlayerSessions"
    CURRENTPLAYERSESSIONS = "CurrentPlayerSessions"
    IDLEINSTANCES = "IdleInstances"
    PERCENTAVAILABLEGAMESESSIONS = "PercentAvailableGameSessions"
    PERCENTIDLEINSTANCES = "PercentIdleInstances"
    QUEUEDEPTH = "QueueDepth"
    WAITTIME = "WaitTime"
    CONCURRENTACTIVATABLEGAMESESSIONS = "ConcurrentActivatableGameSessions"


class OperatingSystem:
    """OperatingSystem enum values."""

    WINDOWS_2012 = "WINDOWS_2012"
    AMAZON_LINUX = "AMAZON_LINUX"
    AMAZON_LINUX_2 = "AMAZON_LINUX_2"
    WINDOWS_2016 = "WINDOWS_2016"
    AMAZON_LINUX_2023 = "AMAZON_LINUX_2023"
    WINDOWS_2022 = "WINDOWS_2022"


class PlacementFallbackStrategy:
    """PlacementFallbackStrategy enum values."""

    DEFAULT_AFTER_SINGLE_PASS = "DEFAULT_AFTER_SINGLE_PASS"
    NONE = "NONE"


class PlayerSessionCreationPolicy:
    """PlayerSessionCreationPolicy enum values."""

    ACCEPT_ALL = "ACCEPT_ALL"
    DENY_ALL = "DENY_ALL"


class PlayerSessionStatus:
    """PlayerSessionStatus enum values."""

    RESERVED = "RESERVED"
    ACTIVE = "ACTIVE"
    COMPLETED = "COMPLETED"
    TIMEDOUT = "TIMEDOUT"


class PolicyType:
    """PolicyType enum values."""

    RULEBASED = "RuleBased"
    TARGETBASED = "TargetBased"


class PriorityType:
    """PriorityType enum values."""

    LATENCY = "LATENCY"
    COST = "COST"
    DESTINATION = "DESTINATION"
    LOCATION = "LOCATION"


class ProtectionPolicy:
    """ProtectionPolicy enum values."""

    NOPROTECTION = "NoProtection"
    FULLPROTECTION = "FullProtection"


class RoutingStrategyType:
    """RoutingStrategyType enum values."""

    SIMPLE = "SIMPLE"
    TERMINAL = "TERMINAL"


class ScalingAdjustmentType:
    """ScalingAdjustmentType enum values."""

    CHANGEINCAPACITY = "ChangeInCapacity"
    EXACTCAPACITY = "ExactCapacity"
    PERCENTCHANGEINCAPACITY = "PercentChangeInCapacity"


class ScalingStatusType:
    """ScalingStatusType enum values."""

    ACTIVE = "ACTIVE"
    UPDATE_REQUESTED = "UPDATE_REQUESTED"
    UPDATING = "UPDATING"
    DELETE_REQUESTED = "DELETE_REQUESTED"
    DELETING = "DELETING"
    DELETED = "DELETED"
    ERROR = "ERROR"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class TerminationMode:
    """TerminationMode enum values."""

    TRIGGER_ON_PROCESS_TERMINATE = "TRIGGER_ON_PROCESS_TERMINATE"
    FORCE_TERMINATE = "FORCE_TERMINATE"


# Convenient aliases for enum values
ACCEPT = AcceptanceType.ACCEPT
REJECT = AcceptanceType.REJECT
AUTOMATIC = BackfillMode.AUTOMATIC
MANUAL = BackfillMode.MANUAL
SPOT_ONLY = BalancingStrategy.SPOT_ONLY
SPOT_PREFERRED = BalancingStrategy.SPOT_PREFERRED
ON_DEMAND_ONLY = BalancingStrategy.ON_DEMAND_ONLY
INITIALIZED = BuildStatus.INITIALIZED
READY = BuildStatus.READY
FAILED = BuildStatus.FAILED
DISABLED = CertificateType.DISABLED
GENERATED = CertificateType.GENERATED
GREATERTHANOREQUALTOTHRESHOLD = ComparisonOperatorType.GREATERTHANOREQUALTOTHRESHOLD
GREATERTHANTHRESHOLD = ComparisonOperatorType.GREATERTHANTHRESHOLD
LESSTHANTHRESHOLD = ComparisonOperatorType.LESSTHANTHRESHOLD
LESSTHANOREQUALTOTHRESHOLD = ComparisonOperatorType.LESSTHANOREQUALTOTHRESHOLD
PENDING = ComputeStatus.PENDING
ACTIVE = ComputeStatus.ACTIVE
TERMINATING = ComputeStatus.TERMINATING
IMPAIRED = ComputeStatus.IMPAIRED
EC2 = ComputeType.EC2
ANYWHERE = ComputeType.ANYWHERE
START = ContainerDependencyCondition.START
COMPLETE = ContainerDependencyCondition.COMPLETE
SUCCESS = ContainerDependencyCondition.SUCCESS
HEALTHY = ContainerDependencyCondition.HEALTHY
ON_DEMAND = ContainerFleetBillingType.ON_DEMAND
SPOT = ContainerFleetBillingType.SPOT
PENDING = ContainerFleetLocationStatus.PENDING
CREATING = ContainerFleetLocationStatus.CREATING
CREATED = ContainerFleetLocationStatus.CREATED
ACTIVATING = ContainerFleetLocationStatus.ACTIVATING
ACTIVE = ContainerFleetLocationStatus.ACTIVE
UPDATING = ContainerFleetLocationStatus.UPDATING
DELETING = ContainerFleetLocationStatus.DELETING
PER_INSTANCE_CONTAINER_GROUP_DEFINITION = ContainerFleetRemoveAttribute.PER_INSTANCE_CONTAINER_GROUP_DEFINITION
PENDING = ContainerFleetStatus.PENDING
CREATING = ContainerFleetStatus.CREATING
CREATED = ContainerFleetStatus.CREATED
ACTIVATING = ContainerFleetStatus.ACTIVATING
ACTIVE = ContainerFleetStatus.ACTIVE
UPDATING = ContainerFleetStatus.UPDATING
DELETING = ContainerFleetStatus.DELETING
READY = ContainerGroupDefinitionStatus.READY
COPYING = ContainerGroupDefinitionStatus.COPYING
FAILED = ContainerGroupDefinitionStatus.FAILED
GAME_SERVER = ContainerGroupType.GAME_SERVER
PER_INSTANCE = ContainerGroupType.PER_INSTANCE
READ_ONLY = ContainerMountPointAccessLevel.READ_ONLY
READ_AND_WRITE = ContainerMountPointAccessLevel.READ_AND_WRITE
AMAZON_LINUX_2023 = ContainerOperatingSystem.AMAZON_LINUX_2023
MAINTAIN = DeploymentImpairmentStrategy.MAINTAIN
ROLLBACK = DeploymentImpairmentStrategy.ROLLBACK
WITH_PROTECTION = DeploymentProtectionStrategy.WITH_PROTECTION
IGNORE_PROTECTION = DeploymentProtectionStrategy.IGNORE_PROTECTION
IN_PROGRESS = DeploymentStatus.IN_PROGRESS
IMPAIRED = DeploymentStatus.IMPAIRED
COMPLETE = DeploymentStatus.COMPLETE
ROLLBACK_IN_PROGRESS = DeploymentStatus.ROLLBACK_IN_PROGRESS
ROLLBACK_COMPLETE = DeploymentStatus.ROLLBACK_COMPLETE
CANCELLED = DeploymentStatus.CANCELLED
PENDING = DeploymentStatus.PENDING
T2_MICRO = EC2InstanceType.T2_MICRO
T2_SMALL = EC2InstanceType.T2_SMALL
T2_MEDIUM = EC2InstanceType.T2_MEDIUM
T2_LARGE = EC2InstanceType.T2_LARGE
C3_LARGE = EC2InstanceType.C3_LARGE
C3_XLARGE = EC2InstanceType.C3_XLARGE
C3_2XLARGE = EC2InstanceType.C3_2XLARGE
C3_4XLARGE = EC2InstanceType.C3_4XLARGE
C3_8XLARGE = EC2InstanceType.C3_8XLARGE
C4_LARGE = EC2InstanceType.C4_LARGE
C4_XLARGE = EC2InstanceType.C4_XLARGE
C4_2XLARGE = EC2InstanceType.C4_2XLARGE
C4_4XLARGE = EC2InstanceType.C4_4XLARGE
C4_8XLARGE = EC2InstanceType.C4_8XLARGE
C5_LARGE = EC2InstanceType.C5_LARGE
C5_XLARGE = EC2InstanceType.C5_XLARGE
C5_2XLARGE = EC2InstanceType.C5_2XLARGE
C5_4XLARGE = EC2InstanceType.C5_4XLARGE
C5_9XLARGE = EC2InstanceType.C5_9XLARGE
C5_12XLARGE = EC2InstanceType.C5_12XLARGE
C5_18XLARGE = EC2InstanceType.C5_18XLARGE
C5_24XLARGE = EC2InstanceType.C5_24XLARGE
C5A_LARGE = EC2InstanceType.C5A_LARGE
C5A_XLARGE = EC2InstanceType.C5A_XLARGE
C5A_2XLARGE = EC2InstanceType.C5A_2XLARGE
C5A_4XLARGE = EC2InstanceType.C5A_4XLARGE
C5A_8XLARGE = EC2InstanceType.C5A_8XLARGE
C5A_12XLARGE = EC2InstanceType.C5A_12XLARGE
C5A_16XLARGE = EC2InstanceType.C5A_16XLARGE
C5A_24XLARGE = EC2InstanceType.C5A_24XLARGE
R3_LARGE = EC2InstanceType.R3_LARGE
R3_XLARGE = EC2InstanceType.R3_XLARGE
R3_2XLARGE = EC2InstanceType.R3_2XLARGE
R3_4XLARGE = EC2InstanceType.R3_4XLARGE
R3_8XLARGE = EC2InstanceType.R3_8XLARGE
R4_LARGE = EC2InstanceType.R4_LARGE
R4_XLARGE = EC2InstanceType.R4_XLARGE
R4_2XLARGE = EC2InstanceType.R4_2XLARGE
R4_4XLARGE = EC2InstanceType.R4_4XLARGE
R4_8XLARGE = EC2InstanceType.R4_8XLARGE
R4_16XLARGE = EC2InstanceType.R4_16XLARGE
R5_LARGE = EC2InstanceType.R5_LARGE
R5_XLARGE = EC2InstanceType.R5_XLARGE
R5_2XLARGE = EC2InstanceType.R5_2XLARGE
R5_4XLARGE = EC2InstanceType.R5_4XLARGE
R5_8XLARGE = EC2InstanceType.R5_8XLARGE
R5_12XLARGE = EC2InstanceType.R5_12XLARGE
R5_16XLARGE = EC2InstanceType.R5_16XLARGE
R5_24XLARGE = EC2InstanceType.R5_24XLARGE
R5A_LARGE = EC2InstanceType.R5A_LARGE
R5A_XLARGE = EC2InstanceType.R5A_XLARGE
R5A_2XLARGE = EC2InstanceType.R5A_2XLARGE
R5A_4XLARGE = EC2InstanceType.R5A_4XLARGE
R5A_8XLARGE = EC2InstanceType.R5A_8XLARGE
R5A_12XLARGE = EC2InstanceType.R5A_12XLARGE
R5A_16XLARGE = EC2InstanceType.R5A_16XLARGE
R5A_24XLARGE = EC2InstanceType.R5A_24XLARGE
M3_MEDIUM = EC2InstanceType.M3_MEDIUM
M3_LARGE = EC2InstanceType.M3_LARGE
M3_XLARGE = EC2InstanceType.M3_XLARGE
M3_2XLARGE = EC2InstanceType.M3_2XLARGE
M4_LARGE = EC2InstanceType.M4_LARGE
M4_XLARGE = EC2InstanceType.M4_XLARGE
M4_2XLARGE = EC2InstanceType.M4_2XLARGE
M4_4XLARGE = EC2InstanceType.M4_4XLARGE
M4_10XLARGE = EC2InstanceType.M4_10XLARGE
M5_LARGE = EC2InstanceType.M5_LARGE
M5_XLARGE = EC2InstanceType.M5_XLARGE
M5_2XLARGE = EC2InstanceType.M5_2XLARGE
M5_4XLARGE = EC2InstanceType.M5_4XLARGE
M5_8XLARGE = EC2InstanceType.M5_8XLARGE
M5_12XLARGE = EC2InstanceType.M5_12XLARGE
M5_16XLARGE = EC2InstanceType.M5_16XLARGE
M5_24XLARGE = EC2InstanceType.M5_24XLARGE
M5A_LARGE = EC2InstanceType.M5A_LARGE
M5A_XLARGE = EC2InstanceType.M5A_XLARGE
M5A_2XLARGE = EC2InstanceType.M5A_2XLARGE
M5A_4XLARGE = EC2InstanceType.M5A_4XLARGE
M5A_8XLARGE = EC2InstanceType.M5A_8XLARGE
M5A_12XLARGE = EC2InstanceType.M5A_12XLARGE
M5A_16XLARGE = EC2InstanceType.M5A_16XLARGE
M5A_24XLARGE = EC2InstanceType.M5A_24XLARGE
C5D_LARGE = EC2InstanceType.C5D_LARGE
C5D_XLARGE = EC2InstanceType.C5D_XLARGE
C5D_2XLARGE = EC2InstanceType.C5D_2XLARGE
C5D_4XLARGE = EC2InstanceType.C5D_4XLARGE
C5D_9XLARGE = EC2InstanceType.C5D_9XLARGE
C5D_12XLARGE = EC2InstanceType.C5D_12XLARGE
C5D_18XLARGE = EC2InstanceType.C5D_18XLARGE
C5D_24XLARGE = EC2InstanceType.C5D_24XLARGE
C6A_LARGE = EC2InstanceType.C6A_LARGE
C6A_XLARGE = EC2InstanceType.C6A_XLARGE
C6A_2XLARGE = EC2InstanceType.C6A_2XLARGE
C6A_4XLARGE = EC2InstanceType.C6A_4XLARGE
C6A_8XLARGE = EC2InstanceType.C6A_8XLARGE
C6A_12XLARGE = EC2InstanceType.C6A_12XLARGE
C6A_16XLARGE = EC2InstanceType.C6A_16XLARGE
C6A_24XLARGE = EC2InstanceType.C6A_24XLARGE
C6I_LARGE = EC2InstanceType.C6I_LARGE
C6I_XLARGE = EC2InstanceType.C6I_XLARGE
C6I_2XLARGE = EC2InstanceType.C6I_2XLARGE
C6I_4XLARGE = EC2InstanceType.C6I_4XLARGE
C6I_8XLARGE = EC2InstanceType.C6I_8XLARGE
C6I_12XLARGE = EC2InstanceType.C6I_12XLARGE
C6I_16XLARGE = EC2InstanceType.C6I_16XLARGE
C6I_24XLARGE = EC2InstanceType.C6I_24XLARGE
R5D_LARGE = EC2InstanceType.R5D_LARGE
R5D_XLARGE = EC2InstanceType.R5D_XLARGE
R5D_2XLARGE = EC2InstanceType.R5D_2XLARGE
R5D_4XLARGE = EC2InstanceType.R5D_4XLARGE
R5D_8XLARGE = EC2InstanceType.R5D_8XLARGE
R5D_12XLARGE = EC2InstanceType.R5D_12XLARGE
R5D_16XLARGE = EC2InstanceType.R5D_16XLARGE
R5D_24XLARGE = EC2InstanceType.R5D_24XLARGE
M6G_MEDIUM = EC2InstanceType.M6G_MEDIUM
M6G_LARGE = EC2InstanceType.M6G_LARGE
M6G_XLARGE = EC2InstanceType.M6G_XLARGE
M6G_2XLARGE = EC2InstanceType.M6G_2XLARGE
M6G_4XLARGE = EC2InstanceType.M6G_4XLARGE
M6G_8XLARGE = EC2InstanceType.M6G_8XLARGE
M6G_12XLARGE = EC2InstanceType.M6G_12XLARGE
M6G_16XLARGE = EC2InstanceType.M6G_16XLARGE
C6G_MEDIUM = EC2InstanceType.C6G_MEDIUM
C6G_LARGE = EC2InstanceType.C6G_LARGE
C6G_XLARGE = EC2InstanceType.C6G_XLARGE
C6G_2XLARGE = EC2InstanceType.C6G_2XLARGE
C6G_4XLARGE = EC2InstanceType.C6G_4XLARGE
C6G_8XLARGE = EC2InstanceType.C6G_8XLARGE
C6G_12XLARGE = EC2InstanceType.C6G_12XLARGE
C6G_16XLARGE = EC2InstanceType.C6G_16XLARGE
R6G_MEDIUM = EC2InstanceType.R6G_MEDIUM
R6G_LARGE = EC2InstanceType.R6G_LARGE
R6G_XLARGE = EC2InstanceType.R6G_XLARGE
R6G_2XLARGE = EC2InstanceType.R6G_2XLARGE
R6G_4XLARGE = EC2InstanceType.R6G_4XLARGE
R6G_8XLARGE = EC2InstanceType.R6G_8XLARGE
R6G_12XLARGE = EC2InstanceType.R6G_12XLARGE
R6G_16XLARGE = EC2InstanceType.R6G_16XLARGE
C6GN_MEDIUM = EC2InstanceType.C6GN_MEDIUM
C6GN_LARGE = EC2InstanceType.C6GN_LARGE
C6GN_XLARGE = EC2InstanceType.C6GN_XLARGE
C6GN_2XLARGE = EC2InstanceType.C6GN_2XLARGE
C6GN_4XLARGE = EC2InstanceType.C6GN_4XLARGE
C6GN_8XLARGE = EC2InstanceType.C6GN_8XLARGE
C6GN_12XLARGE = EC2InstanceType.C6GN_12XLARGE
C6GN_16XLARGE = EC2InstanceType.C6GN_16XLARGE
C7G_MEDIUM = EC2InstanceType.C7G_MEDIUM
C7G_LARGE = EC2InstanceType.C7G_LARGE
C7G_XLARGE = EC2InstanceType.C7G_XLARGE
C7G_2XLARGE = EC2InstanceType.C7G_2XLARGE
C7G_4XLARGE = EC2InstanceType.C7G_4XLARGE
C7G_8XLARGE = EC2InstanceType.C7G_8XLARGE
C7G_12XLARGE = EC2InstanceType.C7G_12XLARGE
C7G_16XLARGE = EC2InstanceType.C7G_16XLARGE
R7G_MEDIUM = EC2InstanceType.R7G_MEDIUM
R7G_LARGE = EC2InstanceType.R7G_LARGE
R7G_XLARGE = EC2InstanceType.R7G_XLARGE
R7G_2XLARGE = EC2InstanceType.R7G_2XLARGE
R7G_4XLARGE = EC2InstanceType.R7G_4XLARGE
R7G_8XLARGE = EC2InstanceType.R7G_8XLARGE
R7G_12XLARGE = EC2InstanceType.R7G_12XLARGE
R7G_16XLARGE = EC2InstanceType.R7G_16XLARGE
M7G_MEDIUM = EC2InstanceType.M7G_MEDIUM
M7G_LARGE = EC2InstanceType.M7G_LARGE
M7G_XLARGE = EC2InstanceType.M7G_XLARGE
M7G_2XLARGE = EC2InstanceType.M7G_2XLARGE
M7G_4XLARGE = EC2InstanceType.M7G_4XLARGE
M7G_8XLARGE = EC2InstanceType.M7G_8XLARGE
M7G_12XLARGE = EC2InstanceType.M7G_12XLARGE
M7G_16XLARGE = EC2InstanceType.M7G_16XLARGE
G5G_XLARGE = EC2InstanceType.G5G_XLARGE
G5G_2XLARGE = EC2InstanceType.G5G_2XLARGE
G5G_4XLARGE = EC2InstanceType.G5G_4XLARGE
G5G_8XLARGE = EC2InstanceType.G5G_8XLARGE
G5G_16XLARGE = EC2InstanceType.G5G_16XLARGE
R6I_LARGE = EC2InstanceType.R6I_LARGE
R6I_XLARGE = EC2InstanceType.R6I_XLARGE
R6I_2XLARGE = EC2InstanceType.R6I_2XLARGE
R6I_4XLARGE = EC2InstanceType.R6I_4XLARGE
R6I_8XLARGE = EC2InstanceType.R6I_8XLARGE
R6I_12XLARGE = EC2InstanceType.R6I_12XLARGE
R6I_16XLARGE = EC2InstanceType.R6I_16XLARGE
C6GD_MEDIUM = EC2InstanceType.C6GD_MEDIUM
C6GD_LARGE = EC2InstanceType.C6GD_LARGE
C6GD_XLARGE = EC2InstanceType.C6GD_XLARGE
C6GD_2XLARGE = EC2InstanceType.C6GD_2XLARGE
C6GD_4XLARGE = EC2InstanceType.C6GD_4XLARGE
C6GD_8XLARGE = EC2InstanceType.C6GD_8XLARGE
C6GD_12XLARGE = EC2InstanceType.C6GD_12XLARGE
C6GD_16XLARGE = EC2InstanceType.C6GD_16XLARGE
C6IN_LARGE = EC2InstanceType.C6IN_LARGE
C6IN_XLARGE = EC2InstanceType.C6IN_XLARGE
C6IN_2XLARGE = EC2InstanceType.C6IN_2XLARGE
C6IN_4XLARGE = EC2InstanceType.C6IN_4XLARGE
C6IN_8XLARGE = EC2InstanceType.C6IN_8XLARGE
C6IN_12XLARGE = EC2InstanceType.C6IN_12XLARGE
C6IN_16XLARGE = EC2InstanceType.C6IN_16XLARGE
C7A_MEDIUM = EC2InstanceType.C7A_MEDIUM
C7A_LARGE = EC2InstanceType.C7A_LARGE
C7A_XLARGE = EC2InstanceType.C7A_XLARGE
C7A_2XLARGE = EC2InstanceType.C7A_2XLARGE
C7A_4XLARGE = EC2InstanceType.C7A_4XLARGE
C7A_8XLARGE = EC2InstanceType.C7A_8XLARGE
C7A_12XLARGE = EC2InstanceType.C7A_12XLARGE
C7A_16XLARGE = EC2InstanceType.C7A_16XLARGE
C7GD_MEDIUM = EC2InstanceType.C7GD_MEDIUM
C7GD_LARGE = EC2InstanceType.C7GD_LARGE
C7GD_XLARGE = EC2InstanceType.C7GD_XLARGE
C7GD_2XLARGE = EC2InstanceType.C7GD_2XLARGE
C7GD_4XLARGE = EC2InstanceType.C7GD_4XLARGE
C7GD_8XLARGE = EC2InstanceType.C7GD_8XLARGE
C7GD_12XLARGE = EC2InstanceType.C7GD_12XLARGE
C7GD_16XLARGE = EC2InstanceType.C7GD_16XLARGE
C7GN_MEDIUM = EC2InstanceType.C7GN_MEDIUM
C7GN_LARGE = EC2InstanceType.C7GN_LARGE
C7GN_XLARGE = EC2InstanceType.C7GN_XLARGE
C7GN_2XLARGE = EC2InstanceType.C7GN_2XLARGE
C7GN_4XLARGE = EC2InstanceType.C7GN_4XLARGE
C7GN_8XLARGE = EC2InstanceType.C7GN_8XLARGE
C7GN_12XLARGE = EC2InstanceType.C7GN_12XLARGE
C7GN_16XLARGE = EC2InstanceType.C7GN_16XLARGE
C7I_LARGE = EC2InstanceType.C7I_LARGE
C7I_XLARGE = EC2InstanceType.C7I_XLARGE
C7I_2XLARGE = EC2InstanceType.C7I_2XLARGE
C7I_4XLARGE = EC2InstanceType.C7I_4XLARGE
C7I_8XLARGE = EC2InstanceType.C7I_8XLARGE
C7I_12XLARGE = EC2InstanceType.C7I_12XLARGE
C7I_16XLARGE = EC2InstanceType.C7I_16XLARGE
M6A_LARGE = EC2InstanceType.M6A_LARGE
M6A_XLARGE = EC2InstanceType.M6A_XLARGE
M6A_2XLARGE = EC2InstanceType.M6A_2XLARGE
M6A_4XLARGE = EC2InstanceType.M6A_4XLARGE
M6A_8XLARGE = EC2InstanceType.M6A_8XLARGE
M6A_12XLARGE = EC2InstanceType.M6A_12XLARGE
M6A_16XLARGE = EC2InstanceType.M6A_16XLARGE
M6GD_MEDIUM = EC2InstanceType.M6GD_MEDIUM
M6GD_LARGE = EC2InstanceType.M6GD_LARGE
M6GD_XLARGE = EC2InstanceType.M6GD_XLARGE
M6GD_2XLARGE = EC2InstanceType.M6GD_2XLARGE
M6GD_4XLARGE = EC2InstanceType.M6GD_4XLARGE
M6GD_8XLARGE = EC2InstanceType.M6GD_8XLARGE
M6GD_12XLARGE = EC2InstanceType.M6GD_12XLARGE
M6GD_16XLARGE = EC2InstanceType.M6GD_16XLARGE
M6I_LARGE = EC2InstanceType.M6I_LARGE
M6I_XLARGE = EC2InstanceType.M6I_XLARGE
M6I_2XLARGE = EC2InstanceType.M6I_2XLARGE
M6I_4XLARGE = EC2InstanceType.M6I_4XLARGE
M6I_8XLARGE = EC2InstanceType.M6I_8XLARGE
M6I_12XLARGE = EC2InstanceType.M6I_12XLARGE
M6I_16XLARGE = EC2InstanceType.M6I_16XLARGE
M7A_MEDIUM = EC2InstanceType.M7A_MEDIUM
M7A_LARGE = EC2InstanceType.M7A_LARGE
M7A_XLARGE = EC2InstanceType.M7A_XLARGE
M7A_2XLARGE = EC2InstanceType.M7A_2XLARGE
M7A_4XLARGE = EC2InstanceType.M7A_4XLARGE
M7A_8XLARGE = EC2InstanceType.M7A_8XLARGE
M7A_12XLARGE = EC2InstanceType.M7A_12XLARGE
M7A_16XLARGE = EC2InstanceType.M7A_16XLARGE
M7GD_MEDIUM = EC2InstanceType.M7GD_MEDIUM
M7GD_LARGE = EC2InstanceType.M7GD_LARGE
M7GD_XLARGE = EC2InstanceType.M7GD_XLARGE
M7GD_2XLARGE = EC2InstanceType.M7GD_2XLARGE
M7GD_4XLARGE = EC2InstanceType.M7GD_4XLARGE
M7GD_8XLARGE = EC2InstanceType.M7GD_8XLARGE
M7GD_12XLARGE = EC2InstanceType.M7GD_12XLARGE
M7GD_16XLARGE = EC2InstanceType.M7GD_16XLARGE
M7I_LARGE = EC2InstanceType.M7I_LARGE
M7I_XLARGE = EC2InstanceType.M7I_XLARGE
M7I_2XLARGE = EC2InstanceType.M7I_2XLARGE
M7I_4XLARGE = EC2InstanceType.M7I_4XLARGE
M7I_8XLARGE = EC2InstanceType.M7I_8XLARGE
M7I_12XLARGE = EC2InstanceType.M7I_12XLARGE
M7I_16XLARGE = EC2InstanceType.M7I_16XLARGE
R6GD_MEDIUM = EC2InstanceType.R6GD_MEDIUM
R6GD_LARGE = EC2InstanceType.R6GD_LARGE
R6GD_XLARGE = EC2InstanceType.R6GD_XLARGE
R6GD_2XLARGE = EC2InstanceType.R6GD_2XLARGE
R6GD_4XLARGE = EC2InstanceType.R6GD_4XLARGE
R6GD_8XLARGE = EC2InstanceType.R6GD_8XLARGE
R6GD_12XLARGE = EC2InstanceType.R6GD_12XLARGE
R6GD_16XLARGE = EC2InstanceType.R6GD_16XLARGE
R7A_MEDIUM = EC2InstanceType.R7A_MEDIUM
R7A_LARGE = EC2InstanceType.R7A_LARGE
R7A_XLARGE = EC2InstanceType.R7A_XLARGE
R7A_2XLARGE = EC2InstanceType.R7A_2XLARGE
R7A_4XLARGE = EC2InstanceType.R7A_4XLARGE
R7A_8XLARGE = EC2InstanceType.R7A_8XLARGE
R7A_12XLARGE = EC2InstanceType.R7A_12XLARGE
R7A_16XLARGE = EC2InstanceType.R7A_16XLARGE
R7GD_MEDIUM = EC2InstanceType.R7GD_MEDIUM
R7GD_LARGE = EC2InstanceType.R7GD_LARGE
R7GD_XLARGE = EC2InstanceType.R7GD_XLARGE
R7GD_2XLARGE = EC2InstanceType.R7GD_2XLARGE
R7GD_4XLARGE = EC2InstanceType.R7GD_4XLARGE
R7GD_8XLARGE = EC2InstanceType.R7GD_8XLARGE
R7GD_12XLARGE = EC2InstanceType.R7GD_12XLARGE
R7GD_16XLARGE = EC2InstanceType.R7GD_16XLARGE
R7I_LARGE = EC2InstanceType.R7I_LARGE
R7I_XLARGE = EC2InstanceType.R7I_XLARGE
R7I_2XLARGE = EC2InstanceType.R7I_2XLARGE
R7I_4XLARGE = EC2InstanceType.R7I_4XLARGE
R7I_8XLARGE = EC2InstanceType.R7I_8XLARGE
R7I_12XLARGE = EC2InstanceType.R7I_12XLARGE
R7I_16XLARGE = EC2InstanceType.R7I_16XLARGE
R7I_24XLARGE = EC2InstanceType.R7I_24XLARGE
R7I_48XLARGE = EC2InstanceType.R7I_48XLARGE
C5AD_LARGE = EC2InstanceType.C5AD_LARGE
C5AD_XLARGE = EC2InstanceType.C5AD_XLARGE
C5AD_2XLARGE = EC2InstanceType.C5AD_2XLARGE
C5AD_4XLARGE = EC2InstanceType.C5AD_4XLARGE
C5AD_8XLARGE = EC2InstanceType.C5AD_8XLARGE
C5AD_12XLARGE = EC2InstanceType.C5AD_12XLARGE
C5AD_16XLARGE = EC2InstanceType.C5AD_16XLARGE
C5AD_24XLARGE = EC2InstanceType.C5AD_24XLARGE
C5N_LARGE = EC2InstanceType.C5N_LARGE
C5N_XLARGE = EC2InstanceType.C5N_XLARGE
C5N_2XLARGE = EC2InstanceType.C5N_2XLARGE
C5N_4XLARGE = EC2InstanceType.C5N_4XLARGE
C5N_9XLARGE = EC2InstanceType.C5N_9XLARGE
C5N_18XLARGE = EC2InstanceType.C5N_18XLARGE
R5AD_LARGE = EC2InstanceType.R5AD_LARGE
R5AD_XLARGE = EC2InstanceType.R5AD_XLARGE
R5AD_2XLARGE = EC2InstanceType.R5AD_2XLARGE
R5AD_4XLARGE = EC2InstanceType.R5AD_4XLARGE
R5AD_8XLARGE = EC2InstanceType.R5AD_8XLARGE
R5AD_12XLARGE = EC2InstanceType.R5AD_12XLARGE
R5AD_16XLARGE = EC2InstanceType.R5AD_16XLARGE
R5AD_24XLARGE = EC2InstanceType.R5AD_24XLARGE
C6ID_LARGE = EC2InstanceType.C6ID_LARGE
C6ID_XLARGE = EC2InstanceType.C6ID_XLARGE
C6ID_2XLARGE = EC2InstanceType.C6ID_2XLARGE
C6ID_4XLARGE = EC2InstanceType.C6ID_4XLARGE
C6ID_8XLARGE = EC2InstanceType.C6ID_8XLARGE
C6ID_12XLARGE = EC2InstanceType.C6ID_12XLARGE
C6ID_16XLARGE = EC2InstanceType.C6ID_16XLARGE
C6ID_24XLARGE = EC2InstanceType.C6ID_24XLARGE
C6ID_32XLARGE = EC2InstanceType.C6ID_32XLARGE
C8G_MEDIUM = EC2InstanceType.C8G_MEDIUM
C8G_LARGE = EC2InstanceType.C8G_LARGE
C8G_XLARGE = EC2InstanceType.C8G_XLARGE
C8G_2XLARGE = EC2InstanceType.C8G_2XLARGE
C8G_4XLARGE = EC2InstanceType.C8G_4XLARGE
C8G_8XLARGE = EC2InstanceType.C8G_8XLARGE
C8G_12XLARGE = EC2InstanceType.C8G_12XLARGE
C8G_16XLARGE = EC2InstanceType.C8G_16XLARGE
C8G_24XLARGE = EC2InstanceType.C8G_24XLARGE
C8G_48XLARGE = EC2InstanceType.C8G_48XLARGE
M5AD_LARGE = EC2InstanceType.M5AD_LARGE
M5AD_XLARGE = EC2InstanceType.M5AD_XLARGE
M5AD_2XLARGE = EC2InstanceType.M5AD_2XLARGE
M5AD_4XLARGE = EC2InstanceType.M5AD_4XLARGE
M5AD_8XLARGE = EC2InstanceType.M5AD_8XLARGE
M5AD_12XLARGE = EC2InstanceType.M5AD_12XLARGE
M5AD_16XLARGE = EC2InstanceType.M5AD_16XLARGE
M5AD_24XLARGE = EC2InstanceType.M5AD_24XLARGE
M5D_LARGE = EC2InstanceType.M5D_LARGE
M5D_XLARGE = EC2InstanceType.M5D_XLARGE
M5D_2XLARGE = EC2InstanceType.M5D_2XLARGE
M5D_4XLARGE = EC2InstanceType.M5D_4XLARGE
M5D_8XLARGE = EC2InstanceType.M5D_8XLARGE
M5D_12XLARGE = EC2InstanceType.M5D_12XLARGE
M5D_16XLARGE = EC2InstanceType.M5D_16XLARGE
M5D_24XLARGE = EC2InstanceType.M5D_24XLARGE
M5DN_LARGE = EC2InstanceType.M5DN_LARGE
M5DN_XLARGE = EC2InstanceType.M5DN_XLARGE
M5DN_2XLARGE = EC2InstanceType.M5DN_2XLARGE
M5DN_4XLARGE = EC2InstanceType.M5DN_4XLARGE
M5DN_8XLARGE = EC2InstanceType.M5DN_8XLARGE
M5DN_12XLARGE = EC2InstanceType.M5DN_12XLARGE
M5DN_16XLARGE = EC2InstanceType.M5DN_16XLARGE
M5DN_24XLARGE = EC2InstanceType.M5DN_24XLARGE
M5N_LARGE = EC2InstanceType.M5N_LARGE
M5N_XLARGE = EC2InstanceType.M5N_XLARGE
M5N_2XLARGE = EC2InstanceType.M5N_2XLARGE
M5N_4XLARGE = EC2InstanceType.M5N_4XLARGE
M5N_8XLARGE = EC2InstanceType.M5N_8XLARGE
M5N_12XLARGE = EC2InstanceType.M5N_12XLARGE
M5N_16XLARGE = EC2InstanceType.M5N_16XLARGE
M5N_24XLARGE = EC2InstanceType.M5N_24XLARGE
M6ID_LARGE = EC2InstanceType.M6ID_LARGE
M6ID_XLARGE = EC2InstanceType.M6ID_XLARGE
M6ID_2XLARGE = EC2InstanceType.M6ID_2XLARGE
M6ID_4XLARGE = EC2InstanceType.M6ID_4XLARGE
M6ID_8XLARGE = EC2InstanceType.M6ID_8XLARGE
M6ID_12XLARGE = EC2InstanceType.M6ID_12XLARGE
M6ID_16XLARGE = EC2InstanceType.M6ID_16XLARGE
M6ID_24XLARGE = EC2InstanceType.M6ID_24XLARGE
M6ID_32XLARGE = EC2InstanceType.M6ID_32XLARGE
M6IDN_LARGE = EC2InstanceType.M6IDN_LARGE
M6IDN_XLARGE = EC2InstanceType.M6IDN_XLARGE
M6IDN_2XLARGE = EC2InstanceType.M6IDN_2XLARGE
M6IDN_4XLARGE = EC2InstanceType.M6IDN_4XLARGE
M6IDN_8XLARGE = EC2InstanceType.M6IDN_8XLARGE
M6IDN_12XLARGE = EC2InstanceType.M6IDN_12XLARGE
M6IDN_16XLARGE = EC2InstanceType.M6IDN_16XLARGE
M6IDN_24XLARGE = EC2InstanceType.M6IDN_24XLARGE
M6IDN_32XLARGE = EC2InstanceType.M6IDN_32XLARGE
M6IN_LARGE = EC2InstanceType.M6IN_LARGE
M6IN_XLARGE = EC2InstanceType.M6IN_XLARGE
M6IN_2XLARGE = EC2InstanceType.M6IN_2XLARGE
M6IN_4XLARGE = EC2InstanceType.M6IN_4XLARGE
M6IN_8XLARGE = EC2InstanceType.M6IN_8XLARGE
M6IN_12XLARGE = EC2InstanceType.M6IN_12XLARGE
M6IN_16XLARGE = EC2InstanceType.M6IN_16XLARGE
M6IN_24XLARGE = EC2InstanceType.M6IN_24XLARGE
M6IN_32XLARGE = EC2InstanceType.M6IN_32XLARGE
M8G_MEDIUM = EC2InstanceType.M8G_MEDIUM
M8G_LARGE = EC2InstanceType.M8G_LARGE
M8G_XLARGE = EC2InstanceType.M8G_XLARGE
M8G_2XLARGE = EC2InstanceType.M8G_2XLARGE
M8G_4XLARGE = EC2InstanceType.M8G_4XLARGE
M8G_8XLARGE = EC2InstanceType.M8G_8XLARGE
M8G_12XLARGE = EC2InstanceType.M8G_12XLARGE
M8G_16XLARGE = EC2InstanceType.M8G_16XLARGE
M8G_24XLARGE = EC2InstanceType.M8G_24XLARGE
M8G_48XLARGE = EC2InstanceType.M8G_48XLARGE
R5DN_LARGE = EC2InstanceType.R5DN_LARGE
R5DN_XLARGE = EC2InstanceType.R5DN_XLARGE
R5DN_2XLARGE = EC2InstanceType.R5DN_2XLARGE
R5DN_4XLARGE = EC2InstanceType.R5DN_4XLARGE
R5DN_8XLARGE = EC2InstanceType.R5DN_8XLARGE
R5DN_12XLARGE = EC2InstanceType.R5DN_12XLARGE
R5DN_16XLARGE = EC2InstanceType.R5DN_16XLARGE
R5DN_24XLARGE = EC2InstanceType.R5DN_24XLARGE
R5N_LARGE = EC2InstanceType.R5N_LARGE
R5N_XLARGE = EC2InstanceType.R5N_XLARGE
R5N_2XLARGE = EC2InstanceType.R5N_2XLARGE
R5N_4XLARGE = EC2InstanceType.R5N_4XLARGE
R5N_8XLARGE = EC2InstanceType.R5N_8XLARGE
R5N_12XLARGE = EC2InstanceType.R5N_12XLARGE
R5N_16XLARGE = EC2InstanceType.R5N_16XLARGE
R5N_24XLARGE = EC2InstanceType.R5N_24XLARGE
R6A_LARGE = EC2InstanceType.R6A_LARGE
R6A_XLARGE = EC2InstanceType.R6A_XLARGE
R6A_2XLARGE = EC2InstanceType.R6A_2XLARGE
R6A_4XLARGE = EC2InstanceType.R6A_4XLARGE
R6A_8XLARGE = EC2InstanceType.R6A_8XLARGE
R6A_12XLARGE = EC2InstanceType.R6A_12XLARGE
R6A_16XLARGE = EC2InstanceType.R6A_16XLARGE
R6A_24XLARGE = EC2InstanceType.R6A_24XLARGE
R6A_32XLARGE = EC2InstanceType.R6A_32XLARGE
R6A_48XLARGE = EC2InstanceType.R6A_48XLARGE
R6ID_LARGE = EC2InstanceType.R6ID_LARGE
R6ID_XLARGE = EC2InstanceType.R6ID_XLARGE
R6ID_2XLARGE = EC2InstanceType.R6ID_2XLARGE
R6ID_4XLARGE = EC2InstanceType.R6ID_4XLARGE
R6ID_8XLARGE = EC2InstanceType.R6ID_8XLARGE
R6ID_12XLARGE = EC2InstanceType.R6ID_12XLARGE
R6ID_16XLARGE = EC2InstanceType.R6ID_16XLARGE
R6ID_24XLARGE = EC2InstanceType.R6ID_24XLARGE
R6ID_32XLARGE = EC2InstanceType.R6ID_32XLARGE
R6IDN_LARGE = EC2InstanceType.R6IDN_LARGE
R6IDN_XLARGE = EC2InstanceType.R6IDN_XLARGE
R6IDN_2XLARGE = EC2InstanceType.R6IDN_2XLARGE
R6IDN_4XLARGE = EC2InstanceType.R6IDN_4XLARGE
R6IDN_8XLARGE = EC2InstanceType.R6IDN_8XLARGE
R6IDN_12XLARGE = EC2InstanceType.R6IDN_12XLARGE
R6IDN_16XLARGE = EC2InstanceType.R6IDN_16XLARGE
R6IDN_24XLARGE = EC2InstanceType.R6IDN_24XLARGE
R6IDN_32XLARGE = EC2InstanceType.R6IDN_32XLARGE
R6IN_LARGE = EC2InstanceType.R6IN_LARGE
R6IN_XLARGE = EC2InstanceType.R6IN_XLARGE
R6IN_2XLARGE = EC2InstanceType.R6IN_2XLARGE
R6IN_4XLARGE = EC2InstanceType.R6IN_4XLARGE
R6IN_8XLARGE = EC2InstanceType.R6IN_8XLARGE
R6IN_12XLARGE = EC2InstanceType.R6IN_12XLARGE
R6IN_16XLARGE = EC2InstanceType.R6IN_16XLARGE
R6IN_24XLARGE = EC2InstanceType.R6IN_24XLARGE
R6IN_32XLARGE = EC2InstanceType.R6IN_32XLARGE
R8G_MEDIUM = EC2InstanceType.R8G_MEDIUM
R8G_LARGE = EC2InstanceType.R8G_LARGE
R8G_XLARGE = EC2InstanceType.R8G_XLARGE
R8G_2XLARGE = EC2InstanceType.R8G_2XLARGE
R8G_4XLARGE = EC2InstanceType.R8G_4XLARGE
R8G_8XLARGE = EC2InstanceType.R8G_8XLARGE
R8G_12XLARGE = EC2InstanceType.R8G_12XLARGE
R8G_16XLARGE = EC2InstanceType.R8G_16XLARGE
R8G_24XLARGE = EC2InstanceType.R8G_24XLARGE
R8G_48XLARGE = EC2InstanceType.R8G_48XLARGE
M4_16XLARGE = EC2InstanceType.M4_16XLARGE
C6A_32XLARGE = EC2InstanceType.C6A_32XLARGE
C6A_48XLARGE = EC2InstanceType.C6A_48XLARGE
C6I_32XLARGE = EC2InstanceType.C6I_32XLARGE
R6I_24XLARGE = EC2InstanceType.R6I_24XLARGE
R6I_32XLARGE = EC2InstanceType.R6I_32XLARGE
C6IN_24XLARGE = EC2InstanceType.C6IN_24XLARGE
C6IN_32XLARGE = EC2InstanceType.C6IN_32XLARGE
C7A_24XLARGE = EC2InstanceType.C7A_24XLARGE
C7A_32XLARGE = EC2InstanceType.C7A_32XLARGE
C7A_48XLARGE = EC2InstanceType.C7A_48XLARGE
C7I_24XLARGE = EC2InstanceType.C7I_24XLARGE
C7I_48XLARGE = EC2InstanceType.C7I_48XLARGE
M6A_24XLARGE = EC2InstanceType.M6A_24XLARGE
M6A_32XLARGE = EC2InstanceType.M6A_32XLARGE
M6A_48XLARGE = EC2InstanceType.M6A_48XLARGE
M6I_24XLARGE = EC2InstanceType.M6I_24XLARGE
M6I_32XLARGE = EC2InstanceType.M6I_32XLARGE
M7A_24XLARGE = EC2InstanceType.M7A_24XLARGE
M7A_32XLARGE = EC2InstanceType.M7A_32XLARGE
M7A_48XLARGE = EC2InstanceType.M7A_48XLARGE
M7I_24XLARGE = EC2InstanceType.M7I_24XLARGE
M7I_48XLARGE = EC2InstanceType.M7I_48XLARGE
R7A_24XLARGE = EC2InstanceType.R7A_24XLARGE
R7A_32XLARGE = EC2InstanceType.R7A_32XLARGE
R7A_48XLARGE = EC2InstanceType.R7A_48XLARGE
GENERIC_EVENT = EventCode.GENERIC_EVENT
FLEET_CREATED = EventCode.FLEET_CREATED
FLEET_DELETED = EventCode.FLEET_DELETED
FLEET_SCALING_EVENT = EventCode.FLEET_SCALING_EVENT
FLEET_STATE_DOWNLOADING = EventCode.FLEET_STATE_DOWNLOADING
FLEET_STATE_VALIDATING = EventCode.FLEET_STATE_VALIDATING
FLEET_STATE_BUILDING = EventCode.FLEET_STATE_BUILDING
FLEET_STATE_ACTIVATING = EventCode.FLEET_STATE_ACTIVATING
FLEET_STATE_ACTIVE = EventCode.FLEET_STATE_ACTIVE
FLEET_STATE_ERROR = EventCode.FLEET_STATE_ERROR
FLEET_STATE_PENDING = EventCode.FLEET_STATE_PENDING
FLEET_STATE_CREATING = EventCode.FLEET_STATE_CREATING
FLEET_STATE_CREATED = EventCode.FLEET_STATE_CREATED
FLEET_STATE_UPDATING = EventCode.FLEET_STATE_UPDATING
FLEET_INITIALIZATION_FAILED = EventCode.FLEET_INITIALIZATION_FAILED
FLEET_BINARY_DOWNLOAD_FAILED = EventCode.FLEET_BINARY_DOWNLOAD_FAILED
FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND = EventCode.FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND
FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE = EventCode.FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE
FLEET_VALIDATION_TIMED_OUT = EventCode.FLEET_VALIDATION_TIMED_OUT
FLEET_ACTIVATION_FAILED = EventCode.FLEET_ACTIVATION_FAILED
FLEET_ACTIVATION_FAILED_NO_INSTANCES = EventCode.FLEET_ACTIVATION_FAILED_NO_INSTANCES
FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED = EventCode.FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED
SERVER_PROCESS_INVALID_PATH = EventCode.SERVER_PROCESS_INVALID_PATH
SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT = EventCode.SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT
SERVER_PROCESS_PROCESS_READY_TIMEOUT = EventCode.SERVER_PROCESS_PROCESS_READY_TIMEOUT
SERVER_PROCESS_CRASHED = EventCode.SERVER_PROCESS_CRASHED
SERVER_PROCESS_TERMINATED_UNHEALTHY = EventCode.SERVER_PROCESS_TERMINATED_UNHEALTHY
SERVER_PROCESS_FORCE_TERMINATED = EventCode.SERVER_PROCESS_FORCE_TERMINATED
SERVER_PROCESS_PROCESS_EXIT_TIMEOUT = EventCode.SERVER_PROCESS_PROCESS_EXIT_TIMEOUT
SERVER_PROCESS_SDK_INITIALIZATION_FAILED = EventCode.SERVER_PROCESS_SDK_INITIALIZATION_FAILED
SERVER_PROCESS_MISCONFIGURED_CONTAINER_PORT = EventCode.SERVER_PROCESS_MISCONFIGURED_CONTAINER_PORT
GAME_SESSION_ACTIVATION_TIMEOUT = EventCode.GAME_SESSION_ACTIVATION_TIMEOUT
FLEET_CREATION_EXTRACTING_BUILD = EventCode.FLEET_CREATION_EXTRACTING_BUILD
FLEET_CREATION_RUNNING_INSTALLER = EventCode.FLEET_CREATION_RUNNING_INSTALLER
FLEET_CREATION_VALIDATING_RUNTIME_CONFIG = EventCode.FLEET_CREATION_VALIDATING_RUNTIME_CONFIG
FLEET_VPC_PEERING_SUCCEEDED = EventCode.FLEET_VPC_PEERING_SUCCEEDED
FLEET_VPC_PEERING_FAILED = EventCode.FLEET_VPC_PEERING_FAILED
FLEET_VPC_PEERING_DELETED = EventCode.FLEET_VPC_PEERING_DELETED
INSTANCE_INTERRUPTED = EventCode.INSTANCE_INTERRUPTED
INSTANCE_RECYCLED = EventCode.INSTANCE_RECYCLED
INSTANCE_REPLACED_UNHEALTHY = EventCode.INSTANCE_REPLACED_UNHEALTHY
FLEET_CREATION_COMPLETED_INSTALLER = EventCode.FLEET_CREATION_COMPLETED_INSTALLER
FLEET_CREATION_FAILED_INSTALLER = EventCode.FLEET_CREATION_FAILED_INSTALLER
COMPUTE_LOG_UPLOAD_FAILED = EventCode.COMPUTE_LOG_UPLOAD_FAILED
GAME_SERVER_CONTAINER_GROUP_CRASHED = EventCode.GAME_SERVER_CONTAINER_GROUP_CRASHED
PER_INSTANCE_CONTAINER_GROUP_CRASHED = EventCode.PER_INSTANCE_CONTAINER_GROUP_CRASHED
GAME_SERVER_CONTAINER_GROUP_REPLACED_UNHEALTHY = EventCode.GAME_SERVER_CONTAINER_GROUP_REPLACED_UNHEALTHY
LOCATION_STATE_PENDING = EventCode.LOCATION_STATE_PENDING
LOCATION_STATE_CREATING = EventCode.LOCATION_STATE_CREATING
LOCATION_STATE_CREATED = EventCode.LOCATION_STATE_CREATED
LOCATION_STATE_ACTIVATING = EventCode.LOCATION_STATE_ACTIVATING
LOCATION_STATE_ACTIVE = EventCode.LOCATION_STATE_ACTIVE
LOCATION_STATE_UPDATING = EventCode.LOCATION_STATE_UPDATING
LOCATION_STATE_ERROR = EventCode.LOCATION_STATE_ERROR
LOCATION_STATE_DELETING = EventCode.LOCATION_STATE_DELETING
LOCATION_STATE_DELETED = EventCode.LOCATION_STATE_DELETED
ACTIVE = FilterInstanceStatus.ACTIVE
DRAINING = FilterInstanceStatus.DRAINING
AUTO_SCALING = FleetAction.AUTO_SCALING
NEW = FleetStatus.NEW
DOWNLOADING = FleetStatus.DOWNLOADING
VALIDATING = FleetStatus.VALIDATING
BUILDING = FleetStatus.BUILDING
ACTIVATING = FleetStatus.ACTIVATING
ACTIVE = FleetStatus.ACTIVE
DELETING = FleetStatus.DELETING
ERROR = FleetStatus.ERROR
TERMINATED = FleetStatus.TERMINATED
NOT_FOUND = FleetStatus.NOT_FOUND
ON_DEMAND = FleetType.ON_DEMAND
SPOT = FleetType.SPOT
STANDALONE = FlexMatchMode.STANDALONE
WITH_QUEUE = FlexMatchMode.WITH_QUEUE
CLAIMED = GameServerClaimStatus.CLAIMED
REPLACE_INSTANCE_TYPES = GameServerGroupAction.REPLACE_INSTANCE_TYPES
SAFE_DELETE = GameServerGroupDeleteOption.SAFE_DELETE
FORCE_DELETE = GameServerGroupDeleteOption.FORCE_DELETE
RETAIN = GameServerGroupDeleteOption.RETAIN
C4_LARGE = GameServerGroupInstanceType.C4_LARGE
C4_XLARGE = GameServerGroupInstanceType.C4_XLARGE
C4_2XLARGE = GameServerGroupInstanceType.C4_2XLARGE
C4_4XLARGE = GameServerGroupInstanceType.C4_4XLARGE
C4_8XLARGE = GameServerGroupInstanceType.C4_8XLARGE
C5_LARGE = GameServerGroupInstanceType.C5_LARGE
C5_XLARGE = GameServerGroupInstanceType.C5_XLARGE
C5_2XLARGE = GameServerGroupInstanceType.C5_2XLARGE
C5_4XLARGE = GameServerGroupInstanceType.C5_4XLARGE
C5_9XLARGE = GameServerGroupInstanceType.C5_9XLARGE
C5_12XLARGE = GameServerGroupInstanceType.C5_12XLARGE
C5_18XLARGE = GameServerGroupInstanceType.C5_18XLARGE
C5_24XLARGE = GameServerGroupInstanceType.C5_24XLARGE
C5A_LARGE = GameServerGroupInstanceType.C5A_LARGE
C5A_XLARGE = GameServerGroupInstanceType.C5A_XLARGE
C5A_2XLARGE = GameServerGroupInstanceType.C5A_2XLARGE
C5A_4XLARGE = GameServerGroupInstanceType.C5A_4XLARGE
C5A_8XLARGE = GameServerGroupInstanceType.C5A_8XLARGE
C5A_12XLARGE = GameServerGroupInstanceType.C5A_12XLARGE
C5A_16XLARGE = GameServerGroupInstanceType.C5A_16XLARGE
C5A_24XLARGE = GameServerGroupInstanceType.C5A_24XLARGE
C6G_MEDIUM = GameServerGroupInstanceType.C6G_MEDIUM
C6G_LARGE = GameServerGroupInstanceType.C6G_LARGE
C6G_XLARGE = GameServerGroupInstanceType.C6G_XLARGE
C6G_2XLARGE = GameServerGroupInstanceType.C6G_2XLARGE
C6G_4XLARGE = GameServerGroupInstanceType.C6G_4XLARGE
C6G_8XLARGE = GameServerGroupInstanceType.C6G_8XLARGE
C6G_12XLARGE = GameServerGroupInstanceType.C6G_12XLARGE
C6G_16XLARGE = GameServerGroupInstanceType.C6G_16XLARGE
R4_LARGE = GameServerGroupInstanceType.R4_LARGE
R4_XLARGE = GameServerGroupInstanceType.R4_XLARGE
R4_2XLARGE = GameServerGroupInstanceType.R4_2XLARGE
R4_4XLARGE = GameServerGroupInstanceType.R4_4XLARGE
R4_8XLARGE = GameServerGroupInstanceType.R4_8XLARGE
R4_16XLARGE = GameServerGroupInstanceType.R4_16XLARGE
R5_LARGE = GameServerGroupInstanceType.R5_LARGE
R5_XLARGE = GameServerGroupInstanceType.R5_XLARGE
R5_2XLARGE = GameServerGroupInstanceType.R5_2XLARGE
R5_4XLARGE = GameServerGroupInstanceType.R5_4XLARGE
R5_8XLARGE = GameServerGroupInstanceType.R5_8XLARGE
R5_12XLARGE = GameServerGroupInstanceType.R5_12XLARGE
R5_16XLARGE = GameServerGroupInstanceType.R5_16XLARGE
R5_24XLARGE = GameServerGroupInstanceType.R5_24XLARGE
R5A_LARGE = GameServerGroupInstanceType.R5A_LARGE
R5A_XLARGE = GameServerGroupInstanceType.R5A_XLARGE
R5A_2XLARGE = GameServerGroupInstanceType.R5A_2XLARGE
R5A_4XLARGE = GameServerGroupInstanceType.R5A_4XLARGE
R5A_8XLARGE = GameServerGroupInstanceType.R5A_8XLARGE
R5A_12XLARGE = GameServerGroupInstanceType.R5A_12XLARGE
R5A_16XLARGE = GameServerGroupInstanceType.R5A_16XLARGE
R5A_24XLARGE = GameServerGroupInstanceType.R5A_24XLARGE
R6G_MEDIUM = GameServerGroupInstanceType.R6G_MEDIUM
R6G_LARGE = GameServerGroupInstanceType.R6G_LARGE
R6G_XLARGE = GameServerGroupInstanceType.R6G_XLARGE
R6G_2XLARGE = GameServerGroupInstanceType.R6G_2XLARGE
R6G_4XLARGE = GameServerGroupInstanceType.R6G_4XLARGE
R6G_8XLARGE = GameServerGroupInstanceType.R6G_8XLARGE
R6G_12XLARGE = GameServerGroupInstanceType.R6G_12XLARGE
R6G_16XLARGE = GameServerGroupInstanceType.R6G_16XLARGE
M4_LARGE = GameServerGroupInstanceType.M4_LARGE
M4_XLARGE = GameServerGroupInstanceType.M4_XLARGE
M4_2XLARGE = GameServerGroupInstanceType.M4_2XLARGE
M4_4XLARGE = GameServerGroupInstanceType.M4_4XLARGE
M4_10XLARGE = GameServerGroupInstanceType.M4_10XLARGE
M5_LARGE = GameServerGroupInstanceType.M5_LARGE
M5_XLARGE = GameServerGroupInstanceType.M5_XLARGE
M5_2XLARGE = GameServerGroupInstanceType.M5_2XLARGE
M5_4XLARGE = GameServerGroupInstanceType.M5_4XLARGE
M5_8XLARGE = GameServerGroupInstanceType.M5_8XLARGE
M5_12XLARGE = GameServerGroupInstanceType.M5_12XLARGE
M5_16XLARGE = GameServerGroupInstanceType.M5_16XLARGE
M5_24XLARGE = GameServerGroupInstanceType.M5_24XLARGE
M5A_LARGE = GameServerGroupInstanceType.M5A_LARGE
M5A_XLARGE = GameServerGroupInstanceType.M5A_XLARGE
M5A_2XLARGE = GameServerGroupInstanceType.M5A_2XLARGE
M5A_4XLARGE = GameServerGroupInstanceType.M5A_4XLARGE
M5A_8XLARGE = GameServerGroupInstanceType.M5A_8XLARGE
M5A_12XLARGE = GameServerGroupInstanceType.M5A_12XLARGE
M5A_16XLARGE = GameServerGroupInstanceType.M5A_16XLARGE
M5A_24XLARGE = GameServerGroupInstanceType.M5A_24XLARGE
M6G_MEDIUM = GameServerGroupInstanceType.M6G_MEDIUM
M6G_LARGE = GameServerGroupInstanceType.M6G_LARGE
M6G_XLARGE = GameServerGroupInstanceType.M6G_XLARGE
M6G_2XLARGE = GameServerGroupInstanceType.M6G_2XLARGE
M6G_4XLARGE = GameServerGroupInstanceType.M6G_4XLARGE
M6G_8XLARGE = GameServerGroupInstanceType.M6G_8XLARGE
M6G_12XLARGE = GameServerGroupInstanceType.M6G_12XLARGE
M6G_16XLARGE = GameServerGroupInstanceType.M6G_16XLARGE
NEW = GameServerGroupStatus.NEW
ACTIVATING = GameServerGroupStatus.ACTIVATING
ACTIVE = GameServerGroupStatus.ACTIVE
DELETE_SCHEDULED = GameServerGroupStatus.DELETE_SCHEDULED
DELETING = GameServerGroupStatus.DELETING
DELETED = GameServerGroupStatus.DELETED
ERROR = GameServerGroupStatus.ERROR
HEALTHY = GameServerHealthCheck.HEALTHY
ACTIVE = GameServerInstanceStatus.ACTIVE
DRAINING = GameServerInstanceStatus.DRAINING
SPOT_TERMINATING = GameServerInstanceStatus.SPOT_TERMINATING
NO_PROTECTION = GameServerProtectionPolicy.NO_PROTECTION
FULL_PROTECTION = GameServerProtectionPolicy.FULL_PROTECTION
AVAILABLE = GameServerUtilizationStatus.AVAILABLE
UTILIZED = GameServerUtilizationStatus.UTILIZED
PENDING = GameSessionPlacementState.PENDING
FULFILLED = GameSessionPlacementState.FULFILLED
CANCELLED = GameSessionPlacementState.CANCELLED
TIMED_OUT = GameSessionPlacementState.TIMED_OUT
FAILED = GameSessionPlacementState.FAILED
ACTIVE = GameSessionStatus.ACTIVE
ACTIVATING = GameSessionStatus.ACTIVATING
TERMINATED = GameSessionStatus.TERMINATED
TERMINATING = GameSessionStatus.TERMINATING
ERROR = GameSessionStatus.ERROR
INTERRUPTED = GameSessionStatusReason.INTERRUPTED
TRIGGERED_ON_PROCESS_TERMINATE = GameSessionStatusReason.TRIGGERED_ON_PROCESS_TERMINATE
FORCE_TERMINATED = GameSessionStatusReason.FORCE_TERMINATED
SHARED_CREDENTIAL_FILE = InstanceRoleCredentialsProvider.SHARED_CREDENTIAL_FILE
PENDING = InstanceStatus.PENDING
ACTIVE = InstanceStatus.ACTIVE
TERMINATING = InstanceStatus.TERMINATING
TCP = IpProtocol.TCP
UDP = IpProtocol.UDP
ACTIVE = ListComputeInputStatus.ACTIVE
IMPAIRED = ListComputeInputStatus.IMPAIRED
AWS = LocationFilter.AWS
CUSTOM = LocationFilter.CUSTOM
PENDING_UPDATE = LocationUpdateStatus.PENDING_UPDATE
NONE = LogDestination.NONE
CLOUDWATCH = LogDestination.CLOUDWATCH
S3 = LogDestination.S3
CANCELLED = MatchmakingConfigurationStatus.CANCELLED
COMPLETED = MatchmakingConfigurationStatus.COMPLETED
FAILED = MatchmakingConfigurationStatus.FAILED
PLACING = MatchmakingConfigurationStatus.PLACING
QUEUED = MatchmakingConfigurationStatus.QUEUED
REQUIRES_ACCEPTANCE = MatchmakingConfigurationStatus.REQUIRES_ACCEPTANCE
SEARCHING = MatchmakingConfigurationStatus.SEARCHING
TIMED_OUT = MatchmakingConfigurationStatus.TIMED_OUT
ACTIVATINGGAMESESSIONS = MetricName.ACTIVATINGGAMESESSIONS
ACTIVEGAMESESSIONS = MetricName.ACTIVEGAMESESSIONS
ACTIVEINSTANCES = MetricName.ACTIVEINSTANCES
AVAILABLEGAMESESSIONS = MetricName.AVAILABLEGAMESESSIONS
AVAILABLEPLAYERSESSIONS = MetricName.AVAILABLEPLAYERSESSIONS
CURRENTPLAYERSESSIONS = MetricName.CURRENTPLAYERSESSIONS
IDLEINSTANCES = MetricName.IDLEINSTANCES
PERCENTAVAILABLEGAMESESSIONS = MetricName.PERCENTAVAILABLEGAMESESSIONS
PERCENTIDLEINSTANCES = MetricName.PERCENTIDLEINSTANCES
QUEUEDEPTH = MetricName.QUEUEDEPTH
WAITTIME = MetricName.WAITTIME
CONCURRENTACTIVATABLEGAMESESSIONS = MetricName.CONCURRENTACTIVATABLEGAMESESSIONS
WINDOWS_2012 = OperatingSystem.WINDOWS_2012
AMAZON_LINUX = OperatingSystem.AMAZON_LINUX
AMAZON_LINUX_2 = OperatingSystem.AMAZON_LINUX_2
WINDOWS_2016 = OperatingSystem.WINDOWS_2016
AMAZON_LINUX_2023 = OperatingSystem.AMAZON_LINUX_2023
WINDOWS_2022 = OperatingSystem.WINDOWS_2022
DEFAULT_AFTER_SINGLE_PASS = PlacementFallbackStrategy.DEFAULT_AFTER_SINGLE_PASS
NONE = PlacementFallbackStrategy.NONE
ACCEPT_ALL = PlayerSessionCreationPolicy.ACCEPT_ALL
DENY_ALL = PlayerSessionCreationPolicy.DENY_ALL
RESERVED = PlayerSessionStatus.RESERVED
ACTIVE = PlayerSessionStatus.ACTIVE
COMPLETED = PlayerSessionStatus.COMPLETED
TIMEDOUT = PlayerSessionStatus.TIMEDOUT
RULEBASED = PolicyType.RULEBASED
TARGETBASED = PolicyType.TARGETBASED
LATENCY = PriorityType.LATENCY
COST = PriorityType.COST
DESTINATION = PriorityType.DESTINATION
LOCATION = PriorityType.LOCATION
NOPROTECTION = ProtectionPolicy.NOPROTECTION
FULLPROTECTION = ProtectionPolicy.FULLPROTECTION
SIMPLE = RoutingStrategyType.SIMPLE
TERMINAL = RoutingStrategyType.TERMINAL
CHANGEINCAPACITY = ScalingAdjustmentType.CHANGEINCAPACITY
EXACTCAPACITY = ScalingAdjustmentType.EXACTCAPACITY
PERCENTCHANGEINCAPACITY = ScalingAdjustmentType.PERCENTCHANGEINCAPACITY
ACTIVE = ScalingStatusType.ACTIVE
UPDATE_REQUESTED = ScalingStatusType.UPDATE_REQUESTED
UPDATING = ScalingStatusType.UPDATING
DELETE_REQUESTED = ScalingStatusType.DELETE_REQUESTED
DELETING = ScalingStatusType.DELETING
DELETED = ScalingStatusType.DELETED
ERROR = ScalingStatusType.ERROR
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
TRIGGER_ON_PROCESS_TERMINATE = TerminationMode.TRIGGER_ON_PROCESS_TERMINATE
FORCE_TERMINATE = TerminationMode.FORCE_TERMINATE


@dataclass
class RoutingStrategy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, RoutingStrategyType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fleet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.message is not None:
            if hasattr(self.message, 'to_dict'):
                props['Message'] = self.message.to_dict()
            elif isinstance(self.message, list):
                props['Message'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message
                ]
            else:
                props['Message'] = self.message

        if self.fleet_id is not None:
            if hasattr(self.fleet_id, 'to_dict'):
                props['FleetId'] = self.fleet_id.to_dict()
            elif isinstance(self.fleet_id, list):
                props['FleetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_id
                ]
            else:
                props['FleetId'] = self.fleet_id

        return props


@dataclass
class Alias(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::Alias"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    routing_strategy: Optional[RoutingStrategy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.routing_strategy is not None:
            # Serialize routing_strategy (handle intrinsic functions)
            if hasattr(self.routing_strategy, 'to_dict'):
                props["RoutingStrategy"] = self.routing_strategy.to_dict()
            elif isinstance(self.routing_strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoutingStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.routing_strategy
                ]
            else:
                props["RoutingStrategy"] = self.routing_strategy

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_alias_arn(self) -> GetAtt:
        """Get the AliasArn attribute."""
        return self.get_att("AliasArn")

    @property
    def attr_alias_id(self) -> GetAtt:
        """Get the AliasId attribute."""
        return self.get_att("AliasId")




@dataclass
class StorageLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.object_version is not None:
            if hasattr(self.object_version, 'to_dict'):
                props['ObjectVersion'] = self.object_version.to_dict()
            elif isinstance(self.object_version, list):
                props['ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.object_version
                ]
            else:
                props['ObjectVersion'] = self.object_version

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        return props


@dataclass
class Build(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::Build"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_system: Optional[Union[str, OperatingSystem, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    server_sdk_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    storage_location: Optional[StorageLocation] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.operating_system is not None:
            # Serialize operating_system (handle intrinsic functions)
            if hasattr(self.operating_system, 'to_dict'):
                props["OperatingSystem"] = self.operating_system.to_dict()
            elif isinstance(self.operating_system, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_system
                ]
            else:
                props["OperatingSystem"] = self.operating_system

        if self.version is not None:
            # Serialize version (handle intrinsic functions)
            if hasattr(self.version, 'to_dict'):
                props["Version"] = self.version.to_dict()
            elif isinstance(self.version, list):
                # Serialize list items (may contain intrinsic functions)
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props["Version"] = self.version

        if self.server_sdk_version is not None:
            # Serialize server_sdk_version (handle intrinsic functions)
            if hasattr(self.server_sdk_version, 'to_dict'):
                props["ServerSdkVersion"] = self.server_sdk_version.to_dict()
            elif isinstance(self.server_sdk_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServerSdkVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_sdk_version
                ]
            else:
                props["ServerSdkVersion"] = self.server_sdk_version

        if self.storage_location is not None:
            # Serialize storage_location (handle intrinsic functions)
            if hasattr(self.storage_location, 'to_dict'):
                props["StorageLocation"] = self.storage_location.to_dict()
            elif isinstance(self.storage_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['StorageLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_location
                ]
            else:
                props["StorageLocation"] = self.storage_location

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_build_id(self) -> GetAtt:
        """Get the BuildId attribute."""
        return self.get_att("BuildId")

    @property
    def attr_build_arn(self) -> GetAtt:
        """Get the BuildArn attribute."""
        return self.get_att("BuildArn")




@dataclass
class ConnectionPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class DeploymentConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protection_strategy: Optional[Union[str, DeploymentProtectionStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    impairment_strategy: Optional[Union[str, DeploymentImpairmentStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_healthy_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protection_strategy is not None:
            if hasattr(self.protection_strategy, 'to_dict'):
                props['ProtectionStrategy'] = self.protection_strategy.to_dict()
            elif isinstance(self.protection_strategy, list):
                props['ProtectionStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protection_strategy
                ]
            else:
                props['ProtectionStrategy'] = self.protection_strategy

        if self.impairment_strategy is not None:
            if hasattr(self.impairment_strategy, 'to_dict'):
                props['ImpairmentStrategy'] = self.impairment_strategy.to_dict()
            elif isinstance(self.impairment_strategy, list):
                props['ImpairmentStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.impairment_strategy
                ]
            else:
                props['ImpairmentStrategy'] = self.impairment_strategy

        if self.minimum_healthy_percentage is not None:
            if hasattr(self.minimum_healthy_percentage, 'to_dict'):
                props['MinimumHealthyPercentage'] = self.minimum_healthy_percentage.to_dict()
            elif isinstance(self.minimum_healthy_percentage, list):
                props['MinimumHealthyPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_healthy_percentage
                ]
            else:
                props['MinimumHealthyPercentage'] = self.minimum_healthy_percentage

        return props


@dataclass
class DeploymentDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    latest_deployment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.latest_deployment_id is not None:
            if hasattr(self.latest_deployment_id, 'to_dict'):
                props['LatestDeploymentId'] = self.latest_deployment_id.to_dict()
            elif isinstance(self.latest_deployment_id, list):
                props['LatestDeploymentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.latest_deployment_id
                ]
            else:
                props['LatestDeploymentId'] = self.latest_deployment_id

        return props


@dataclass
class GameSessionCreationLimitPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_period_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    new_game_sessions_per_creator: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_period_in_minutes is not None:
            if hasattr(self.policy_period_in_minutes, 'to_dict'):
                props['PolicyPeriodInMinutes'] = self.policy_period_in_minutes.to_dict()
            elif isinstance(self.policy_period_in_minutes, list):
                props['PolicyPeriodInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_period_in_minutes
                ]
            else:
                props['PolicyPeriodInMinutes'] = self.policy_period_in_minutes

        if self.new_game_sessions_per_creator is not None:
            if hasattr(self.new_game_sessions_per_creator, 'to_dict'):
                props['NewGameSessionsPerCreator'] = self.new_game_sessions_per_creator.to_dict()
            elif isinstance(self.new_game_sessions_per_creator, list):
                props['NewGameSessionsPerCreator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.new_game_sessions_per_creator
                ]
            else:
                props['NewGameSessionsPerCreator'] = self.new_game_sessions_per_creator

        return props


@dataclass
class IpPermission:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, IpProtocol, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ip_range is not None:
            if hasattr(self.ip_range, 'to_dict'):
                props['IpRange'] = self.ip_range.to_dict()
            elif isinstance(self.ip_range, list):
                props['IpRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_range
                ]
            else:
                props['IpRange'] = self.ip_range

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class LocationCapacity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    desired_ec2_instances: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_size is not None:
            if hasattr(self.min_size, 'to_dict'):
                props['MinSize'] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props['MinSize'] = self.min_size

        if self.desired_ec2_instances is not None:
            if hasattr(self.desired_ec2_instances, 'to_dict'):
                props['DesiredEC2Instances'] = self.desired_ec2_instances.to_dict()
            elif isinstance(self.desired_ec2_instances, list):
                props['DesiredEC2Instances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_ec2_instances
                ]
            else:
                props['DesiredEC2Instances'] = self.desired_ec2_instances

        if self.max_size is not None:
            if hasattr(self.max_size, 'to_dict'):
                props['MaxSize'] = self.max_size.to_dict()
            elif isinstance(self.max_size, list):
                props['MaxSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_size
                ]
            else:
                props['MaxSize'] = self.max_size

        return props


@dataclass
class LocationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location_capacity: Optional[LocationCapacity] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stopped_actions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.location_capacity is not None:
            if hasattr(self.location_capacity, 'to_dict'):
                props['LocationCapacity'] = self.location_capacity.to_dict()
            elif isinstance(self.location_capacity, list):
                props['LocationCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location_capacity
                ]
            else:
                props['LocationCapacity'] = self.location_capacity

        if self.stopped_actions is not None:
            if hasattr(self.stopped_actions, 'to_dict'):
                props['StoppedActions'] = self.stopped_actions.to_dict()
            elif isinstance(self.stopped_actions, list):
                props['StoppedActions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopped_actions
                ]
            else:
                props['StoppedActions'] = self.stopped_actions

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class LogConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_destination: Optional[Union[str, LogDestination, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_destination is not None:
            if hasattr(self.log_destination, 'to_dict'):
                props['LogDestination'] = self.log_destination.to_dict()
            elif isinstance(self.log_destination, list):
                props['LogDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_destination
                ]
            else:
                props['LogDestination'] = self.log_destination

        if self.s3_bucket_name is not None:
            if hasattr(self.s3_bucket_name, 'to_dict'):
                props['S3BucketName'] = self.s3_bucket_name.to_dict()
            elif isinstance(self.s3_bucket_name, list):
                props['S3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_name
                ]
            else:
                props['S3BucketName'] = self.s3_bucket_name

        if self.log_group_arn is not None:
            if hasattr(self.log_group_arn, 'to_dict'):
                props['LogGroupArn'] = self.log_group_arn.to_dict()
            elif isinstance(self.log_group_arn, list):
                props['LogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_arn
                ]
            else:
                props['LogGroupArn'] = self.log_group_arn

        return props


@dataclass
class ScalingPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, MetricName, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_type: Optional[Union[str, PolicyType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    comparison_operator: Optional[Union[str, ComparisonOperatorType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_configuration: Optional[TargetConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    evaluation_periods: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment_type: Optional[Union[str, ScalingAdjustmentType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.policy_type is not None:
            if hasattr(self.policy_type, 'to_dict'):
                props['PolicyType'] = self.policy_type.to_dict()
            elif isinstance(self.policy_type, list):
                props['PolicyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_type
                ]
            else:
                props['PolicyType'] = self.policy_type

        if self.comparison_operator is not None:
            if hasattr(self.comparison_operator, 'to_dict'):
                props['ComparisonOperator'] = self.comparison_operator.to_dict()
            elif isinstance(self.comparison_operator, list):
                props['ComparisonOperator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.comparison_operator
                ]
            else:
                props['ComparisonOperator'] = self.comparison_operator

        if self.target_configuration is not None:
            if hasattr(self.target_configuration, 'to_dict'):
                props['TargetConfiguration'] = self.target_configuration.to_dict()
            elif isinstance(self.target_configuration, list):
                props['TargetConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_configuration
                ]
            else:
                props['TargetConfiguration'] = self.target_configuration

        if self.scaling_adjustment is not None:
            if hasattr(self.scaling_adjustment, 'to_dict'):
                props['ScalingAdjustment'] = self.scaling_adjustment.to_dict()
            elif isinstance(self.scaling_adjustment, list):
                props['ScalingAdjustment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment
                ]
            else:
                props['ScalingAdjustment'] = self.scaling_adjustment

        if self.evaluation_periods is not None:
            if hasattr(self.evaluation_periods, 'to_dict'):
                props['EvaluationPeriods'] = self.evaluation_periods.to_dict()
            elif isinstance(self.evaluation_periods, list):
                props['EvaluationPeriods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_periods
                ]
            else:
                props['EvaluationPeriods'] = self.evaluation_periods

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.scaling_adjustment_type is not None:
            if hasattr(self.scaling_adjustment_type, 'to_dict'):
                props['ScalingAdjustmentType'] = self.scaling_adjustment_type.to_dict()
            elif isinstance(self.scaling_adjustment_type, list):
                props['ScalingAdjustmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment_type
                ]
            else:
                props['ScalingAdjustmentType'] = self.scaling_adjustment_type

        if self.threshold is not None:
            if hasattr(self.threshold, 'to_dict'):
                props['Threshold'] = self.threshold.to_dict()
            elif isinstance(self.threshold, list):
                props['Threshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threshold
                ]
            else:
                props['Threshold'] = self.threshold

        return props


@dataclass
class TargetConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        return props


@dataclass
class ContainerFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::ContainerFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_policies: Optional[list[ScalingPolicy]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_server_container_group_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    per_instance_container_group_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    locations: Optional[list[LocationConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_session_creation_limit_policy: Optional[GameSessionCreationLimitPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    new_game_session_protection_policy: Optional[Union[str, ProtectionPolicy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_server_container_groups_per_instance: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_configuration: Optional[LogConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_connection_port_range: Optional[ConnectionPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_inbound_permissions: Optional[list[IpPermission]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_configuration: Optional[DeploymentConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    billing_type: Optional[Union[str, ContainerFleetBillingType, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scaling_policies is not None:
            # Serialize scaling_policies (handle intrinsic functions)
            if hasattr(self.scaling_policies, 'to_dict'):
                props["ScalingPolicies"] = self.scaling_policies.to_dict()
            elif isinstance(self.scaling_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_policies
                ]
            else:
                props["ScalingPolicies"] = self.scaling_policies

        if self.game_server_container_group_definition_name is not None:
            # Serialize game_server_container_group_definition_name (handle intrinsic functions)
            if hasattr(self.game_server_container_group_definition_name, 'to_dict'):
                props["GameServerContainerGroupDefinitionName"] = self.game_server_container_group_definition_name.to_dict()
            elif isinstance(self.game_server_container_group_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameServerContainerGroupDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_server_container_group_definition_name
                ]
            else:
                props["GameServerContainerGroupDefinitionName"] = self.game_server_container_group_definition_name

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.fleet_role_arn is not None:
            # Serialize fleet_role_arn (handle intrinsic functions)
            if hasattr(self.fleet_role_arn, 'to_dict'):
                props["FleetRoleArn"] = self.fleet_role_arn.to_dict()
            elif isinstance(self.fleet_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_role_arn
                ]
            else:
                props["FleetRoleArn"] = self.fleet_role_arn

        if self.per_instance_container_group_definition_name is not None:
            # Serialize per_instance_container_group_definition_name (handle intrinsic functions)
            if hasattr(self.per_instance_container_group_definition_name, 'to_dict'):
                props["PerInstanceContainerGroupDefinitionName"] = self.per_instance_container_group_definition_name.to_dict()
            elif isinstance(self.per_instance_container_group_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PerInstanceContainerGroupDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_instance_container_group_definition_name
                ]
            else:
                props["PerInstanceContainerGroupDefinitionName"] = self.per_instance_container_group_definition_name

        if self.locations is not None:
            # Serialize locations (handle intrinsic functions)
            if hasattr(self.locations, 'to_dict'):
                props["Locations"] = self.locations.to_dict()
            elif isinstance(self.locations, list):
                # Serialize list items (may contain intrinsic functions)
                props['Locations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.locations
                ]
            else:
                props["Locations"] = self.locations

        if self.game_session_creation_limit_policy is not None:
            # Serialize game_session_creation_limit_policy (handle intrinsic functions)
            if hasattr(self.game_session_creation_limit_policy, 'to_dict'):
                props["GameSessionCreationLimitPolicy"] = self.game_session_creation_limit_policy.to_dict()
            elif isinstance(self.game_session_creation_limit_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameSessionCreationLimitPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_session_creation_limit_policy
                ]
            else:
                props["GameSessionCreationLimitPolicy"] = self.game_session_creation_limit_policy

        if self.new_game_session_protection_policy is not None:
            # Serialize new_game_session_protection_policy (handle intrinsic functions)
            if hasattr(self.new_game_session_protection_policy, 'to_dict'):
                props["NewGameSessionProtectionPolicy"] = self.new_game_session_protection_policy.to_dict()
            elif isinstance(self.new_game_session_protection_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['NewGameSessionProtectionPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.new_game_session_protection_policy
                ]
            else:
                props["NewGameSessionProtectionPolicy"] = self.new_game_session_protection_policy

        if self.game_server_container_groups_per_instance is not None:
            # Serialize game_server_container_groups_per_instance (handle intrinsic functions)
            if hasattr(self.game_server_container_groups_per_instance, 'to_dict'):
                props["GameServerContainerGroupsPerInstance"] = self.game_server_container_groups_per_instance.to_dict()
            elif isinstance(self.game_server_container_groups_per_instance, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameServerContainerGroupsPerInstance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_server_container_groups_per_instance
                ]
            else:
                props["GameServerContainerGroupsPerInstance"] = self.game_server_container_groups_per_instance

        if self.log_configuration is not None:
            # Serialize log_configuration (handle intrinsic functions)
            if hasattr(self.log_configuration, 'to_dict'):
                props["LogConfiguration"] = self.log_configuration.to_dict()
            elif isinstance(self.log_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_configuration
                ]
            else:
                props["LogConfiguration"] = self.log_configuration

        if self.instance_connection_port_range is not None:
            # Serialize instance_connection_port_range (handle intrinsic functions)
            if hasattr(self.instance_connection_port_range, 'to_dict'):
                props["InstanceConnectionPortRange"] = self.instance_connection_port_range.to_dict()
            elif isinstance(self.instance_connection_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceConnectionPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_connection_port_range
                ]
            else:
                props["InstanceConnectionPortRange"] = self.instance_connection_port_range

        if self.metric_groups is not None:
            # Serialize metric_groups (handle intrinsic functions)
            if hasattr(self.metric_groups, 'to_dict'):
                props["MetricGroups"] = self.metric_groups.to_dict()
            elif isinstance(self.metric_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_groups
                ]
            else:
                props["MetricGroups"] = self.metric_groups

        if self.instance_inbound_permissions is not None:
            # Serialize instance_inbound_permissions (handle intrinsic functions)
            if hasattr(self.instance_inbound_permissions, 'to_dict'):
                props["InstanceInboundPermissions"] = self.instance_inbound_permissions.to_dict()
            elif isinstance(self.instance_inbound_permissions, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceInboundPermissions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_inbound_permissions
                ]
            else:
                props["InstanceInboundPermissions"] = self.instance_inbound_permissions

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.deployment_configuration is not None:
            # Serialize deployment_configuration (handle intrinsic functions)
            if hasattr(self.deployment_configuration, 'to_dict'):
                props["DeploymentConfiguration"] = self.deployment_configuration.to_dict()
            elif isinstance(self.deployment_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeploymentConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_configuration
                ]
            else:
                props["DeploymentConfiguration"] = self.deployment_configuration

        if self.billing_type is not None:
            # Serialize billing_type (handle intrinsic functions)
            if hasattr(self.billing_type, 'to_dict'):
                props["BillingType"] = self.billing_type.to_dict()
            elif isinstance(self.billing_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['BillingType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.billing_type
                ]
            else:
                props["BillingType"] = self.billing_type

        return props

    @property
    def attr_deployment_details(self) -> GetAtt:
        """Get the DeploymentDetails attribute."""
        return self.get_att("DeploymentDetails")

    @property
    def attr_per_instance_container_group_definition_arn(self) -> GetAtt:
        """Get the PerInstanceContainerGroupDefinitionArn attribute."""
        return self.get_att("PerInstanceContainerGroupDefinitionArn")

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_game_server_container_group_definition_arn(self) -> GetAtt:
        """Get the GameServerContainerGroupDefinitionArn attribute."""
        return self.get_att("GameServerContainerGroupDefinitionArn")

    @property
    def attr_fleet_id(self) -> GetAtt:
        """Get the FleetId attribute."""
        return self.get_att("FleetId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_maximum_game_server_container_groups_per_instance(self) -> GetAtt:
        """Get the MaximumGameServerContainerGroupsPerInstance attribute."""
        return self.get_att("MaximumGameServerContainerGroupsPerInstance")

    @property
    def attr_deployment_details__latest_deployment_id(self) -> GetAtt:
        """Get the DeploymentDetails.LatestDeploymentId attribute."""
        return self.get_att("DeploymentDetails.LatestDeploymentId")

    @property
    def attr_fleet_arn(self) -> GetAtt:
        """Get the FleetArn attribute."""
        return self.get_att("FleetArn")




@dataclass
class ContainerDependency:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition: Optional[Union[str, ContainerDependencyCondition, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.condition is not None:
            if hasattr(self.condition, 'to_dict'):
                props['Condition'] = self.condition.to_dict()
            elif isinstance(self.condition, list):
                props['Condition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition
                ]
            else:
                props['Condition'] = self.condition

        if self.container_name is not None:
            if hasattr(self.container_name, 'to_dict'):
                props['ContainerName'] = self.container_name.to_dict()
            elif isinstance(self.container_name, list):
                props['ContainerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_name
                ]
            else:
                props['ContainerName'] = self.container_name

        return props


@dataclass
class ContainerEnvironment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class ContainerHealthCheck:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    command: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retries: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_period: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.command is not None:
            if hasattr(self.command, 'to_dict'):
                props['Command'] = self.command.to_dict()
            elif isinstance(self.command, list):
                props['Command'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.command
                ]
            else:
                props['Command'] = self.command

        if self.timeout is not None:
            if hasattr(self.timeout, 'to_dict'):
                props['Timeout'] = self.timeout.to_dict()
            elif isinstance(self.timeout, list):
                props['Timeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout
                ]
            else:
                props['Timeout'] = self.timeout

        if self.retries is not None:
            if hasattr(self.retries, 'to_dict'):
                props['Retries'] = self.retries.to_dict()
            elif isinstance(self.retries, list):
                props['Retries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retries
                ]
            else:
                props['Retries'] = self.retries

        if self.interval is not None:
            if hasattr(self.interval, 'to_dict'):
                props['Interval'] = self.interval.to_dict()
            elif isinstance(self.interval, list):
                props['Interval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interval
                ]
            else:
                props['Interval'] = self.interval

        if self.start_period is not None:
            if hasattr(self.start_period, 'to_dict'):
                props['StartPeriod'] = self.start_period.to_dict()
            elif isinstance(self.start_period, list):
                props['StartPeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_period
                ]
            else:
                props['StartPeriod'] = self.start_period

        return props


@dataclass
class ContainerMountPoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_level: Optional[Union[str, ContainerMountPointAccessLevel, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_path is not None:
            if hasattr(self.instance_path, 'to_dict'):
                props['InstancePath'] = self.instance_path.to_dict()
            elif isinstance(self.instance_path, list):
                props['InstancePath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_path
                ]
            else:
                props['InstancePath'] = self.instance_path

        if self.container_path is not None:
            if hasattr(self.container_path, 'to_dict'):
                props['ContainerPath'] = self.container_path.to_dict()
            elif isinstance(self.container_path, list):
                props['ContainerPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_path
                ]
            else:
                props['ContainerPath'] = self.container_path

        if self.access_level is not None:
            if hasattr(self.access_level, 'to_dict'):
                props['AccessLevel'] = self.access_level.to_dict()
            elif isinstance(self.access_level, list):
                props['AccessLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_level
                ]
            else:
                props['AccessLevel'] = self.access_level

        return props


@dataclass
class ContainerPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, IpProtocol, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class GameServerContainerDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_points: Optional[list[ContainerMountPoint]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    depends_on: Optional[list[ContainerDependency]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment_override: Optional[list[ContainerEnvironment]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    server_sdk_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resolved_image_digest: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_configuration: Optional[PortConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_points is not None:
            if hasattr(self.mount_points, 'to_dict'):
                props['MountPoints'] = self.mount_points.to_dict()
            elif isinstance(self.mount_points, list):
                props['MountPoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_points
                ]
            else:
                props['MountPoints'] = self.mount_points

        if self.depends_on is not None:
            if hasattr(self.depends_on, 'to_dict'):
                props['DependsOn'] = self.depends_on.to_dict()
            elif isinstance(self.depends_on, list):
                props['DependsOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.depends_on
                ]
            else:
                props['DependsOn'] = self.depends_on

        if self.container_name is not None:
            if hasattr(self.container_name, 'to_dict'):
                props['ContainerName'] = self.container_name.to_dict()
            elif isinstance(self.container_name, list):
                props['ContainerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_name
                ]
            else:
                props['ContainerName'] = self.container_name

        if self.environment_override is not None:
            if hasattr(self.environment_override, 'to_dict'):
                props['EnvironmentOverride'] = self.environment_override.to_dict()
            elif isinstance(self.environment_override, list):
                props['EnvironmentOverride'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_override
                ]
            else:
                props['EnvironmentOverride'] = self.environment_override

        if self.server_sdk_version is not None:
            if hasattr(self.server_sdk_version, 'to_dict'):
                props['ServerSdkVersion'] = self.server_sdk_version.to_dict()
            elif isinstance(self.server_sdk_version, list):
                props['ServerSdkVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_sdk_version
                ]
            else:
                props['ServerSdkVersion'] = self.server_sdk_version

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.resolved_image_digest is not None:
            if hasattr(self.resolved_image_digest, 'to_dict'):
                props['ResolvedImageDigest'] = self.resolved_image_digest.to_dict()
            elif isinstance(self.resolved_image_digest, list):
                props['ResolvedImageDigest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resolved_image_digest
                ]
            else:
                props['ResolvedImageDigest'] = self.resolved_image_digest

        if self.port_configuration is not None:
            if hasattr(self.port_configuration, 'to_dict'):
                props['PortConfiguration'] = self.port_configuration.to_dict()
            elif isinstance(self.port_configuration, list):
                props['PortConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_configuration
                ]
            else:
                props['PortConfiguration'] = self.port_configuration

        return props


@dataclass
class PortConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_port_ranges: Optional[list[ContainerPortRange]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_port_ranges is not None:
            if hasattr(self.container_port_ranges, 'to_dict'):
                props['ContainerPortRanges'] = self.container_port_ranges.to_dict()
            elif isinstance(self.container_port_ranges, list):
                props['ContainerPortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_port_ranges
                ]
            else:
                props['ContainerPortRanges'] = self.container_port_ranges

        return props


@dataclass
class SupportContainerDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_points: Optional[list[ContainerMountPoint]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    depends_on: Optional[list[ContainerDependency]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_hard_limit_mebibytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment_override: Optional[list[ContainerEnvironment]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    health_check: Optional[ContainerHealthCheck] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vcpu: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resolved_image_digest: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    essential: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_configuration: Optional[PortConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_points is not None:
            if hasattr(self.mount_points, 'to_dict'):
                props['MountPoints'] = self.mount_points.to_dict()
            elif isinstance(self.mount_points, list):
                props['MountPoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_points
                ]
            else:
                props['MountPoints'] = self.mount_points

        if self.depends_on is not None:
            if hasattr(self.depends_on, 'to_dict'):
                props['DependsOn'] = self.depends_on.to_dict()
            elif isinstance(self.depends_on, list):
                props['DependsOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.depends_on
                ]
            else:
                props['DependsOn'] = self.depends_on

        if self.container_name is not None:
            if hasattr(self.container_name, 'to_dict'):
                props['ContainerName'] = self.container_name.to_dict()
            elif isinstance(self.container_name, list):
                props['ContainerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_name
                ]
            else:
                props['ContainerName'] = self.container_name

        if self.memory_hard_limit_mebibytes is not None:
            if hasattr(self.memory_hard_limit_mebibytes, 'to_dict'):
                props['MemoryHardLimitMebibytes'] = self.memory_hard_limit_mebibytes.to_dict()
            elif isinstance(self.memory_hard_limit_mebibytes, list):
                props['MemoryHardLimitMebibytes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_hard_limit_mebibytes
                ]
            else:
                props['MemoryHardLimitMebibytes'] = self.memory_hard_limit_mebibytes

        if self.environment_override is not None:
            if hasattr(self.environment_override, 'to_dict'):
                props['EnvironmentOverride'] = self.environment_override.to_dict()
            elif isinstance(self.environment_override, list):
                props['EnvironmentOverride'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_override
                ]
            else:
                props['EnvironmentOverride'] = self.environment_override

        if self.health_check is not None:
            if hasattr(self.health_check, 'to_dict'):
                props['HealthCheck'] = self.health_check.to_dict()
            elif isinstance(self.health_check, list):
                props['HealthCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.health_check
                ]
            else:
                props['HealthCheck'] = self.health_check

        if self.vcpu is not None:
            if hasattr(self.vcpu, 'to_dict'):
                props['Vcpu'] = self.vcpu.to_dict()
            elif isinstance(self.vcpu, list):
                props['Vcpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vcpu
                ]
            else:
                props['Vcpu'] = self.vcpu

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.resolved_image_digest is not None:
            if hasattr(self.resolved_image_digest, 'to_dict'):
                props['ResolvedImageDigest'] = self.resolved_image_digest.to_dict()
            elif isinstance(self.resolved_image_digest, list):
                props['ResolvedImageDigest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resolved_image_digest
                ]
            else:
                props['ResolvedImageDigest'] = self.resolved_image_digest

        if self.essential is not None:
            if hasattr(self.essential, 'to_dict'):
                props['Essential'] = self.essential.to_dict()
            elif isinstance(self.essential, list):
                props['Essential'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.essential
                ]
            else:
                props['Essential'] = self.essential

        if self.port_configuration is not None:
            if hasattr(self.port_configuration, 'to_dict'):
                props['PortConfiguration'] = self.port_configuration.to_dict()
            elif isinstance(self.port_configuration, list):
                props['PortConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_configuration
                ]
            else:
                props['PortConfiguration'] = self.port_configuration

        return props


@dataclass
class ContainerGroupDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::ContainerGroupDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_system: Optional[Union[str, ContainerOperatingSystem, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_server_container_definition: Optional[GameServerContainerDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    total_memory_limit_mebibytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_version_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    total_vcpu_limit: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    container_group_type: Optional[Union[str, ContainerGroupType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    support_container_definitions: Optional[list[SupportContainerDefinition]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.operating_system is not None:
            # Serialize operating_system (handle intrinsic functions)
            if hasattr(self.operating_system, 'to_dict'):
                props["OperatingSystem"] = self.operating_system.to_dict()
            elif isinstance(self.operating_system, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_system
                ]
            else:
                props["OperatingSystem"] = self.operating_system

        if self.version_description is not None:
            # Serialize version_description (handle intrinsic functions)
            if hasattr(self.version_description, 'to_dict'):
                props["VersionDescription"] = self.version_description.to_dict()
            elif isinstance(self.version_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_description
                ]
            else:
                props["VersionDescription"] = self.version_description

        if self.game_server_container_definition is not None:
            # Serialize game_server_container_definition (handle intrinsic functions)
            if hasattr(self.game_server_container_definition, 'to_dict'):
                props["GameServerContainerDefinition"] = self.game_server_container_definition.to_dict()
            elif isinstance(self.game_server_container_definition, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameServerContainerDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_server_container_definition
                ]
            else:
                props["GameServerContainerDefinition"] = self.game_server_container_definition

        if self.total_memory_limit_mebibytes is not None:
            # Serialize total_memory_limit_mebibytes (handle intrinsic functions)
            if hasattr(self.total_memory_limit_mebibytes, 'to_dict'):
                props["TotalMemoryLimitMebibytes"] = self.total_memory_limit_mebibytes.to_dict()
            elif isinstance(self.total_memory_limit_mebibytes, list):
                # Serialize list items (may contain intrinsic functions)
                props['TotalMemoryLimitMebibytes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_memory_limit_mebibytes
                ]
            else:
                props["TotalMemoryLimitMebibytes"] = self.total_memory_limit_mebibytes

        if self.source_version_number is not None:
            # Serialize source_version_number (handle intrinsic functions)
            if hasattr(self.source_version_number, 'to_dict'):
                props["SourceVersionNumber"] = self.source_version_number.to_dict()
            elif isinstance(self.source_version_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceVersionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_version_number
                ]
            else:
                props["SourceVersionNumber"] = self.source_version_number

        if self.total_vcpu_limit is not None:
            # Serialize total_vcpu_limit (handle intrinsic functions)
            if hasattr(self.total_vcpu_limit, 'to_dict'):
                props["TotalVcpuLimit"] = self.total_vcpu_limit.to_dict()
            elif isinstance(self.total_vcpu_limit, list):
                # Serialize list items (may contain intrinsic functions)
                props['TotalVcpuLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_vcpu_limit
                ]
            else:
                props["TotalVcpuLimit"] = self.total_vcpu_limit

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.container_group_type is not None:
            # Serialize container_group_type (handle intrinsic functions)
            if hasattr(self.container_group_type, 'to_dict'):
                props["ContainerGroupType"] = self.container_group_type.to_dict()
            elif isinstance(self.container_group_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContainerGroupType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_group_type
                ]
            else:
                props["ContainerGroupType"] = self.container_group_type

        if self.support_container_definitions is not None:
            # Serialize support_container_definitions (handle intrinsic functions)
            if hasattr(self.support_container_definitions, 'to_dict'):
                props["SupportContainerDefinitions"] = self.support_container_definitions.to_dict()
            elif isinstance(self.support_container_definitions, list):
                # Serialize list items (may contain intrinsic functions)
                props['SupportContainerDefinitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.support_container_definitions
                ]
            else:
                props["SupportContainerDefinitions"] = self.support_container_definitions

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_container_group_definition_arn(self) -> GetAtt:
        """Get the ContainerGroupDefinitionArn attribute."""
        return self.get_att("ContainerGroupDefinitionArn")

    @property
    def attr_status_reason(self) -> GetAtt:
        """Get the StatusReason attribute."""
        return self.get_att("StatusReason")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_version_number(self) -> GetAtt:
        """Get the VersionNumber attribute."""
        return self.get_att("VersionNumber")




@dataclass
class AnywhereConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cost: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cost is not None:
            if hasattr(self.cost, 'to_dict'):
                props['Cost'] = self.cost.to_dict()
            elif isinstance(self.cost, list):
                props['Cost'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cost
                ]
            else:
                props['Cost'] = self.cost

        return props


@dataclass
class CertificateConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    certificate_type: Optional[Union[str, CertificateType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.certificate_type is not None:
            if hasattr(self.certificate_type, 'to_dict'):
                props['CertificateType'] = self.certificate_type.to_dict()
            elif isinstance(self.certificate_type, list):
                props['CertificateType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_type
                ]
            else:
                props['CertificateType'] = self.certificate_type

        return props


@dataclass
class IpPermission:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, IpProtocol, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ip_range is not None:
            if hasattr(self.ip_range, 'to_dict'):
                props['IpRange'] = self.ip_range.to_dict()
            elif isinstance(self.ip_range, list):
                props['IpRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_range
                ]
            else:
                props['IpRange'] = self.ip_range

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class LocationCapacity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    desired_ec2_instances: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_size is not None:
            if hasattr(self.min_size, 'to_dict'):
                props['MinSize'] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props['MinSize'] = self.min_size

        if self.desired_ec2_instances is not None:
            if hasattr(self.desired_ec2_instances, 'to_dict'):
                props['DesiredEC2Instances'] = self.desired_ec2_instances.to_dict()
            elif isinstance(self.desired_ec2_instances, list):
                props['DesiredEC2Instances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_ec2_instances
                ]
            else:
                props['DesiredEC2Instances'] = self.desired_ec2_instances

        if self.max_size is not None:
            if hasattr(self.max_size, 'to_dict'):
                props['MaxSize'] = self.max_size.to_dict()
            elif isinstance(self.max_size, list):
                props['MaxSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_size
                ]
            else:
                props['MaxSize'] = self.max_size

        return props


@dataclass
class LocationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location_capacity: Optional[LocationCapacity] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.location_capacity is not None:
            if hasattr(self.location_capacity, 'to_dict'):
                props['LocationCapacity'] = self.location_capacity.to_dict()
            elif isinstance(self.location_capacity, list):
                props['LocationCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location_capacity
                ]
            else:
                props['LocationCapacity'] = self.location_capacity

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class ResourceCreationLimitPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_period_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    new_game_sessions_per_creator: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_period_in_minutes is not None:
            if hasattr(self.policy_period_in_minutes, 'to_dict'):
                props['PolicyPeriodInMinutes'] = self.policy_period_in_minutes.to_dict()
            elif isinstance(self.policy_period_in_minutes, list):
                props['PolicyPeriodInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_period_in_minutes
                ]
            else:
                props['PolicyPeriodInMinutes'] = self.policy_period_in_minutes

        if self.new_game_sessions_per_creator is not None:
            if hasattr(self.new_game_sessions_per_creator, 'to_dict'):
                props['NewGameSessionsPerCreator'] = self.new_game_sessions_per_creator.to_dict()
            elif isinstance(self.new_game_sessions_per_creator, list):
                props['NewGameSessionsPerCreator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.new_game_sessions_per_creator
                ]
            else:
                props['NewGameSessionsPerCreator'] = self.new_game_sessions_per_creator

        return props


@dataclass
class RuntimeConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    server_processes: Optional[list[ServerProcess]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_game_session_activations: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    game_session_activation_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.server_processes is not None:
            if hasattr(self.server_processes, 'to_dict'):
                props['ServerProcesses'] = self.server_processes.to_dict()
            elif isinstance(self.server_processes, list):
                props['ServerProcesses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_processes
                ]
            else:
                props['ServerProcesses'] = self.server_processes

        if self.max_concurrent_game_session_activations is not None:
            if hasattr(self.max_concurrent_game_session_activations, 'to_dict'):
                props['MaxConcurrentGameSessionActivations'] = self.max_concurrent_game_session_activations.to_dict()
            elif isinstance(self.max_concurrent_game_session_activations, list):
                props['MaxConcurrentGameSessionActivations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_game_session_activations
                ]
            else:
                props['MaxConcurrentGameSessionActivations'] = self.max_concurrent_game_session_activations

        if self.game_session_activation_timeout_seconds is not None:
            if hasattr(self.game_session_activation_timeout_seconds, 'to_dict'):
                props['GameSessionActivationTimeoutSeconds'] = self.game_session_activation_timeout_seconds.to_dict()
            elif isinstance(self.game_session_activation_timeout_seconds, list):
                props['GameSessionActivationTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_session_activation_timeout_seconds
                ]
            else:
                props['GameSessionActivationTimeoutSeconds'] = self.game_session_activation_timeout_seconds

        return props


@dataclass
class ScalingPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, ScalingStatusType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, MetricName, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_type: Optional[Union[str, PolicyType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    comparison_operator: Optional[Union[str, ComparisonOperatorType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_configuration: Optional[TargetConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    update_status: Optional[Union[str, LocationUpdateStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    evaluation_periods: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment_type: Optional[Union[str, ScalingAdjustmentType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.policy_type is not None:
            if hasattr(self.policy_type, 'to_dict'):
                props['PolicyType'] = self.policy_type.to_dict()
            elif isinstance(self.policy_type, list):
                props['PolicyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_type
                ]
            else:
                props['PolicyType'] = self.policy_type

        if self.comparison_operator is not None:
            if hasattr(self.comparison_operator, 'to_dict'):
                props['ComparisonOperator'] = self.comparison_operator.to_dict()
            elif isinstance(self.comparison_operator, list):
                props['ComparisonOperator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.comparison_operator
                ]
            else:
                props['ComparisonOperator'] = self.comparison_operator

        if self.target_configuration is not None:
            if hasattr(self.target_configuration, 'to_dict'):
                props['TargetConfiguration'] = self.target_configuration.to_dict()
            elif isinstance(self.target_configuration, list):
                props['TargetConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_configuration
                ]
            else:
                props['TargetConfiguration'] = self.target_configuration

        if self.update_status is not None:
            if hasattr(self.update_status, 'to_dict'):
                props['UpdateStatus'] = self.update_status.to_dict()
            elif isinstance(self.update_status, list):
                props['UpdateStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.update_status
                ]
            else:
                props['UpdateStatus'] = self.update_status

        if self.scaling_adjustment is not None:
            if hasattr(self.scaling_adjustment, 'to_dict'):
                props['ScalingAdjustment'] = self.scaling_adjustment.to_dict()
            elif isinstance(self.scaling_adjustment, list):
                props['ScalingAdjustment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment
                ]
            else:
                props['ScalingAdjustment'] = self.scaling_adjustment

        if self.evaluation_periods is not None:
            if hasattr(self.evaluation_periods, 'to_dict'):
                props['EvaluationPeriods'] = self.evaluation_periods.to_dict()
            elif isinstance(self.evaluation_periods, list):
                props['EvaluationPeriods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_periods
                ]
            else:
                props['EvaluationPeriods'] = self.evaluation_periods

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.scaling_adjustment_type is not None:
            if hasattr(self.scaling_adjustment_type, 'to_dict'):
                props['ScalingAdjustmentType'] = self.scaling_adjustment_type.to_dict()
            elif isinstance(self.scaling_adjustment_type, list):
                props['ScalingAdjustmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment_type
                ]
            else:
                props['ScalingAdjustmentType'] = self.scaling_adjustment_type

        if self.threshold is not None:
            if hasattr(self.threshold, 'to_dict'):
                props['Threshold'] = self.threshold.to_dict()
            elif isinstance(self.threshold, list):
                props['Threshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threshold
                ]
            else:
                props['Threshold'] = self.threshold

        return props


@dataclass
class ServerProcess:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.concurrent_executions is not None:
            if hasattr(self.concurrent_executions, 'to_dict'):
                props['ConcurrentExecutions'] = self.concurrent_executions.to_dict()
            elif isinstance(self.concurrent_executions, list):
                props['ConcurrentExecutions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.concurrent_executions
                ]
            else:
                props['ConcurrentExecutions'] = self.concurrent_executions

        if self.parameters is not None:
            if hasattr(self.parameters, 'to_dict'):
                props['Parameters'] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props['Parameters'] = self.parameters

        if self.launch_path is not None:
            if hasattr(self.launch_path, 'to_dict'):
                props['LaunchPath'] = self.launch_path.to_dict()
            elif isinstance(self.launch_path, list):
                props['LaunchPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_path
                ]
            else:
                props['LaunchPath'] = self.launch_path

        return props


@dataclass
class TargetConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        return props


@dataclass
class Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_policies: Optional[list[ScalingPolicy]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    apply_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ec2_inbound_permissions: Optional[list[IpPermission]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    locations: Optional[list[LocationConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    new_game_session_protection_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    script_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    runtime_configuration: Optional[RuntimeConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_vpc_aws_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    anywhere_configuration: Optional[AnywhereConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    build_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_creation_limit_policy: Optional[ResourceCreationLimitPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ec2_instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_configuration: Optional[CertificateConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_role_credentials_provider: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scaling_policies is not None:
            # Serialize scaling_policies (handle intrinsic functions)
            if hasattr(self.scaling_policies, 'to_dict'):
                props["ScalingPolicies"] = self.scaling_policies.to_dict()
            elif isinstance(self.scaling_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_policies
                ]
            else:
                props["ScalingPolicies"] = self.scaling_policies

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.peer_vpc_id is not None:
            # Serialize peer_vpc_id (handle intrinsic functions)
            if hasattr(self.peer_vpc_id, 'to_dict'):
                props["PeerVpcId"] = self.peer_vpc_id.to_dict()
            elif isinstance(self.peer_vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerVpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_vpc_id
                ]
            else:
                props["PeerVpcId"] = self.peer_vpc_id

        if self.apply_capacity is not None:
            # Serialize apply_capacity (handle intrinsic functions)
            if hasattr(self.apply_capacity, 'to_dict'):
                props["ApplyCapacity"] = self.apply_capacity.to_dict()
            elif isinstance(self.apply_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplyCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_capacity
                ]
            else:
                props["ApplyCapacity"] = self.apply_capacity

        if self.fleet_type is not None:
            # Serialize fleet_type (handle intrinsic functions)
            if hasattr(self.fleet_type, 'to_dict'):
                props["FleetType"] = self.fleet_type.to_dict()
            elif isinstance(self.fleet_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_type
                ]
            else:
                props["FleetType"] = self.fleet_type

        if self.ec2_inbound_permissions is not None:
            # Serialize ec2_inbound_permissions (handle intrinsic functions)
            if hasattr(self.ec2_inbound_permissions, 'to_dict'):
                props["EC2InboundPermissions"] = self.ec2_inbound_permissions.to_dict()
            elif isinstance(self.ec2_inbound_permissions, list):
                # Serialize list items (may contain intrinsic functions)
                props['EC2InboundPermissions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ec2_inbound_permissions
                ]
            else:
                props["EC2InboundPermissions"] = self.ec2_inbound_permissions

        if self.locations is not None:
            # Serialize locations (handle intrinsic functions)
            if hasattr(self.locations, 'to_dict'):
                props["Locations"] = self.locations.to_dict()
            elif isinstance(self.locations, list):
                # Serialize list items (may contain intrinsic functions)
                props['Locations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.locations
                ]
            else:
                props["Locations"] = self.locations

        if self.new_game_session_protection_policy is not None:
            # Serialize new_game_session_protection_policy (handle intrinsic functions)
            if hasattr(self.new_game_session_protection_policy, 'to_dict'):
                props["NewGameSessionProtectionPolicy"] = self.new_game_session_protection_policy.to_dict()
            elif isinstance(self.new_game_session_protection_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['NewGameSessionProtectionPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.new_game_session_protection_policy
                ]
            else:
                props["NewGameSessionProtectionPolicy"] = self.new_game_session_protection_policy

        if self.script_id is not None:
            # Serialize script_id (handle intrinsic functions)
            if hasattr(self.script_id, 'to_dict'):
                props["ScriptId"] = self.script_id.to_dict()
            elif isinstance(self.script_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScriptId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.script_id
                ]
            else:
                props["ScriptId"] = self.script_id

        if self.compute_type is not None:
            # Serialize compute_type (handle intrinsic functions)
            if hasattr(self.compute_type, 'to_dict'):
                props["ComputeType"] = self.compute_type.to_dict()
            elif isinstance(self.compute_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComputeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_type
                ]
            else:
                props["ComputeType"] = self.compute_type

        if self.runtime_configuration is not None:
            # Serialize runtime_configuration (handle intrinsic functions)
            if hasattr(self.runtime_configuration, 'to_dict'):
                props["RuntimeConfiguration"] = self.runtime_configuration.to_dict()
            elif isinstance(self.runtime_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuntimeConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_configuration
                ]
            else:
                props["RuntimeConfiguration"] = self.runtime_configuration

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.peer_vpc_aws_account_id is not None:
            # Serialize peer_vpc_aws_account_id (handle intrinsic functions)
            if hasattr(self.peer_vpc_aws_account_id, 'to_dict'):
                props["PeerVpcAwsAccountId"] = self.peer_vpc_aws_account_id.to_dict()
            elif isinstance(self.peer_vpc_aws_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerVpcAwsAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_vpc_aws_account_id
                ]
            else:
                props["PeerVpcAwsAccountId"] = self.peer_vpc_aws_account_id

        if self.anywhere_configuration is not None:
            # Serialize anywhere_configuration (handle intrinsic functions)
            if hasattr(self.anywhere_configuration, 'to_dict'):
                props["AnywhereConfiguration"] = self.anywhere_configuration.to_dict()
            elif isinstance(self.anywhere_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['AnywhereConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.anywhere_configuration
                ]
            else:
                props["AnywhereConfiguration"] = self.anywhere_configuration

        if self.instance_role_arn is not None:
            # Serialize instance_role_arn (handle intrinsic functions)
            if hasattr(self.instance_role_arn, 'to_dict'):
                props["InstanceRoleARN"] = self.instance_role_arn.to_dict()
            elif isinstance(self.instance_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceRoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_role_arn
                ]
            else:
                props["InstanceRoleARN"] = self.instance_role_arn

        if self.metric_groups is not None:
            # Serialize metric_groups (handle intrinsic functions)
            if hasattr(self.metric_groups, 'to_dict'):
                props["MetricGroups"] = self.metric_groups.to_dict()
            elif isinstance(self.metric_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_groups
                ]
            else:
                props["MetricGroups"] = self.metric_groups

        if self.build_id is not None:
            # Serialize build_id (handle intrinsic functions)
            if hasattr(self.build_id, 'to_dict'):
                props["BuildId"] = self.build_id.to_dict()
            elif isinstance(self.build_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BuildId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.build_id
                ]
            else:
                props["BuildId"] = self.build_id

        if self.resource_creation_limit_policy is not None:
            # Serialize resource_creation_limit_policy (handle intrinsic functions)
            if hasattr(self.resource_creation_limit_policy, 'to_dict'):
                props["ResourceCreationLimitPolicy"] = self.resource_creation_limit_policy.to_dict()
            elif isinstance(self.resource_creation_limit_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceCreationLimitPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_creation_limit_policy
                ]
            else:
                props["ResourceCreationLimitPolicy"] = self.resource_creation_limit_policy

        if self.ec2_instance_type is not None:
            # Serialize ec2_instance_type (handle intrinsic functions)
            if hasattr(self.ec2_instance_type, 'to_dict'):
                props["EC2InstanceType"] = self.ec2_instance_type.to_dict()
            elif isinstance(self.ec2_instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EC2InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ec2_instance_type
                ]
            else:
                props["EC2InstanceType"] = self.ec2_instance_type

        if self.certificate_configuration is not None:
            # Serialize certificate_configuration (handle intrinsic functions)
            if hasattr(self.certificate_configuration, 'to_dict'):
                props["CertificateConfiguration"] = self.certificate_configuration.to_dict()
            elif isinstance(self.certificate_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_configuration
                ]
            else:
                props["CertificateConfiguration"] = self.certificate_configuration

        if self.instance_role_credentials_provider is not None:
            # Serialize instance_role_credentials_provider (handle intrinsic functions)
            if hasattr(self.instance_role_credentials_provider, 'to_dict'):
                props["InstanceRoleCredentialsProvider"] = self.instance_role_credentials_provider.to_dict()
            elif isinstance(self.instance_role_credentials_provider, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceRoleCredentialsProvider'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_role_credentials_provider
                ]
            else:
                props["InstanceRoleCredentialsProvider"] = self.instance_role_credentials_provider

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_fleet_id(self) -> GetAtt:
        """Get the FleetId attribute."""
        return self.get_att("FleetId")

    @property
    def attr_fleet_arn(self) -> GetAtt:
        """Get the FleetArn attribute."""
        return self.get_att("FleetArn")




@dataclass
class AutoScalingPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_tracking_configuration: Optional[TargetTrackingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    estimated_instance_warmup: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_tracking_configuration is not None:
            if hasattr(self.target_tracking_configuration, 'to_dict'):
                props['TargetTrackingConfiguration'] = self.target_tracking_configuration.to_dict()
            elif isinstance(self.target_tracking_configuration, list):
                props['TargetTrackingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_tracking_configuration
                ]
            else:
                props['TargetTrackingConfiguration'] = self.target_tracking_configuration

        if self.estimated_instance_warmup is not None:
            if hasattr(self.estimated_instance_warmup, 'to_dict'):
                props['EstimatedInstanceWarmup'] = self.estimated_instance_warmup.to_dict()
            elif isinstance(self.estimated_instance_warmup, list):
                props['EstimatedInstanceWarmup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.estimated_instance_warmup
                ]
            else:
                props['EstimatedInstanceWarmup'] = self.estimated_instance_warmup

        return props


@dataclass
class InstanceDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, GameServerGroupInstanceType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class LaunchTemplate:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class TargetTrackingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        return props


@dataclass
class GameServerGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::GameServerGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_policy: Optional[AutoScalingPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delete_option: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    balancing_strategy: Optional[Union[str, BalancingStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_server_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template: Optional[LaunchTemplate] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_server_protection_policy: Optional[Union[str, GameServerProtectionPolicy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_size: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_definitions: Optional[list[InstanceDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_scaling_policy is not None:
            # Serialize auto_scaling_policy (handle intrinsic functions)
            if hasattr(self.auto_scaling_policy, 'to_dict'):
                props["AutoScalingPolicy"] = self.auto_scaling_policy.to_dict()
            elif isinstance(self.auto_scaling_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_policy
                ]
            else:
                props["AutoScalingPolicy"] = self.auto_scaling_policy

        if self.min_size is not None:
            # Serialize min_size (handle intrinsic functions)
            if hasattr(self.min_size, 'to_dict'):
                props["MinSize"] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props["MinSize"] = self.min_size

        if self.delete_option is not None:
            # Serialize delete_option (handle intrinsic functions)
            if hasattr(self.delete_option, 'to_dict'):
                props["DeleteOption"] = self.delete_option.to_dict()
            elif isinstance(self.delete_option, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeleteOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_option
                ]
            else:
                props["DeleteOption"] = self.delete_option

        if self.balancing_strategy is not None:
            # Serialize balancing_strategy (handle intrinsic functions)
            if hasattr(self.balancing_strategy, 'to_dict'):
                props["BalancingStrategy"] = self.balancing_strategy.to_dict()
            elif isinstance(self.balancing_strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['BalancingStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.balancing_strategy
                ]
            else:
                props["BalancingStrategy"] = self.balancing_strategy

        if self.game_server_group_name is not None:
            # Serialize game_server_group_name (handle intrinsic functions)
            if hasattr(self.game_server_group_name, 'to_dict'):
                props["GameServerGroupName"] = self.game_server_group_name.to_dict()
            elif isinstance(self.game_server_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameServerGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_server_group_name
                ]
            else:
                props["GameServerGroupName"] = self.game_server_group_name

        if self.launch_template is not None:
            # Serialize launch_template (handle intrinsic functions)
            if hasattr(self.launch_template, 'to_dict'):
                props["LaunchTemplate"] = self.launch_template.to_dict()
            elif isinstance(self.launch_template, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template
                ]
            else:
                props["LaunchTemplate"] = self.launch_template

        if self.game_server_protection_policy is not None:
            # Serialize game_server_protection_policy (handle intrinsic functions)
            if hasattr(self.game_server_protection_policy, 'to_dict'):
                props["GameServerProtectionPolicy"] = self.game_server_protection_policy.to_dict()
            elif isinstance(self.game_server_protection_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameServerProtectionPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_server_protection_policy
                ]
            else:
                props["GameServerProtectionPolicy"] = self.game_server_protection_policy

        if self.vpc_subnets is not None:
            # Serialize vpc_subnets (handle intrinsic functions)
            if hasattr(self.vpc_subnets, 'to_dict'):
                props["VpcSubnets"] = self.vpc_subnets.to_dict()
            elif isinstance(self.vpc_subnets, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcSubnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_subnets
                ]
            else:
                props["VpcSubnets"] = self.vpc_subnets

        if self.max_size is not None:
            # Serialize max_size (handle intrinsic functions)
            if hasattr(self.max_size, 'to_dict'):
                props["MaxSize"] = self.max_size.to_dict()
            elif isinstance(self.max_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_size
                ]
            else:
                props["MaxSize"] = self.max_size

        if self.instance_definitions is not None:
            # Serialize instance_definitions (handle intrinsic functions)
            if hasattr(self.instance_definitions, 'to_dict'):
                props["InstanceDefinitions"] = self.instance_definitions.to_dict()
            elif isinstance(self.instance_definitions, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceDefinitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_definitions
                ]
            else:
                props["InstanceDefinitions"] = self.instance_definitions

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_auto_scaling_group_arn(self) -> GetAtt:
        """Get the AutoScalingGroupArn attribute."""
        return self.get_att("AutoScalingGroupArn")

    @property
    def attr_game_server_group_arn(self) -> GetAtt:
        """Get the GameServerGroupArn attribute."""
        return self.get_att("GameServerGroupArn")




@dataclass
class FilterConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_locations: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allowed_locations is not None:
            if hasattr(self.allowed_locations, 'to_dict'):
                props['AllowedLocations'] = self.allowed_locations.to_dict()
            elif isinstance(self.allowed_locations, list):
                props['AllowedLocations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_locations
                ]
            else:
                props['AllowedLocations'] = self.allowed_locations

        return props


@dataclass
class GameSessionQueueDestination:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_arn is not None:
            if hasattr(self.destination_arn, 'to_dict'):
                props['DestinationArn'] = self.destination_arn.to_dict()
            elif isinstance(self.destination_arn, list):
                props['DestinationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_arn
                ]
            else:
                props['DestinationArn'] = self.destination_arn

        return props


@dataclass
class PlayerLatencyPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_duration_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_individual_player_latency_milliseconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_duration_seconds is not None:
            if hasattr(self.policy_duration_seconds, 'to_dict'):
                props['PolicyDurationSeconds'] = self.policy_duration_seconds.to_dict()
            elif isinstance(self.policy_duration_seconds, list):
                props['PolicyDurationSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_duration_seconds
                ]
            else:
                props['PolicyDurationSeconds'] = self.policy_duration_seconds

        if self.maximum_individual_player_latency_milliseconds is not None:
            if hasattr(self.maximum_individual_player_latency_milliseconds, 'to_dict'):
                props['MaximumIndividualPlayerLatencyMilliseconds'] = self.maximum_individual_player_latency_milliseconds.to_dict()
            elif isinstance(self.maximum_individual_player_latency_milliseconds, list):
                props['MaximumIndividualPlayerLatencyMilliseconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_individual_player_latency_milliseconds
                ]
            else:
                props['MaximumIndividualPlayerLatencyMilliseconds'] = self.maximum_individual_player_latency_milliseconds

        return props


@dataclass
class PriorityConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority_order: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location_order: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.priority_order is not None:
            if hasattr(self.priority_order, 'to_dict'):
                props['PriorityOrder'] = self.priority_order.to_dict()
            elif isinstance(self.priority_order, list):
                props['PriorityOrder'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority_order
                ]
            else:
                props['PriorityOrder'] = self.priority_order

        if self.location_order is not None:
            if hasattr(self.location_order, 'to_dict'):
                props['LocationOrder'] = self.location_order.to_dict()
            elif isinstance(self.location_order, list):
                props['LocationOrder'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location_order
                ]
            else:
                props['LocationOrder'] = self.location_order

        return props


@dataclass
class GameSessionQueue(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::GameSessionQueue"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    player_latency_policies: Optional[list[PlayerLatencyPolicy]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destinations: Optional[list[GameSessionQueueDestination]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_configuration: Optional[FilterConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    custom_event_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    priority_configuration: Optional[PriorityConfiguration] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.timeout_in_seconds is not None:
            # Serialize timeout_in_seconds (handle intrinsic functions)
            if hasattr(self.timeout_in_seconds, 'to_dict'):
                props["TimeoutInSeconds"] = self.timeout_in_seconds.to_dict()
            elif isinstance(self.timeout_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['TimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_in_seconds
                ]
            else:
                props["TimeoutInSeconds"] = self.timeout_in_seconds

        if self.player_latency_policies is not None:
            # Serialize player_latency_policies (handle intrinsic functions)
            if hasattr(self.player_latency_policies, 'to_dict'):
                props["PlayerLatencyPolicies"] = self.player_latency_policies.to_dict()
            elif isinstance(self.player_latency_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlayerLatencyPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.player_latency_policies
                ]
            else:
                props["PlayerLatencyPolicies"] = self.player_latency_policies

        if self.destinations is not None:
            # Serialize destinations (handle intrinsic functions)
            if hasattr(self.destinations, 'to_dict'):
                props["Destinations"] = self.destinations.to_dict()
            elif isinstance(self.destinations, list):
                # Serialize list items (may contain intrinsic functions)
                props['Destinations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destinations
                ]
            else:
                props["Destinations"] = self.destinations

        if self.notification_target is not None:
            # Serialize notification_target (handle intrinsic functions)
            if hasattr(self.notification_target, 'to_dict'):
                props["NotificationTarget"] = self.notification_target.to_dict()
            elif isinstance(self.notification_target, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_target
                ]
            else:
                props["NotificationTarget"] = self.notification_target

        if self.filter_configuration is not None:
            # Serialize filter_configuration (handle intrinsic functions)
            if hasattr(self.filter_configuration, 'to_dict'):
                props["FilterConfiguration"] = self.filter_configuration.to_dict()
            elif isinstance(self.filter_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_configuration
                ]
            else:
                props["FilterConfiguration"] = self.filter_configuration

        if self.custom_event_data is not None:
            # Serialize custom_event_data (handle intrinsic functions)
            if hasattr(self.custom_event_data, 'to_dict'):
                props["CustomEventData"] = self.custom_event_data.to_dict()
            elif isinstance(self.custom_event_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['CustomEventData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_event_data
                ]
            else:
                props["CustomEventData"] = self.custom_event_data

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.priority_configuration is not None:
            # Serialize priority_configuration (handle intrinsic functions)
            if hasattr(self.priority_configuration, 'to_dict'):
                props["PriorityConfiguration"] = self.priority_configuration.to_dict()
            elif isinstance(self.priority_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PriorityConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority_configuration
                ]
            else:
                props["PriorityConfiguration"] = self.priority_configuration

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class Location(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::Location"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.location_name is not None:
            # Serialize location_name (handle intrinsic functions)
            if hasattr(self.location_name, 'to_dict'):
                props["LocationName"] = self.location_name.to_dict()
            elif isinstance(self.location_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location_name
                ]
            else:
                props["LocationName"] = self.location_name

        return props

    @property
    def attr_location_arn(self) -> GetAtt:
        """Get the LocationArn attribute."""
        return self.get_att("LocationArn")




@dataclass
class GameProperty:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class MatchmakingConfiguration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::MatchmakingConfiguration"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_properties: Optional[list[GameProperty]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_session_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    acceptance_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    custom_event_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_player_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    backfill_mode: Optional[Union[str, BackfillMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    request_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    acceptance_required: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    creation_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    flex_match_mode: Optional[Union[str, FlexMatchMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_set_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    game_session_queue_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_set_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.game_properties is not None:
            # Serialize game_properties (handle intrinsic functions)
            if hasattr(self.game_properties, 'to_dict'):
                props["GameProperties"] = self.game_properties.to_dict()
            elif isinstance(self.game_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_properties
                ]
            else:
                props["GameProperties"] = self.game_properties

        if self.game_session_data is not None:
            # Serialize game_session_data (handle intrinsic functions)
            if hasattr(self.game_session_data, 'to_dict'):
                props["GameSessionData"] = self.game_session_data.to_dict()
            elif isinstance(self.game_session_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameSessionData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_session_data
                ]
            else:
                props["GameSessionData"] = self.game_session_data

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.acceptance_timeout_seconds is not None:
            # Serialize acceptance_timeout_seconds (handle intrinsic functions)
            if hasattr(self.acceptance_timeout_seconds, 'to_dict'):
                props["AcceptanceTimeoutSeconds"] = self.acceptance_timeout_seconds.to_dict()
            elif isinstance(self.acceptance_timeout_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceptanceTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acceptance_timeout_seconds
                ]
            else:
                props["AcceptanceTimeoutSeconds"] = self.acceptance_timeout_seconds

        if self.notification_target is not None:
            # Serialize notification_target (handle intrinsic functions)
            if hasattr(self.notification_target, 'to_dict'):
                props["NotificationTarget"] = self.notification_target.to_dict()
            elif isinstance(self.notification_target, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_target
                ]
            else:
                props["NotificationTarget"] = self.notification_target

        if self.custom_event_data is not None:
            # Serialize custom_event_data (handle intrinsic functions)
            if hasattr(self.custom_event_data, 'to_dict'):
                props["CustomEventData"] = self.custom_event_data.to_dict()
            elif isinstance(self.custom_event_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['CustomEventData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_event_data
                ]
            else:
                props["CustomEventData"] = self.custom_event_data

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.additional_player_count is not None:
            # Serialize additional_player_count (handle intrinsic functions)
            if hasattr(self.additional_player_count, 'to_dict'):
                props["AdditionalPlayerCount"] = self.additional_player_count.to_dict()
            elif isinstance(self.additional_player_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalPlayerCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_player_count
                ]
            else:
                props["AdditionalPlayerCount"] = self.additional_player_count

        if self.backfill_mode is not None:
            # Serialize backfill_mode (handle intrinsic functions)
            if hasattr(self.backfill_mode, 'to_dict'):
                props["BackfillMode"] = self.backfill_mode.to_dict()
            elif isinstance(self.backfill_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['BackfillMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.backfill_mode
                ]
            else:
                props["BackfillMode"] = self.backfill_mode

        if self.request_timeout_seconds is not None:
            # Serialize request_timeout_seconds (handle intrinsic functions)
            if hasattr(self.request_timeout_seconds, 'to_dict'):
                props["RequestTimeoutSeconds"] = self.request_timeout_seconds.to_dict()
            elif isinstance(self.request_timeout_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['RequestTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.request_timeout_seconds
                ]
            else:
                props["RequestTimeoutSeconds"] = self.request_timeout_seconds

        if self.acceptance_required is not None:
            # Serialize acceptance_required (handle intrinsic functions)
            if hasattr(self.acceptance_required, 'to_dict'):
                props["AcceptanceRequired"] = self.acceptance_required.to_dict()
            elif isinstance(self.acceptance_required, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceptanceRequired'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acceptance_required
                ]
            else:
                props["AcceptanceRequired"] = self.acceptance_required

        if self.creation_time is not None:
            # Serialize creation_time (handle intrinsic functions)
            if hasattr(self.creation_time, 'to_dict'):
                props["CreationTime"] = self.creation_time.to_dict()
            elif isinstance(self.creation_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['CreationTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.creation_time
                ]
            else:
                props["CreationTime"] = self.creation_time

        if self.flex_match_mode is not None:
            # Serialize flex_match_mode (handle intrinsic functions)
            if hasattr(self.flex_match_mode, 'to_dict'):
                props["FlexMatchMode"] = self.flex_match_mode.to_dict()
            elif isinstance(self.flex_match_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['FlexMatchMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.flex_match_mode
                ]
            else:
                props["FlexMatchMode"] = self.flex_match_mode

        if self.rule_set_name is not None:
            # Serialize rule_set_name (handle intrinsic functions)
            if hasattr(self.rule_set_name, 'to_dict'):
                props["RuleSetName"] = self.rule_set_name.to_dict()
            elif isinstance(self.rule_set_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleSetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_set_name
                ]
            else:
                props["RuleSetName"] = self.rule_set_name

        if self.game_session_queue_arns is not None:
            # Serialize game_session_queue_arns (handle intrinsic functions)
            if hasattr(self.game_session_queue_arns, 'to_dict'):
                props["GameSessionQueueArns"] = self.game_session_queue_arns.to_dict()
            elif isinstance(self.game_session_queue_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['GameSessionQueueArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.game_session_queue_arns
                ]
            else:
                props["GameSessionQueueArns"] = self.game_session_queue_arns

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.rule_set_arn is not None:
            # Serialize rule_set_arn (handle intrinsic functions)
            if hasattr(self.rule_set_arn, 'to_dict'):
                props["RuleSetArn"] = self.rule_set_arn.to_dict()
            elif isinstance(self.rule_set_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleSetArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_set_arn
                ]
            else:
                props["RuleSetArn"] = self.rule_set_arn

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class MatchmakingRuleSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::MatchmakingRuleSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_set_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.rule_set_body is not None:
            # Serialize rule_set_body (handle intrinsic functions)
            if hasattr(self.rule_set_body, 'to_dict'):
                props["RuleSetBody"] = self.rule_set_body.to_dict()
            elif isinstance(self.rule_set_body, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleSetBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_set_body
                ]
            else:
                props["RuleSetBody"] = self.rule_set_body

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.object_version is not None:
            if hasattr(self.object_version, 'to_dict'):
                props['ObjectVersion'] = self.object_version.to_dict()
            elif isinstance(self.object_version, list):
                props['ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.object_version
                ]
            else:
                props['ObjectVersion'] = self.object_version

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        return props


@dataclass
class Script(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamel"""

    resource_type: ClassVar[str] = "AWS::GameLift::Script"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    storage_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version is not None:
            # Serialize version (handle intrinsic functions)
            if hasattr(self.version, 'to_dict'):
                props["Version"] = self.version.to_dict()
            elif isinstance(self.version, list):
                # Serialize list items (may contain intrinsic functions)
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props["Version"] = self.version

        if self.storage_location is not None:
            # Serialize storage_location (handle intrinsic functions)
            if hasattr(self.storage_location, 'to_dict'):
                props["StorageLocation"] = self.storage_location.to_dict()
            elif isinstance(self.storage_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['StorageLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_location
                ]
            else:
                props["StorageLocation"] = self.storage_location

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_size_on_disk(self) -> GetAtt:
        """Get the SizeOnDisk attribute."""
        return self.get_att("SizeOnDisk")



