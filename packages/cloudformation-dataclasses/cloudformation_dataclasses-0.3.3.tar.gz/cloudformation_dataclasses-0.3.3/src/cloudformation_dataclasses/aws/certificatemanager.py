"""
AWS CloudFormation CertificateManager Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CertificateManager
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class CertificateExport:
    """CertificateExport enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class CertificateManagedBy:
    """CertificateManagedBy enum values."""

    CLOUDFRONT = "CLOUDFRONT"


class CertificateStatus:
    """CertificateStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    ISSUED = "ISSUED"
    INACTIVE = "INACTIVE"
    EXPIRED = "EXPIRED"
    VALIDATION_TIMED_OUT = "VALIDATION_TIMED_OUT"
    REVOKED = "REVOKED"
    FAILED = "FAILED"


class CertificateTransparencyLoggingPreference:
    """CertificateTransparencyLoggingPreference enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class CertificateType:
    """CertificateType enum values."""

    IMPORTED = "IMPORTED"
    AMAZON_ISSUED = "AMAZON_ISSUED"
    PRIVATE = "PRIVATE"


class DomainStatus:
    """DomainStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"


class ExtendedKeyUsageName:
    """ExtendedKeyUsageName enum values."""

    TLS_WEB_SERVER_AUTHENTICATION = "TLS_WEB_SERVER_AUTHENTICATION"
    TLS_WEB_CLIENT_AUTHENTICATION = "TLS_WEB_CLIENT_AUTHENTICATION"
    CODE_SIGNING = "CODE_SIGNING"
    EMAIL_PROTECTION = "EMAIL_PROTECTION"
    TIME_STAMPING = "TIME_STAMPING"
    OCSP_SIGNING = "OCSP_SIGNING"
    IPSEC_END_SYSTEM = "IPSEC_END_SYSTEM"
    IPSEC_TUNNEL = "IPSEC_TUNNEL"
    IPSEC_USER = "IPSEC_USER"
    ANY = "ANY"
    NONE = "NONE"
    CUSTOM = "CUSTOM"


class FailureReason:
    """FailureReason enum values."""

    NO_AVAILABLE_CONTACTS = "NO_AVAILABLE_CONTACTS"
    ADDITIONAL_VERIFICATION_REQUIRED = "ADDITIONAL_VERIFICATION_REQUIRED"
    DOMAIN_NOT_ALLOWED = "DOMAIN_NOT_ALLOWED"
    INVALID_PUBLIC_DOMAIN = "INVALID_PUBLIC_DOMAIN"
    DOMAIN_VALIDATION_DENIED = "DOMAIN_VALIDATION_DENIED"
    CAA_ERROR = "CAA_ERROR"
    PCA_LIMIT_EXCEEDED = "PCA_LIMIT_EXCEEDED"
    PCA_INVALID_ARN = "PCA_INVALID_ARN"
    PCA_INVALID_STATE = "PCA_INVALID_STATE"
    PCA_REQUEST_FAILED = "PCA_REQUEST_FAILED"
    PCA_NAME_CONSTRAINTS_VALIDATION = "PCA_NAME_CONSTRAINTS_VALIDATION"
    PCA_RESOURCE_NOT_FOUND = "PCA_RESOURCE_NOT_FOUND"
    PCA_INVALID_ARGS = "PCA_INVALID_ARGS"
    PCA_INVALID_DURATION = "PCA_INVALID_DURATION"
    PCA_ACCESS_DENIED = "PCA_ACCESS_DENIED"
    SLR_NOT_FOUND = "SLR_NOT_FOUND"
    OTHER = "OTHER"


class KeyAlgorithm:
    """KeyAlgorithm enum values."""

    RSA_1024 = "RSA_1024"
    RSA_2048 = "RSA_2048"
    RSA_3072 = "RSA_3072"
    RSA_4096 = "RSA_4096"
    EC_PRIME256V1 = "EC_prime256v1"
    EC_SECP384R1 = "EC_secp384r1"
    EC_SECP521R1 = "EC_secp521r1"


class KeyUsageName:
    """KeyUsageName enum values."""

    DIGITAL_SIGNATURE = "DIGITAL_SIGNATURE"
    NON_REPUDIATION = "NON_REPUDIATION"
    KEY_ENCIPHERMENT = "KEY_ENCIPHERMENT"
    DATA_ENCIPHERMENT = "DATA_ENCIPHERMENT"
    KEY_AGREEMENT = "KEY_AGREEMENT"
    CERTIFICATE_SIGNING = "CERTIFICATE_SIGNING"
    CRL_SIGNING = "CRL_SIGNING"
    ENCIPHER_ONLY = "ENCIPHER_ONLY"
    DECIPHER_ONLY = "DECIPHER_ONLY"
    ANY = "ANY"
    CUSTOM = "CUSTOM"


class RecordType:
    """RecordType enum values."""

    CNAME = "CNAME"


class RenewalEligibility:
    """RenewalEligibility enum values."""

    ELIGIBLE = "ELIGIBLE"
    INELIGIBLE = "INELIGIBLE"


class RenewalStatus:
    """RenewalStatus enum values."""

    PENDING_AUTO_RENEWAL = "PENDING_AUTO_RENEWAL"
    PENDING_VALIDATION = "PENDING_VALIDATION"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"


class RevocationReason:
    """RevocationReason enum values."""

    UNSPECIFIED = "UNSPECIFIED"
    KEY_COMPROMISE = "KEY_COMPROMISE"
    CA_COMPROMISE = "CA_COMPROMISE"
    AFFILIATION_CHANGED = "AFFILIATION_CHANGED"
    SUPERCEDED = "SUPERCEDED"
    SUPERSEDED = "SUPERSEDED"
    CESSATION_OF_OPERATION = "CESSATION_OF_OPERATION"
    CERTIFICATE_HOLD = "CERTIFICATE_HOLD"
    REMOVE_FROM_CRL = "REMOVE_FROM_CRL"
    PRIVILEGE_WITHDRAWN = "PRIVILEGE_WITHDRAWN"
    A_A_COMPROMISE = "A_A_COMPROMISE"


class SortBy:
    """SortBy enum values."""

    CREATED_AT = "CREATED_AT"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class ValidationMethod:
    """ValidationMethod enum values."""

    EMAIL = "EMAIL"
    DNS = "DNS"
    HTTP = "HTTP"


# Convenient aliases for enum values
ENABLED = CertificateExport.ENABLED
DISABLED = CertificateExport.DISABLED
CLOUDFRONT = CertificateManagedBy.CLOUDFRONT
PENDING_VALIDATION = CertificateStatus.PENDING_VALIDATION
ISSUED = CertificateStatus.ISSUED
INACTIVE = CertificateStatus.INACTIVE
EXPIRED = CertificateStatus.EXPIRED
VALIDATION_TIMED_OUT = CertificateStatus.VALIDATION_TIMED_OUT
REVOKED = CertificateStatus.REVOKED
FAILED = CertificateStatus.FAILED
ENABLED = CertificateTransparencyLoggingPreference.ENABLED
DISABLED = CertificateTransparencyLoggingPreference.DISABLED
IMPORTED = CertificateType.IMPORTED
AMAZON_ISSUED = CertificateType.AMAZON_ISSUED
PRIVATE = CertificateType.PRIVATE
PENDING_VALIDATION = DomainStatus.PENDING_VALIDATION
SUCCESS = DomainStatus.SUCCESS
FAILED = DomainStatus.FAILED
TLS_WEB_SERVER_AUTHENTICATION = ExtendedKeyUsageName.TLS_WEB_SERVER_AUTHENTICATION
TLS_WEB_CLIENT_AUTHENTICATION = ExtendedKeyUsageName.TLS_WEB_CLIENT_AUTHENTICATION
CODE_SIGNING = ExtendedKeyUsageName.CODE_SIGNING
EMAIL_PROTECTION = ExtendedKeyUsageName.EMAIL_PROTECTION
TIME_STAMPING = ExtendedKeyUsageName.TIME_STAMPING
OCSP_SIGNING = ExtendedKeyUsageName.OCSP_SIGNING
IPSEC_END_SYSTEM = ExtendedKeyUsageName.IPSEC_END_SYSTEM
IPSEC_TUNNEL = ExtendedKeyUsageName.IPSEC_TUNNEL
IPSEC_USER = ExtendedKeyUsageName.IPSEC_USER
ANY = ExtendedKeyUsageName.ANY
NONE = ExtendedKeyUsageName.NONE
CUSTOM = ExtendedKeyUsageName.CUSTOM
NO_AVAILABLE_CONTACTS = FailureReason.NO_AVAILABLE_CONTACTS
ADDITIONAL_VERIFICATION_REQUIRED = FailureReason.ADDITIONAL_VERIFICATION_REQUIRED
DOMAIN_NOT_ALLOWED = FailureReason.DOMAIN_NOT_ALLOWED
INVALID_PUBLIC_DOMAIN = FailureReason.INVALID_PUBLIC_DOMAIN
DOMAIN_VALIDATION_DENIED = FailureReason.DOMAIN_VALIDATION_DENIED
CAA_ERROR = FailureReason.CAA_ERROR
PCA_LIMIT_EXCEEDED = FailureReason.PCA_LIMIT_EXCEEDED
PCA_INVALID_ARN = FailureReason.PCA_INVALID_ARN
PCA_INVALID_STATE = FailureReason.PCA_INVALID_STATE
PCA_REQUEST_FAILED = FailureReason.PCA_REQUEST_FAILED
PCA_NAME_CONSTRAINTS_VALIDATION = FailureReason.PCA_NAME_CONSTRAINTS_VALIDATION
PCA_RESOURCE_NOT_FOUND = FailureReason.PCA_RESOURCE_NOT_FOUND
PCA_INVALID_ARGS = FailureReason.PCA_INVALID_ARGS
PCA_INVALID_DURATION = FailureReason.PCA_INVALID_DURATION
PCA_ACCESS_DENIED = FailureReason.PCA_ACCESS_DENIED
SLR_NOT_FOUND = FailureReason.SLR_NOT_FOUND
OTHER = FailureReason.OTHER
RSA_1024 = KeyAlgorithm.RSA_1024
RSA_2048 = KeyAlgorithm.RSA_2048
RSA_3072 = KeyAlgorithm.RSA_3072
RSA_4096 = KeyAlgorithm.RSA_4096
EC_PRIME256V1 = KeyAlgorithm.EC_PRIME256V1
EC_SECP384R1 = KeyAlgorithm.EC_SECP384R1
EC_SECP521R1 = KeyAlgorithm.EC_SECP521R1
DIGITAL_SIGNATURE = KeyUsageName.DIGITAL_SIGNATURE
NON_REPUDIATION = KeyUsageName.NON_REPUDIATION
KEY_ENCIPHERMENT = KeyUsageName.KEY_ENCIPHERMENT
DATA_ENCIPHERMENT = KeyUsageName.DATA_ENCIPHERMENT
KEY_AGREEMENT = KeyUsageName.KEY_AGREEMENT
CERTIFICATE_SIGNING = KeyUsageName.CERTIFICATE_SIGNING
CRL_SIGNING = KeyUsageName.CRL_SIGNING
ENCIPHER_ONLY = KeyUsageName.ENCIPHER_ONLY
DECIPHER_ONLY = KeyUsageName.DECIPHER_ONLY
ANY = KeyUsageName.ANY
CUSTOM = KeyUsageName.CUSTOM
CNAME = RecordType.CNAME
ELIGIBLE = RenewalEligibility.ELIGIBLE
INELIGIBLE = RenewalEligibility.INELIGIBLE
PENDING_AUTO_RENEWAL = RenewalStatus.PENDING_AUTO_RENEWAL
PENDING_VALIDATION = RenewalStatus.PENDING_VALIDATION
SUCCESS = RenewalStatus.SUCCESS
FAILED = RenewalStatus.FAILED
UNSPECIFIED = RevocationReason.UNSPECIFIED
KEY_COMPROMISE = RevocationReason.KEY_COMPROMISE
CA_COMPROMISE = RevocationReason.CA_COMPROMISE
AFFILIATION_CHANGED = RevocationReason.AFFILIATION_CHANGED
SUPERCEDED = RevocationReason.SUPERCEDED
SUPERSEDED = RevocationReason.SUPERSEDED
CESSATION_OF_OPERATION = RevocationReason.CESSATION_OF_OPERATION
CERTIFICATE_HOLD = RevocationReason.CERTIFICATE_HOLD
REMOVE_FROM_CRL = RevocationReason.REMOVE_FROM_CRL
PRIVILEGE_WITHDRAWN = RevocationReason.PRIVILEGE_WITHDRAWN
A_A_COMPROMISE = RevocationReason.A_A_COMPROMISE
CREATED_AT = SortBy.CREATED_AT
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
EMAIL = ValidationMethod.EMAIL
DNS = ValidationMethod.DNS
HTTP = ValidationMethod.HTTP


@dataclass
class ExpiryEventsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cer"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    days_before_expiry: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.days_before_expiry is not None:
            if hasattr(self.days_before_expiry, 'to_dict'):
                props['DaysBeforeExpiry'] = self.days_before_expiry.to_dict()
            elif isinstance(self.days_before_expiry, list):
                props['DaysBeforeExpiry'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.days_before_expiry
                ]
            else:
                props['DaysBeforeExpiry'] = self.days_before_expiry

        return props


@dataclass
class Account(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certi"""

    resource_type: ClassVar[str] = "AWS::CertificateManager::Account"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expiry_events_configuration: Optional[ExpiryEventsConfiguration] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.expiry_events_configuration is not None:
            # Serialize expiry_events_configuration (handle intrinsic functions)
            if hasattr(self.expiry_events_configuration, 'to_dict'):
                props["ExpiryEventsConfiguration"] = self.expiry_events_configuration.to_dict()
            elif isinstance(self.expiry_events_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpiryEventsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expiry_events_configuration
                ]
            else:
                props["ExpiryEventsConfiguration"] = self.expiry_events_configuration

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")




@dataclass
class DomainValidationOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cer"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hosted_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    validation_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_name is not None:
            if hasattr(self.domain_name, 'to_dict'):
                props['DomainName'] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props['DomainName'] = self.domain_name

        if self.hosted_zone_id is not None:
            if hasattr(self.hosted_zone_id, 'to_dict'):
                props['HostedZoneId'] = self.hosted_zone_id.to_dict()
            elif isinstance(self.hosted_zone_id, list):
                props['HostedZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hosted_zone_id
                ]
            else:
                props['HostedZoneId'] = self.hosted_zone_id

        if self.validation_domain is not None:
            if hasattr(self.validation_domain, 'to_dict'):
                props['ValidationDomain'] = self.validation_domain.to_dict()
            elif isinstance(self.validation_domain, list):
                props['ValidationDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_domain
                ]
            else:
                props['ValidationDomain'] = self.validation_domain

        return props


@dataclass
class Certificate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certi"""

    resource_type: ClassVar[str] = "AWS::CertificateManager::Certificate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_authority_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_export: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_transparency_logging_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_validation_options: Optional[list[DomainValidationOption]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_algorithm: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subject_alternative_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    validation_method: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.certificate_authority_arn is not None:
            # Serialize certificate_authority_arn (handle intrinsic functions)
            if hasattr(self.certificate_authority_arn, 'to_dict'):
                props["CertificateAuthorityArn"] = self.certificate_authority_arn.to_dict()
            elif isinstance(self.certificate_authority_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateAuthorityArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_authority_arn
                ]
            else:
                props["CertificateAuthorityArn"] = self.certificate_authority_arn

        if self.certificate_export is not None:
            # Serialize certificate_export (handle intrinsic functions)
            if hasattr(self.certificate_export, 'to_dict'):
                props["CertificateExport"] = self.certificate_export.to_dict()
            elif isinstance(self.certificate_export, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateExport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_export
                ]
            else:
                props["CertificateExport"] = self.certificate_export

        if self.certificate_transparency_logging_preference is not None:
            # Serialize certificate_transparency_logging_preference (handle intrinsic functions)
            if hasattr(self.certificate_transparency_logging_preference, 'to_dict'):
                props["CertificateTransparencyLoggingPreference"] = self.certificate_transparency_logging_preference.to_dict()
            elif isinstance(self.certificate_transparency_logging_preference, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateTransparencyLoggingPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_transparency_logging_preference
                ]
            else:
                props["CertificateTransparencyLoggingPreference"] = self.certificate_transparency_logging_preference

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.domain_validation_options is not None:
            # Serialize domain_validation_options (handle intrinsic functions)
            if hasattr(self.domain_validation_options, 'to_dict'):
                props["DomainValidationOptions"] = self.domain_validation_options.to_dict()
            elif isinstance(self.domain_validation_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainValidationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_validation_options
                ]
            else:
                props["DomainValidationOptions"] = self.domain_validation_options

        if self.key_algorithm is not None:
            # Serialize key_algorithm (handle intrinsic functions)
            if hasattr(self.key_algorithm, 'to_dict'):
                props["KeyAlgorithm"] = self.key_algorithm.to_dict()
            elif isinstance(self.key_algorithm, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyAlgorithm'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_algorithm
                ]
            else:
                props["KeyAlgorithm"] = self.key_algorithm

        if self.subject_alternative_names is not None:
            # Serialize subject_alternative_names (handle intrinsic functions)
            if hasattr(self.subject_alternative_names, 'to_dict'):
                props["SubjectAlternativeNames"] = self.subject_alternative_names.to_dict()
            elif isinstance(self.subject_alternative_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubjectAlternativeNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subject_alternative_names
                ]
            else:
                props["SubjectAlternativeNames"] = self.subject_alternative_names

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.validation_method is not None:
            # Serialize validation_method (handle intrinsic functions)
            if hasattr(self.validation_method, 'to_dict'):
                props["ValidationMethod"] = self.validation_method.to_dict()
            elif isinstance(self.validation_method, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidationMethod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_method
                ]
            else:
                props["ValidationMethod"] = self.validation_method

        return props


