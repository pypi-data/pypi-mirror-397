"""
AWS CloudFormation Comprehend Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Comprehend
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AugmentedManifestsDocumentTypeFormat:
    """AugmentedManifestsDocumentTypeFormat enum values."""

    PLAIN_TEXT_DOCUMENT = "PLAIN_TEXT_DOCUMENT"
    SEMI_STRUCTURED_DOCUMENT = "SEMI_STRUCTURED_DOCUMENT"


class BlockType:
    """BlockType enum values."""

    LINE = "LINE"
    WORD = "WORD"


class DatasetDataFormat:
    """DatasetDataFormat enum values."""

    COMPREHEND_CSV = "COMPREHEND_CSV"
    AUGMENTED_MANIFEST = "AUGMENTED_MANIFEST"


class DatasetStatus:
    """DatasetStatus enum values."""

    CREATING = "CREATING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class DatasetType:
    """DatasetType enum values."""

    TRAIN = "TRAIN"
    TEST = "TEST"


class DocumentClassifierDataFormat:
    """DocumentClassifierDataFormat enum values."""

    COMPREHEND_CSV = "COMPREHEND_CSV"
    AUGMENTED_MANIFEST = "AUGMENTED_MANIFEST"


class DocumentClassifierDocumentTypeFormat:
    """DocumentClassifierDocumentTypeFormat enum values."""

    PLAIN_TEXT_DOCUMENT = "PLAIN_TEXT_DOCUMENT"
    SEMI_STRUCTURED_DOCUMENT = "SEMI_STRUCTURED_DOCUMENT"


class DocumentClassifierMode:
    """DocumentClassifierMode enum values."""

    MULTI_CLASS = "MULTI_CLASS"
    MULTI_LABEL = "MULTI_LABEL"


class DocumentReadAction:
    """DocumentReadAction enum values."""

    TEXTRACT_DETECT_DOCUMENT_TEXT = "TEXTRACT_DETECT_DOCUMENT_TEXT"
    TEXTRACT_ANALYZE_DOCUMENT = "TEXTRACT_ANALYZE_DOCUMENT"


class DocumentReadFeatureTypes:
    """DocumentReadFeatureTypes enum values."""

    TABLES = "TABLES"
    FORMS = "FORMS"


class DocumentReadMode:
    """DocumentReadMode enum values."""

    SERVICE_DEFAULT = "SERVICE_DEFAULT"
    FORCE_DOCUMENT_READ_ACTION = "FORCE_DOCUMENT_READ_ACTION"


class DocumentType:
    """DocumentType enum values."""

    NATIVE_PDF = "NATIVE_PDF"
    SCANNED_PDF = "SCANNED_PDF"
    MS_WORD = "MS_WORD"
    IMAGE = "IMAGE"
    PLAIN_TEXT = "PLAIN_TEXT"
    TEXTRACT_DETECT_DOCUMENT_TEXT_JSON = "TEXTRACT_DETECT_DOCUMENT_TEXT_JSON"
    TEXTRACT_ANALYZE_DOCUMENT_JSON = "TEXTRACT_ANALYZE_DOCUMENT_JSON"


class EndpointStatus:
    """EndpointStatus enum values."""

    CREATING = "CREATING"
    DELETING = "DELETING"
    FAILED = "FAILED"
    IN_SERVICE = "IN_SERVICE"
    UPDATING = "UPDATING"


class EntityRecognizerDataFormat:
    """EntityRecognizerDataFormat enum values."""

    COMPREHEND_CSV = "COMPREHEND_CSV"
    AUGMENTED_MANIFEST = "AUGMENTED_MANIFEST"


class EntityType:
    """EntityType enum values."""

    PERSON = "PERSON"
    LOCATION = "LOCATION"
    ORGANIZATION = "ORGANIZATION"
    COMMERCIAL_ITEM = "COMMERCIAL_ITEM"
    EVENT = "EVENT"
    DATE = "DATE"
    QUANTITY = "QUANTITY"
    TITLE = "TITLE"
    OTHER = "OTHER"


class FlywheelIterationStatus:
    """FlywheelIterationStatus enum values."""

    TRAINING = "TRAINING"
    EVALUATING = "EVALUATING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STOP_REQUESTED = "STOP_REQUESTED"
    STOPPED = "STOPPED"


class FlywheelStatus:
    """FlywheelStatus enum values."""

    CREATING = "CREATING"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    DELETING = "DELETING"
    FAILED = "FAILED"


class InputFormat:
    """InputFormat enum values."""

    ONE_DOC_PER_FILE = "ONE_DOC_PER_FILE"
    ONE_DOC_PER_LINE = "ONE_DOC_PER_LINE"


class InvalidRequestDetailReason:
    """InvalidRequestDetailReason enum values."""

    DOCUMENT_SIZE_EXCEEDED = "DOCUMENT_SIZE_EXCEEDED"
    UNSUPPORTED_DOC_TYPE = "UNSUPPORTED_DOC_TYPE"
    PAGE_LIMIT_EXCEEDED = "PAGE_LIMIT_EXCEEDED"
    TEXTRACT_ACCESS_DENIED = "TEXTRACT_ACCESS_DENIED"


class InvalidRequestReason:
    """InvalidRequestReason enum values."""

    INVALID_DOCUMENT = "INVALID_DOCUMENT"


class JobStatus:
    """JobStatus enum values."""

    SUBMITTED = "SUBMITTED"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STOP_REQUESTED = "STOP_REQUESTED"
    STOPPED = "STOPPED"


class LanguageCode:
    """LanguageCode enum values."""

    EN = "en"
    ES = "es"
    FR = "fr"
    DE = "de"
    IT = "it"
    PT = "pt"
    AR = "ar"
    HI = "hi"
    JA = "ja"
    KO = "ko"
    ZH = "zh"
    ZH_TW = "zh-TW"


class ModelStatus:
    """ModelStatus enum values."""

    SUBMITTED = "SUBMITTED"
    TRAINING = "TRAINING"
    DELETING = "DELETING"
    STOP_REQUESTED = "STOP_REQUESTED"
    STOPPED = "STOPPED"
    IN_ERROR = "IN_ERROR"
    TRAINED = "TRAINED"
    TRAINED_WITH_WARNING = "TRAINED_WITH_WARNING"


class ModelType:
    """ModelType enum values."""

    DOCUMENT_CLASSIFIER = "DOCUMENT_CLASSIFIER"
    ENTITY_RECOGNIZER = "ENTITY_RECOGNIZER"


class PageBasedErrorCode:
    """PageBasedErrorCode enum values."""

    TEXTRACT_BAD_PAGE = "TEXTRACT_BAD_PAGE"
    TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED = "TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED"
    PAGE_CHARACTERS_EXCEEDED = "PAGE_CHARACTERS_EXCEEDED"
    PAGE_SIZE_EXCEEDED = "PAGE_SIZE_EXCEEDED"
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR"


class PageBasedWarningCode:
    """PageBasedWarningCode enum values."""

    INFERENCING_PLAINTEXT_WITH_NATIVE_TRAINED_MODEL = "INFERENCING_PLAINTEXT_WITH_NATIVE_TRAINED_MODEL"
    INFERENCING_NATIVE_DOCUMENT_WITH_PLAINTEXT_TRAINED_MODEL = "INFERENCING_NATIVE_DOCUMENT_WITH_PLAINTEXT_TRAINED_MODEL"


class PartOfSpeechTagType:
    """PartOfSpeechTagType enum values."""

    ADJ = "ADJ"
    ADP = "ADP"
    ADV = "ADV"
    AUX = "AUX"
    CONJ = "CONJ"
    CCONJ = "CCONJ"
    DET = "DET"
    INTJ = "INTJ"
    NOUN = "NOUN"
    NUM = "NUM"
    O = "O"
    PART = "PART"
    PRON = "PRON"
    PROPN = "PROPN"
    PUNCT = "PUNCT"
    SCONJ = "SCONJ"
    SYM = "SYM"
    VERB = "VERB"


class PiiEntitiesDetectionMaskMode:
    """PiiEntitiesDetectionMaskMode enum values."""

    MASK = "MASK"
    REPLACE_WITH_PII_ENTITY_TYPE = "REPLACE_WITH_PII_ENTITY_TYPE"


class PiiEntitiesDetectionMode:
    """PiiEntitiesDetectionMode enum values."""

    ONLY_REDACTION = "ONLY_REDACTION"
    ONLY_OFFSETS = "ONLY_OFFSETS"


class PiiEntityType:
    """PiiEntityType enum values."""

    BANK_ACCOUNT_NUMBER = "BANK_ACCOUNT_NUMBER"
    BANK_ROUTING = "BANK_ROUTING"
    CREDIT_DEBIT_NUMBER = "CREDIT_DEBIT_NUMBER"
    CREDIT_DEBIT_CVV = "CREDIT_DEBIT_CVV"
    CREDIT_DEBIT_EXPIRY = "CREDIT_DEBIT_EXPIRY"
    PIN = "PIN"
    EMAIL = "EMAIL"
    ADDRESS = "ADDRESS"
    NAME = "NAME"
    PHONE = "PHONE"
    SSN = "SSN"
    DATE_TIME = "DATE_TIME"
    PASSPORT_NUMBER = "PASSPORT_NUMBER"
    DRIVER_ID = "DRIVER_ID"
    URL = "URL"
    AGE = "AGE"
    USERNAME = "USERNAME"
    PASSWORD = "PASSWORD"
    AWS_ACCESS_KEY = "AWS_ACCESS_KEY"
    AWS_SECRET_KEY = "AWS_SECRET_KEY"
    IP_ADDRESS = "IP_ADDRESS"
    MAC_ADDRESS = "MAC_ADDRESS"
    ALL = "ALL"
    LICENSE_PLATE = "LICENSE_PLATE"
    VEHICLE_IDENTIFICATION_NUMBER = "VEHICLE_IDENTIFICATION_NUMBER"
    UK_NATIONAL_INSURANCE_NUMBER = "UK_NATIONAL_INSURANCE_NUMBER"
    CA_SOCIAL_INSURANCE_NUMBER = "CA_SOCIAL_INSURANCE_NUMBER"
    US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
    UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
    IN_PERMANENT_ACCOUNT_NUMBER = "IN_PERMANENT_ACCOUNT_NUMBER"
    IN_NREGA = "IN_NREGA"
    INTERNATIONAL_BANK_ACCOUNT_NUMBER = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
    SWIFT_CODE = "SWIFT_CODE"
    UK_NATIONAL_HEALTH_SERVICE_NUMBER = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
    CA_HEALTH_NUMBER = "CA_HEALTH_NUMBER"
    IN_AADHAAR = "IN_AADHAAR"
    IN_VOTER_NUMBER = "IN_VOTER_NUMBER"


class RelationshipType:
    """RelationshipType enum values."""

    CHILD = "CHILD"


class SentimentType:
    """SentimentType enum values."""

    POSITIVE = "POSITIVE"
    NEGATIVE = "NEGATIVE"
    NEUTRAL = "NEUTRAL"
    MIXED = "MIXED"


class Split:
    """Split enum values."""

    TRAIN = "TRAIN"
    TEST = "TEST"


class SyntaxLanguageCode:
    """SyntaxLanguageCode enum values."""

    EN = "en"
    ES = "es"
    FR = "fr"
    DE = "de"
    IT = "it"
    PT = "pt"


class TargetedSentimentEntityType:
    """TargetedSentimentEntityType enum values."""

    PERSON = "PERSON"
    LOCATION = "LOCATION"
    ORGANIZATION = "ORGANIZATION"
    FACILITY = "FACILITY"
    BRAND = "BRAND"
    COMMERCIAL_ITEM = "COMMERCIAL_ITEM"
    MOVIE = "MOVIE"
    MUSIC = "MUSIC"
    BOOK = "BOOK"
    SOFTWARE = "SOFTWARE"
    GAME = "GAME"
    PERSONAL_TITLE = "PERSONAL_TITLE"
    EVENT = "EVENT"
    DATE = "DATE"
    QUANTITY = "QUANTITY"
    ATTRIBUTE = "ATTRIBUTE"
    OTHER = "OTHER"


class ToxicContentType:
    """ToxicContentType enum values."""

    GRAPHIC = "GRAPHIC"
    HARASSMENT_OR_ABUSE = "HARASSMENT_OR_ABUSE"
    HATE_SPEECH = "HATE_SPEECH"
    INSULT = "INSULT"
    PROFANITY = "PROFANITY"
    SEXUAL = "SEXUAL"
    VIOLENCE_OR_THREAT = "VIOLENCE_OR_THREAT"


# Convenient aliases for enum values
PLAIN_TEXT_DOCUMENT = AugmentedManifestsDocumentTypeFormat.PLAIN_TEXT_DOCUMENT
SEMI_STRUCTURED_DOCUMENT = AugmentedManifestsDocumentTypeFormat.SEMI_STRUCTURED_DOCUMENT
LINE = BlockType.LINE
WORD = BlockType.WORD
COMPREHEND_CSV = DatasetDataFormat.COMPREHEND_CSV
AUGMENTED_MANIFEST = DatasetDataFormat.AUGMENTED_MANIFEST
CREATING = DatasetStatus.CREATING
COMPLETED = DatasetStatus.COMPLETED
FAILED = DatasetStatus.FAILED
TRAIN = DatasetType.TRAIN
TEST = DatasetType.TEST
COMPREHEND_CSV = DocumentClassifierDataFormat.COMPREHEND_CSV
AUGMENTED_MANIFEST = DocumentClassifierDataFormat.AUGMENTED_MANIFEST
PLAIN_TEXT_DOCUMENT = DocumentClassifierDocumentTypeFormat.PLAIN_TEXT_DOCUMENT
SEMI_STRUCTURED_DOCUMENT = DocumentClassifierDocumentTypeFormat.SEMI_STRUCTURED_DOCUMENT
MULTI_CLASS = DocumentClassifierMode.MULTI_CLASS
MULTI_LABEL = DocumentClassifierMode.MULTI_LABEL
TEXTRACT_DETECT_DOCUMENT_TEXT = DocumentReadAction.TEXTRACT_DETECT_DOCUMENT_TEXT
TEXTRACT_ANALYZE_DOCUMENT = DocumentReadAction.TEXTRACT_ANALYZE_DOCUMENT
TABLES = DocumentReadFeatureTypes.TABLES
FORMS = DocumentReadFeatureTypes.FORMS
SERVICE_DEFAULT = DocumentReadMode.SERVICE_DEFAULT
FORCE_DOCUMENT_READ_ACTION = DocumentReadMode.FORCE_DOCUMENT_READ_ACTION
NATIVE_PDF = DocumentType.NATIVE_PDF
SCANNED_PDF = DocumentType.SCANNED_PDF
MS_WORD = DocumentType.MS_WORD
IMAGE = DocumentType.IMAGE
PLAIN_TEXT = DocumentType.PLAIN_TEXT
TEXTRACT_DETECT_DOCUMENT_TEXT_JSON = DocumentType.TEXTRACT_DETECT_DOCUMENT_TEXT_JSON
TEXTRACT_ANALYZE_DOCUMENT_JSON = DocumentType.TEXTRACT_ANALYZE_DOCUMENT_JSON
CREATING = EndpointStatus.CREATING
DELETING = EndpointStatus.DELETING
FAILED = EndpointStatus.FAILED
IN_SERVICE = EndpointStatus.IN_SERVICE
UPDATING = EndpointStatus.UPDATING
COMPREHEND_CSV = EntityRecognizerDataFormat.COMPREHEND_CSV
AUGMENTED_MANIFEST = EntityRecognizerDataFormat.AUGMENTED_MANIFEST
PERSON = EntityType.PERSON
LOCATION = EntityType.LOCATION
ORGANIZATION = EntityType.ORGANIZATION
COMMERCIAL_ITEM = EntityType.COMMERCIAL_ITEM
EVENT = EntityType.EVENT
DATE = EntityType.DATE
QUANTITY = EntityType.QUANTITY
TITLE = EntityType.TITLE
OTHER = EntityType.OTHER
TRAINING = FlywheelIterationStatus.TRAINING
EVALUATING = FlywheelIterationStatus.EVALUATING
COMPLETED = FlywheelIterationStatus.COMPLETED
FAILED = FlywheelIterationStatus.FAILED
STOP_REQUESTED = FlywheelIterationStatus.STOP_REQUESTED
STOPPED = FlywheelIterationStatus.STOPPED
CREATING = FlywheelStatus.CREATING
ACTIVE = FlywheelStatus.ACTIVE
UPDATING = FlywheelStatus.UPDATING
DELETING = FlywheelStatus.DELETING
FAILED = FlywheelStatus.FAILED
ONE_DOC_PER_FILE = InputFormat.ONE_DOC_PER_FILE
ONE_DOC_PER_LINE = InputFormat.ONE_DOC_PER_LINE
DOCUMENT_SIZE_EXCEEDED = InvalidRequestDetailReason.DOCUMENT_SIZE_EXCEEDED
UNSUPPORTED_DOC_TYPE = InvalidRequestDetailReason.UNSUPPORTED_DOC_TYPE
PAGE_LIMIT_EXCEEDED = InvalidRequestDetailReason.PAGE_LIMIT_EXCEEDED
TEXTRACT_ACCESS_DENIED = InvalidRequestDetailReason.TEXTRACT_ACCESS_DENIED
INVALID_DOCUMENT = InvalidRequestReason.INVALID_DOCUMENT
SUBMITTED = JobStatus.SUBMITTED
IN_PROGRESS = JobStatus.IN_PROGRESS
COMPLETED = JobStatus.COMPLETED
FAILED = JobStatus.FAILED
STOP_REQUESTED = JobStatus.STOP_REQUESTED
STOPPED = JobStatus.STOPPED
EN = LanguageCode.EN
ES = LanguageCode.ES
FR = LanguageCode.FR
DE = LanguageCode.DE
IT = LanguageCode.IT
PT = LanguageCode.PT
AR = LanguageCode.AR
HI = LanguageCode.HI
JA = LanguageCode.JA
KO = LanguageCode.KO
ZH = LanguageCode.ZH
ZH_TW = LanguageCode.ZH_TW
SUBMITTED = ModelStatus.SUBMITTED
TRAINING = ModelStatus.TRAINING
DELETING = ModelStatus.DELETING
STOP_REQUESTED = ModelStatus.STOP_REQUESTED
STOPPED = ModelStatus.STOPPED
IN_ERROR = ModelStatus.IN_ERROR
TRAINED = ModelStatus.TRAINED
TRAINED_WITH_WARNING = ModelStatus.TRAINED_WITH_WARNING
DOCUMENT_CLASSIFIER = ModelType.DOCUMENT_CLASSIFIER
ENTITY_RECOGNIZER = ModelType.ENTITY_RECOGNIZER
TEXTRACT_BAD_PAGE = PageBasedErrorCode.TEXTRACT_BAD_PAGE
TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED = PageBasedErrorCode.TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED
PAGE_CHARACTERS_EXCEEDED = PageBasedErrorCode.PAGE_CHARACTERS_EXCEEDED
PAGE_SIZE_EXCEEDED = PageBasedErrorCode.PAGE_SIZE_EXCEEDED
INTERNAL_SERVER_ERROR = PageBasedErrorCode.INTERNAL_SERVER_ERROR
INFERENCING_PLAINTEXT_WITH_NATIVE_TRAINED_MODEL = PageBasedWarningCode.INFERENCING_PLAINTEXT_WITH_NATIVE_TRAINED_MODEL
INFERENCING_NATIVE_DOCUMENT_WITH_PLAINTEXT_TRAINED_MODEL = PageBasedWarningCode.INFERENCING_NATIVE_DOCUMENT_WITH_PLAINTEXT_TRAINED_MODEL
ADJ = PartOfSpeechTagType.ADJ
ADP = PartOfSpeechTagType.ADP
ADV = PartOfSpeechTagType.ADV
AUX = PartOfSpeechTagType.AUX
CONJ = PartOfSpeechTagType.CONJ
CCONJ = PartOfSpeechTagType.CCONJ
DET = PartOfSpeechTagType.DET
INTJ = PartOfSpeechTagType.INTJ
NOUN = PartOfSpeechTagType.NOUN
NUM = PartOfSpeechTagType.NUM
O = PartOfSpeechTagType.O
PART = PartOfSpeechTagType.PART
PRON = PartOfSpeechTagType.PRON
PROPN = PartOfSpeechTagType.PROPN
PUNCT = PartOfSpeechTagType.PUNCT
SCONJ = PartOfSpeechTagType.SCONJ
SYM = PartOfSpeechTagType.SYM
VERB = PartOfSpeechTagType.VERB
MASK = PiiEntitiesDetectionMaskMode.MASK
REPLACE_WITH_PII_ENTITY_TYPE = PiiEntitiesDetectionMaskMode.REPLACE_WITH_PII_ENTITY_TYPE
ONLY_REDACTION = PiiEntitiesDetectionMode.ONLY_REDACTION
ONLY_OFFSETS = PiiEntitiesDetectionMode.ONLY_OFFSETS
BANK_ACCOUNT_NUMBER = PiiEntityType.BANK_ACCOUNT_NUMBER
BANK_ROUTING = PiiEntityType.BANK_ROUTING
CREDIT_DEBIT_NUMBER = PiiEntityType.CREDIT_DEBIT_NUMBER
CREDIT_DEBIT_CVV = PiiEntityType.CREDIT_DEBIT_CVV
CREDIT_DEBIT_EXPIRY = PiiEntityType.CREDIT_DEBIT_EXPIRY
PIN = PiiEntityType.PIN
EMAIL = PiiEntityType.EMAIL
ADDRESS = PiiEntityType.ADDRESS
NAME = PiiEntityType.NAME
PHONE = PiiEntityType.PHONE
SSN = PiiEntityType.SSN
DATE_TIME = PiiEntityType.DATE_TIME
PASSPORT_NUMBER = PiiEntityType.PASSPORT_NUMBER
DRIVER_ID = PiiEntityType.DRIVER_ID
URL = PiiEntityType.URL
AGE = PiiEntityType.AGE
USERNAME = PiiEntityType.USERNAME
PASSWORD = PiiEntityType.PASSWORD
AWS_ACCESS_KEY = PiiEntityType.AWS_ACCESS_KEY
AWS_SECRET_KEY = PiiEntityType.AWS_SECRET_KEY
IP_ADDRESS = PiiEntityType.IP_ADDRESS
MAC_ADDRESS = PiiEntityType.MAC_ADDRESS
ALL = PiiEntityType.ALL
LICENSE_PLATE = PiiEntityType.LICENSE_PLATE
VEHICLE_IDENTIFICATION_NUMBER = PiiEntityType.VEHICLE_IDENTIFICATION_NUMBER
UK_NATIONAL_INSURANCE_NUMBER = PiiEntityType.UK_NATIONAL_INSURANCE_NUMBER
CA_SOCIAL_INSURANCE_NUMBER = PiiEntityType.CA_SOCIAL_INSURANCE_NUMBER
US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER = PiiEntityType.US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER
UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER = PiiEntityType.UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER
IN_PERMANENT_ACCOUNT_NUMBER = PiiEntityType.IN_PERMANENT_ACCOUNT_NUMBER
IN_NREGA = PiiEntityType.IN_NREGA
INTERNATIONAL_BANK_ACCOUNT_NUMBER = PiiEntityType.INTERNATIONAL_BANK_ACCOUNT_NUMBER
SWIFT_CODE = PiiEntityType.SWIFT_CODE
UK_NATIONAL_HEALTH_SERVICE_NUMBER = PiiEntityType.UK_NATIONAL_HEALTH_SERVICE_NUMBER
CA_HEALTH_NUMBER = PiiEntityType.CA_HEALTH_NUMBER
IN_AADHAAR = PiiEntityType.IN_AADHAAR
IN_VOTER_NUMBER = PiiEntityType.IN_VOTER_NUMBER
CHILD = RelationshipType.CHILD
POSITIVE = SentimentType.POSITIVE
NEGATIVE = SentimentType.NEGATIVE
NEUTRAL = SentimentType.NEUTRAL
MIXED = SentimentType.MIXED
TRAIN = Split.TRAIN
TEST = Split.TEST
EN = SyntaxLanguageCode.EN
ES = SyntaxLanguageCode.ES
FR = SyntaxLanguageCode.FR
DE = SyntaxLanguageCode.DE
IT = SyntaxLanguageCode.IT
PT = SyntaxLanguageCode.PT
PERSON = TargetedSentimentEntityType.PERSON
LOCATION = TargetedSentimentEntityType.LOCATION
ORGANIZATION = TargetedSentimentEntityType.ORGANIZATION
FACILITY = TargetedSentimentEntityType.FACILITY
BRAND = TargetedSentimentEntityType.BRAND
COMMERCIAL_ITEM = TargetedSentimentEntityType.COMMERCIAL_ITEM
MOVIE = TargetedSentimentEntityType.MOVIE
MUSIC = TargetedSentimentEntityType.MUSIC
BOOK = TargetedSentimentEntityType.BOOK
SOFTWARE = TargetedSentimentEntityType.SOFTWARE
GAME = TargetedSentimentEntityType.GAME
PERSONAL_TITLE = TargetedSentimentEntityType.PERSONAL_TITLE
EVENT = TargetedSentimentEntityType.EVENT
DATE = TargetedSentimentEntityType.DATE
QUANTITY = TargetedSentimentEntityType.QUANTITY
ATTRIBUTE = TargetedSentimentEntityType.ATTRIBUTE
OTHER = TargetedSentimentEntityType.OTHER
GRAPHIC = ToxicContentType.GRAPHIC
HARASSMENT_OR_ABUSE = ToxicContentType.HARASSMENT_OR_ABUSE
HATE_SPEECH = ToxicContentType.HATE_SPEECH
INSULT = ToxicContentType.INSULT
PROFANITY = ToxicContentType.PROFANITY
SEXUAL = ToxicContentType.SEXUAL
VIOLENCE_OR_THREAT = ToxicContentType.VIOLENCE_OR_THREAT


@dataclass
class AugmentedManifestsListItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    split: Optional[Union[str, Split, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.attribute_names is not None:
            if hasattr(self.attribute_names, 'to_dict'):
                props['AttributeNames'] = self.attribute_names.to_dict()
            elif isinstance(self.attribute_names, list):
                props['AttributeNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute_names
                ]
            else:
                props['AttributeNames'] = self.attribute_names

        if self.split is not None:
            if hasattr(self.split, 'to_dict'):
                props['Split'] = self.split.to_dict()
            elif isinstance(self.split, list):
                props['Split'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split
                ]
            else:
                props['Split'] = self.split

        return props


@dataclass
class DocumentClassifierDocuments:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    test_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.test_s3_uri is not None:
            if hasattr(self.test_s3_uri, 'to_dict'):
                props['TestS3Uri'] = self.test_s3_uri.to_dict()
            elif isinstance(self.test_s3_uri, list):
                props['TestS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.test_s3_uri
                ]
            else:
                props['TestS3Uri'] = self.test_s3_uri

        return props


@dataclass
class DocumentClassifierInputDataConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_reader_config: Optional[DocumentReaderConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    documents: Optional[DocumentClassifierDocuments] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_format: Optional[Union[str, DocumentClassifierDataFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_type: Optional[Union[str, DocumentClassifierDocumentTypeFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    augmented_manifests: Optional[list[AugmentedManifestsListItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label_delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    test_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.document_reader_config is not None:
            if hasattr(self.document_reader_config, 'to_dict'):
                props['DocumentReaderConfig'] = self.document_reader_config.to_dict()
            elif isinstance(self.document_reader_config, list):
                props['DocumentReaderConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_reader_config
                ]
            else:
                props['DocumentReaderConfig'] = self.document_reader_config

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.documents is not None:
            if hasattr(self.documents, 'to_dict'):
                props['Documents'] = self.documents.to_dict()
            elif isinstance(self.documents, list):
                props['Documents'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.documents
                ]
            else:
                props['Documents'] = self.documents

        if self.data_format is not None:
            if hasattr(self.data_format, 'to_dict'):
                props['DataFormat'] = self.data_format.to_dict()
            elif isinstance(self.data_format, list):
                props['DataFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_format
                ]
            else:
                props['DataFormat'] = self.data_format

        if self.document_type is not None:
            if hasattr(self.document_type, 'to_dict'):
                props['DocumentType'] = self.document_type.to_dict()
            elif isinstance(self.document_type, list):
                props['DocumentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_type
                ]
            else:
                props['DocumentType'] = self.document_type

        if self.augmented_manifests is not None:
            if hasattr(self.augmented_manifests, 'to_dict'):
                props['AugmentedManifests'] = self.augmented_manifests.to_dict()
            elif isinstance(self.augmented_manifests, list):
                props['AugmentedManifests'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.augmented_manifests
                ]
            else:
                props['AugmentedManifests'] = self.augmented_manifests

        if self.label_delimiter is not None:
            if hasattr(self.label_delimiter, 'to_dict'):
                props['LabelDelimiter'] = self.label_delimiter.to_dict()
            elif isinstance(self.label_delimiter, list):
                props['LabelDelimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label_delimiter
                ]
            else:
                props['LabelDelimiter'] = self.label_delimiter

        if self.test_s3_uri is not None:
            if hasattr(self.test_s3_uri, 'to_dict'):
                props['TestS3Uri'] = self.test_s3_uri.to_dict()
            elif isinstance(self.test_s3_uri, list):
                props['TestS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.test_s3_uri
                ]
            else:
                props['TestS3Uri'] = self.test_s3_uri

        return props


@dataclass
class DocumentClassifierOutputDataConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class DocumentReaderConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_read_mode: Optional[Union[str, DocumentReadMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_read_action: Optional[Union[str, DocumentReadAction, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.feature_types is not None:
            if hasattr(self.feature_types, 'to_dict'):
                props['FeatureTypes'] = self.feature_types.to_dict()
            elif isinstance(self.feature_types, list):
                props['FeatureTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_types
                ]
            else:
                props['FeatureTypes'] = self.feature_types

        if self.document_read_mode is not None:
            if hasattr(self.document_read_mode, 'to_dict'):
                props['DocumentReadMode'] = self.document_read_mode.to_dict()
            elif isinstance(self.document_read_mode, list):
                props['DocumentReadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_read_mode
                ]
            else:
                props['DocumentReadMode'] = self.document_read_mode

        if self.document_read_action is not None:
            if hasattr(self.document_read_action, 'to_dict'):
                props['DocumentReadAction'] = self.document_read_action.to_dict()
            elif isinstance(self.document_read_action, list):
                props['DocumentReadAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_read_action
                ]
            else:
                props['DocumentReadAction'] = self.document_read_action

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class DocumentClassifier(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-compr"""

    resource_type: ClassVar[str] = "AWS::Comprehend::DocumentClassifier"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    language_code: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_access_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_data_config: Optional[DocumentClassifierOutputDataConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    document_classifier_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    input_data_config: Optional[DocumentClassifierInputDataConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.language_code is not None:
            # Serialize language_code (handle intrinsic functions)
            if hasattr(self.language_code, 'to_dict'):
                props["LanguageCode"] = self.language_code.to_dict()
            elif isinstance(self.language_code, list):
                # Serialize list items (may contain intrinsic functions)
                props['LanguageCode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.language_code
                ]
            else:
                props["LanguageCode"] = self.language_code

        if self.data_access_role_arn is not None:
            # Serialize data_access_role_arn (handle intrinsic functions)
            if hasattr(self.data_access_role_arn, 'to_dict'):
                props["DataAccessRoleArn"] = self.data_access_role_arn.to_dict()
            elif isinstance(self.data_access_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataAccessRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_access_role_arn
                ]
            else:
                props["DataAccessRoleArn"] = self.data_access_role_arn

        if self.output_data_config is not None:
            # Serialize output_data_config (handle intrinsic functions)
            if hasattr(self.output_data_config, 'to_dict'):
                props["OutputDataConfig"] = self.output_data_config.to_dict()
            elif isinstance(self.output_data_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputDataConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_data_config
                ]
            else:
                props["OutputDataConfig"] = self.output_data_config

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.document_classifier_name is not None:
            # Serialize document_classifier_name (handle intrinsic functions)
            if hasattr(self.document_classifier_name, 'to_dict'):
                props["DocumentClassifierName"] = self.document_classifier_name.to_dict()
            elif isinstance(self.document_classifier_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DocumentClassifierName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_classifier_name
                ]
            else:
                props["DocumentClassifierName"] = self.document_classifier_name

        if self.mode is not None:
            # Serialize mode (handle intrinsic functions)
            if hasattr(self.mode, 'to_dict'):
                props["Mode"] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props["Mode"] = self.mode

        if self.volume_kms_key_id is not None:
            # Serialize volume_kms_key_id (handle intrinsic functions)
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props["VolumeKmsKeyId"] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props["VolumeKmsKeyId"] = self.volume_kms_key_id

        if self.model_kms_key_id is not None:
            # Serialize model_kms_key_id (handle intrinsic functions)
            if hasattr(self.model_kms_key_id, 'to_dict'):
                props["ModelKmsKeyId"] = self.model_kms_key_id.to_dict()
            elif isinstance(self.model_kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_kms_key_id
                ]
            else:
                props["ModelKmsKeyId"] = self.model_kms_key_id

        if self.version_name is not None:
            # Serialize version_name (handle intrinsic functions)
            if hasattr(self.version_name, 'to_dict'):
                props["VersionName"] = self.version_name.to_dict()
            elif isinstance(self.version_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_name
                ]
            else:
                props["VersionName"] = self.version_name

        if self.model_policy is not None:
            # Serialize model_policy (handle intrinsic functions)
            if hasattr(self.model_policy, 'to_dict'):
                props["ModelPolicy"] = self.model_policy.to_dict()
            elif isinstance(self.model_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_policy
                ]
            else:
                props["ModelPolicy"] = self.model_policy

        if self.input_data_config is not None:
            # Serialize input_data_config (handle intrinsic functions)
            if hasattr(self.input_data_config, 'to_dict'):
                props["InputDataConfig"] = self.input_data_config.to_dict()
            elif isinstance(self.input_data_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['InputDataConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_data_config
                ]
            else:
                props["InputDataConfig"] = self.input_data_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class DataSecurityConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_lake_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.model_kms_key_id is not None:
            if hasattr(self.model_kms_key_id, 'to_dict'):
                props['ModelKmsKeyId'] = self.model_kms_key_id.to_dict()
            elif isinstance(self.model_kms_key_id, list):
                props['ModelKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_kms_key_id
                ]
            else:
                props['ModelKmsKeyId'] = self.model_kms_key_id

        if self.data_lake_kms_key_id is not None:
            if hasattr(self.data_lake_kms_key_id, 'to_dict'):
                props['DataLakeKmsKeyId'] = self.data_lake_kms_key_id.to_dict()
            elif isinstance(self.data_lake_kms_key_id, list):
                props['DataLakeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_lake_kms_key_id
                ]
            else:
                props['DataLakeKmsKeyId'] = self.data_lake_kms_key_id

        return props


@dataclass
class DocumentClassificationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, DocumentClassifierMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    labels: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.labels is not None:
            if hasattr(self.labels, 'to_dict'):
                props['Labels'] = self.labels.to_dict()
            elif isinstance(self.labels, list):
                props['Labels'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.labels
                ]
            else:
                props['Labels'] = self.labels

        return props


@dataclass
class EntityRecognitionConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entity_types: Optional[list[EntityTypesListItem]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entity_types is not None:
            if hasattr(self.entity_types, 'to_dict'):
                props['EntityTypes'] = self.entity_types.to_dict()
            elif isinstance(self.entity_types, list):
                props['EntityTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entity_types
                ]
            else:
                props['EntityTypes'] = self.entity_types

        return props


@dataclass
class EntityTypesListItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class TaskConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    language_code: Optional[Union[str, LanguageCode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_classification_config: Optional[DocumentClassificationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entity_recognition_config: Optional[EntityRecognitionConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.language_code is not None:
            if hasattr(self.language_code, 'to_dict'):
                props['LanguageCode'] = self.language_code.to_dict()
            elif isinstance(self.language_code, list):
                props['LanguageCode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.language_code
                ]
            else:
                props['LanguageCode'] = self.language_code

        if self.document_classification_config is not None:
            if hasattr(self.document_classification_config, 'to_dict'):
                props['DocumentClassificationConfig'] = self.document_classification_config.to_dict()
            elif isinstance(self.document_classification_config, list):
                props['DocumentClassificationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_classification_config
                ]
            else:
                props['DocumentClassificationConfig'] = self.document_classification_config

        if self.entity_recognition_config is not None:
            if hasattr(self.entity_recognition_config, 'to_dict'):
                props['EntityRecognitionConfig'] = self.entity_recognition_config.to_dict()
            elif isinstance(self.entity_recognition_config, list):
                props['EntityRecognitionConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entity_recognition_config
                ]
            else:
                props['EntityRecognitionConfig'] = self.entity_recognition_config

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-com"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Flywheel(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-compr"""

    resource_type: ClassVar[str] = "AWS::Comprehend::Flywheel"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_lake_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_access_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    flywheel_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task_config: Optional[TaskConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    active_model_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_security_config: Optional[DataSecurityConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_lake_s3_uri is not None:
            # Serialize data_lake_s3_uri (handle intrinsic functions)
            if hasattr(self.data_lake_s3_uri, 'to_dict'):
                props["DataLakeS3Uri"] = self.data_lake_s3_uri.to_dict()
            elif isinstance(self.data_lake_s3_uri, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataLakeS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_lake_s3_uri
                ]
            else:
                props["DataLakeS3Uri"] = self.data_lake_s3_uri

        if self.data_access_role_arn is not None:
            # Serialize data_access_role_arn (handle intrinsic functions)
            if hasattr(self.data_access_role_arn, 'to_dict'):
                props["DataAccessRoleArn"] = self.data_access_role_arn.to_dict()
            elif isinstance(self.data_access_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataAccessRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_access_role_arn
                ]
            else:
                props["DataAccessRoleArn"] = self.data_access_role_arn

        if self.flywheel_name is not None:
            # Serialize flywheel_name (handle intrinsic functions)
            if hasattr(self.flywheel_name, 'to_dict'):
                props["FlywheelName"] = self.flywheel_name.to_dict()
            elif isinstance(self.flywheel_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FlywheelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.flywheel_name
                ]
            else:
                props["FlywheelName"] = self.flywheel_name

        if self.model_type is not None:
            # Serialize model_type (handle intrinsic functions)
            if hasattr(self.model_type, 'to_dict'):
                props["ModelType"] = self.model_type.to_dict()
            elif isinstance(self.model_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_type
                ]
            else:
                props["ModelType"] = self.model_type

        if self.task_config is not None:
            # Serialize task_config (handle intrinsic functions)
            if hasattr(self.task_config, 'to_dict'):
                props["TaskConfig"] = self.task_config.to_dict()
            elif isinstance(self.task_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['TaskConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_config
                ]
            else:
                props["TaskConfig"] = self.task_config

        if self.active_model_arn is not None:
            # Serialize active_model_arn (handle intrinsic functions)
            if hasattr(self.active_model_arn, 'to_dict'):
                props["ActiveModelArn"] = self.active_model_arn.to_dict()
            elif isinstance(self.active_model_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ActiveModelArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active_model_arn
                ]
            else:
                props["ActiveModelArn"] = self.active_model_arn

        if self.data_security_config is not None:
            # Serialize data_security_config (handle intrinsic functions)
            if hasattr(self.data_security_config, 'to_dict'):
                props["DataSecurityConfig"] = self.data_security_config.to_dict()
            elif isinstance(self.data_security_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataSecurityConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_security_config
                ]
            else:
                props["DataSecurityConfig"] = self.data_security_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



