# -*- coding: utf-8 -*-
"""ITD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qfmbTEOX3I6doOlIs3Zn2Z5F57WH0M4O

# Importing Modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from scipy.signal import butter, filtfilt, detrend, decimate, correlate
import scipy
from scipy.signal import welch, csd, find_peaks
from scipy.linalg import svd


# !pip install plotly
import plotly.express as px

"""# Main Function (Whole Operation)"""

def ITD_alg(data, dt, order=0, criteria=[0.01,0.05,0.02],Num_poles_to_accept_a_mode=5):
    """
    This function receives data and perform Ibrahim Time Domain algorithm.

    :param data: A 2D Numpy array or PyTorch tensor Containing time history response of structure.
    :param dt: Time Resolution
    :param order: Maximum order of model
    :param criteria: Criteria for considering a pole stable (e.g. [error of frequency, error of damping ratio, error of mode shape]).
    :param Num_poles_to_accept_a_mode: Number of stable poles in a frequency line to assume that mode a physical mode
    :return:
        Information to draw stabilization diagram
        - A list of physical modes' frequencies
        - A list of physical modes' damping ratios
    """
    if isinstance(data, np.ndarray):
        data = torch.tensor(np.asarray(data).copy())
    if isinstance(data, pd.DataFrame):
        data = np.asarray(data)
        data = torch.tensor(np.asarray(data).copy())
    if data.shape[0] > data.shape[1]:
        data = torch.transpose(data, 0, 1)  ## y.shape = [number_of_sensors, number_of_timesteps]
    if Num_poles_to_accept_a_mode=='auto':
        if order == 0:
            Num_Poles = 1
        else:
            Num_Poles = int(order // 5)
    else:
        Num_Poles = Num_poles_to_accept_a_mode
    A = []
    if order != 0:
        for o in range(1,order):
            H_R_0, H_R_1 = calculate_correlation(data, n=o)
            A.append(H_R_1 @ np.linalg.pinv(H_R_0))
    else:
        H_R_0, H_R_1 = calculate_correlation(data)
        A.append(H_R_1 @ np.linalg.pinv(H_R_0))
    f, zeta, phi = modal_parameters(A,dt)
    Coord_dict, Modal_info = Stable_Poles_without_phi(f, zeta, criteria, Num_Poles=Num_Poles)
    Stable_frequencies, Stable_zetas = Modal_info.values()

    return Coord_dict, Stable_frequencies, Stable_zetas

"""# Correlation Function + Hankel"""

def calculate_correlation(y, n=0):
    y = np.array(y)
    l = y.shape[0]
    Nt = y.shape[1]
    if n == 0:
        n = int(Nt/2) - 1
    R = np.zeros((2*n, l, l))
    R[0,:,:] = 1/(y.shape[1]) * np.matmul(y, np.transpose(y))
    for i in range(1, 2*n):
        R[i,:,:] = 1/(y[:,i:].shape[1]) * np.matmul(y[:,i:], np.transpose(y[:,:-i]))

    H_R_0, H_R_1 = assemble_Hankel(R)
    return H_R_0, H_R_1

def assemble_Hankel(R):
    l = R.shape[1]
    n = int(R.shape[0]/2)
    H_R_0 = np.zeros((n*l, n*l))
    H_R_1 = np.zeros((n*l, n*l))
    for i in range(n):
        for j in range(n):
            H_R_0[i*l:(i+1)*l, j*l:(j+1)*l] = R[i+j,:,:]
            H_R_1[i*l:(i+1)*l, j*l:(j+1)*l] = R[i+j+1,:,:]

    return H_R_0, H_R_1

"""# Modal parameters"""

def modal_parameters(A,dt):
    f = []
    zeta = []
    Phi = []
    for i in range(len(A)):
        A_torch = torch.tensor(A[i])
        L, V = torch.linalg.eig(A_torch)
        Lambda = torch.log(L)/dt

        f.append(torch.abs(Lambda)/(2*torch.pi))
        f[i], f_idx = torch.sort(f[i])

        zeta.append(-torch.real(Lambda)/torch.abs(Lambda))
        zeta[i] = zeta[i][f_idx]


        Phi.append(V)
        Phi[i] = Phi[i][:,f_idx]

        # eliminate complex conjugate pairs
        if f[i].numel() == 0:
            continue
        f[i], f_counts = torch.unique_consecutive(f[i], return_counts=True)
        c1 = 0
        f_uq_idx = []
        for j in range(len(f_counts)):
            f_uq_idx.append(c1)
            c1 += int(f_counts[j])
        # print('f_uq_idx: ',f_uq_idx)
        zeta[i] = zeta[i][f_uq_idx]
        Phi[i] = Phi[i][:,f_uq_idx]
    return f, zeta, Phi

"""# Stable Poles"""

def Stable_Poles_without_phi(f, zeta, criteria, Num_Poles):
    # Criteria is a list of numbers which show the similarity criteria between two consecutive poles to assume them stable
    err_f = criteria[0]
    err_zeta = criteria[1]
    stable = []
    x_scatter_not_stable = []
    y_scatter_not_stable = []
    x_scatter_stable = []
    y_scatter_stable = []
    z_scatter_stable = []

    x_scatter_stable_noZeta = []
    y_scatter_stable_noZeta = []

    stable_frequencies_dict = {}
    stable_frequencies_dict_avg = {}
    stable_zetas_dict_avg = {}
    stable_frequencies = []
    stable_zetas = []
    for i in range(len(f)-1):
        f1 = f[i]
        f2 = f[i+1]
        zeta1 = zeta[i]
        zeta2 = zeta[i+1]

        stable.append(torch.zeros_like(f2))
        if f1.numel() == 0 or f2.numel() == 0:
            continue
        for j2 in range(len(f2)):
            j2_f = f2[j2]
            j2_z = zeta2[j2]
            for j1 in range(len(f1)):
                j1_f = f1[j1]
                j1_z = zeta1[j1]
                #################################################################################################
                ## For the cases all parameters are reliable
                #################################################################################################
                if torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f    and    torch.abs(j2_z-j1_z)/torch.abs(j1_z) < err_zeta  \
                  and   j2_z<0.2 and j2_z>0:
                    stable[i][j2] = 1
                    x_scatter_stable.append(j2_f)
                    y_scatter_stable.append(i+1)
                    z_scatter_stable.append(j2_z)
                    if stable_frequencies_dict == {}:
                        stable_frequencies_dict.update({j2_f:1})
                        stable_frequencies_dict_avg.update({j2_f:1})
                        stable_zetas_dict_avg.update({j2_f:j2_z})
                        # stable_phis_dict_avg.update({j2_f:j2_ph})
                        # stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                        is_same_freq = True
                    else:
                        stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                        for kk in stable_frequencies_dict.keys():
                            is_same_freq = False
                            if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                is_same_freq = True
                                kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                stable_zetas_dict_avg.pop(kk)
                                stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                stable_frequencies_dict_avg.pop(kk)
                                stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                break
                        if not is_same_freq:
                            # stable_phis_dict_avg.update({j2_f:j2_ph})
                            stable_zetas_dict_avg.update({j2_f:j2_z})
                            stable_frequencies_dict_avg.update({j2_f:1})

                    break  # The pole is stable no need to check more of j1
                #################################################################################################
                ## For the cases that damping ratios are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f and j2_z>0:
                    x_scatter_stable_noZeta.append(j2_f)
                    y_scatter_stable_noZeta.append(i+1)
            x_scatter_not_stable.append(j2_f)
            y_scatter_not_stable.append(i+1)
        stable[i] = list(map(bool, stable[i]))

    ###############################################################################################
    # A loop for adding stable poles with number more than a limit to a list as natural frequencies
    ###############################################################################################
    how_many_stable_poles = Num_Poles
    for kk in stable_frequencies_dict_avg.keys():
        if stable_frequencies_dict_avg[kk]>=how_many_stable_poles and kk not in stable_frequencies:
            stable_frequencies.append(kk)
            stable_zetas.append(stable_zetas_dict_avg[kk])

            ## Finding the stable pole having the nearest frequency to the mean frequency
            # diff_freq = np.asarray(stable_phis_dict[kk]['freq']) - np.asarray(kk)
            # min_diff_freq_idx = np.argmin(diff_freq)

    sorted_idx = np.argsort(np.array(stable_frequencies))
    stable_zetas_sorted_by_freq = []
    for i in sorted_idx:
        stable_zetas_sorted_by_freq.append(stable_zetas[i])


    # Mode_shapes = []
    # Mode_shapes_amp = []
    # Mode_shapes_phase = []
    # Mode_shapes_sign = []
    # for mode in range(len(stable_phis_sorted_by_freq)):
    #     Mode_shapes_phase.append(torch.angle(stable_phis_sorted_by_freq[mode]))
    #     Mode_shapes_amp.append(torch.abs(stable_phis_sorted_by_freq[mode]))
    #     Mode_shapes_sign.append(torch.sign(torch.cos(Mode_shapes_phase[mode]-Mode_shapes_phase[mode][0])))
    #     Mode_shapes.append(Mode_shapes_sign[mode]*Mode_shapes_amp[mode] / torch.max(Mode_shapes_amp[mode]))


    stable_frequencies.sort()
    return {'x_NS':x_scatter_not_stable, 'y_NS':y_scatter_not_stable, 'x_S':x_scatter_stable, 'y_S':y_scatter_stable, 'z_S':z_scatter_stable,
            'x_S_noZeta':x_scatter_stable_noZeta, 'y_S_noZeta':y_scatter_stable_noZeta}, \
            {'frequencies':stable_frequencies, 'damping_ratios':stable_zetas_sorted_by_freq}

"""# Stabilization Diagram"""

def fix_coord_dict(input_dict):
    # Dictionary with all possible keys
    all_keys = {'x_NS', 'y_NS', 'x_S', 'y_S', 'z_S', 'ph_stable',
                'x_S_noZeta', 'y_S_noZeta', 'ph_stable_noZeta',
                'x_S_noZeta_noPhi', 'y_S_noZeta_noPhi',
                'X_bound_cov', 'y_bound_cov', 'z_bound_cov',
                'X_bound_cov_stable_nozeta', 'y_bound_cov_stable_nozeta', 'z_bound_cov_stable_nozeta',
                'X_bound_cov_stable_nozeta_nophi', 'y_bound_cov_stable_nozeta_nophi', 'z_bound_cov_stable_nozeta_nophi',
                'X_bound_cov_notstable', 'y_bound_cov_notstable', 'z_bound_cov_notstable'}

    # Iterate over all possible keys and check if they're in the input dictionary
    copy_dict = input_dict.copy()
    for key in all_keys:
        if key not in input_dict:
            copy_dict[key] = []  # If key is missing, add it with an empty list

    return copy_dict

def stabilization_diagram(Coord_dict, Stable_frequencies, Stable_zetas, without_mode_shape=False, add_damping_indicator=False, xlim=0, ylim=0, scale_unc=1.,
                          damp_ylim=0, add_PSD_SVD=False, f_psd=[], ss1=[], show_second_singular_value=False, show_title=False, only_show_stable=False, draw_unc=False):
    """
        This function is a general function to plot stabilization diagram.

        :param Coord_dict: Information about poles (Output of methods like SSI, PolyMAX, and ITD)
        :param Stable_frequencies: A list of physical modes' frequencies
        :param Stable_zetas: A list of physical modes' damping ratios
        :param without_mode_shape: A bool value, if True the mode shapes are not considered (suitable for ITD and PolyMAX).
        :param add_damping_indicator: A bool value, if True some text indicator will be shown.
        :param xlim: A list of two numbers indicating the xlim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete xlim)
        :param ylim: A list of two numbers indicating the ylim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete ylim)
        :param damp_ylim: A list of two numbers indicating the ylim of the damping ratio plot. (e.g. [2,10]) (0 acts as the complete ylim)
        :param add_PSD_SVD: A bool value, if True first singular value diagram will be shown behind the stabilization diagram.
        :param f_psd: If add_PSD_SVD=True, a frequency domain's array must be provided.
        :param ss1: If add_PSD_SVD=True, an SVD of PSD array must be provided.
    """

    if 'x_S_noZeta_noPhi' not in Coord_dict.keys():
        without_mode_shape = True

    Coord_dict = fix_coord_dict(Coord_dict)

    if Coord_dict['X_bound_cov_notstable'] == [] and draw_unc:
        draw_unc = False
        print('There is no uncertainty information available!')


    
    if without_mode_shape:
        if not add_PSD_SVD:
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # ax1 = axis[0]
            # ax2 = axis[1]

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')
            
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim) 
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)

            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)
            # plt.show()

            # plt.subplot(2,1,2)
            fig_total, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)

            ax2.grid()
            # plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            scatt3 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('Singular values of PSD (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                # plt1_2.set_zorder(0.5)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(which='both')

            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3] ,framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))


            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)
            
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)

            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid(which='both')
            plt.show()
    else:
        if not add_PSD_SVD:
            # fig_total, axis = plt.subplots(2, 1, figsize=(10, 10))
            #
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)
            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()
            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)


            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)

            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            # ax2.grid()
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.grid(visible=True, axis='x')
            ax2.grid(visible=True, which='both', axis='y')
            plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                scatt3 = ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt3 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            scatt4 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')


            COV_TOL = 1e10
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc, Coord_dict['x_S'][i]-np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc]
                if Coord_dict['X_bound_cov'][i] < COV_TOL:
                    if draw_unc:
                        ax1.plot(x_plot_cov, y_plot_cov, color='tab:green')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta'][i], Coord_dict['y_bound_cov_stable_nozeta'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc, Coord_dict['x_S_noZeta'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:blue')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta_nophi'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta_nophi'][i], Coord_dict['y_bound_cov_stable_nozeta_nophi'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta_noPhi'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc, Coord_dict['x_S_noZeta_noPhi'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta_nophi'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:orange')

            # for i in range(len(Coord_dict['X_bound_cov_notstable'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_notstable'][i], Coord_dict['y_bound_cov_notstable'][i]]
            #     x_plot_cov = [Coord_dict['x_NS'][i]+np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc, Coord_dict['x_NS'][i]-np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_notstable'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:red')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()


            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3, scatt4], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid()
            # ax2.grid(visible=True,axis='x')
            # ax2.grid(visible=True,which='both',axis='y')
            plt.show()

"""# Mode Shape

## Usnig LSFD method (Independent method)
"""

def independent_mode_shape(freqs, damps, y, dt, nseg=2, pov=0.5, window='hann'):
    """
        This function if based on a method that uses frequencies and damping ratios to extract mode shapes.
        This method is used internally in PolyMAX and ITD, though here we provided an independent form.
        This independent function let the user find the mode shapes by simply having the frequencies and damping ratios.

        :param freqs: A list of physical modes' frequencies
        :param damps:A list of physical modes' damping ratios
        :param y: A 2D Numpy array containing the response of the structure
        :param dt: Time Resolution
        :param nseg: Number of segments in Welch's method
        :param pov: Percent of overlap
        :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
        :return: A list of mode shapes
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if isinstance(y, pd.DataFrame):
        y = np.asarray(y)
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)  ## y.shape = [number_of_sensors, number_of_timesteps]
    print('Calculating PSD...')
    Gyy, f_psd = psd_func(y, dt, nseg=nseg, pov=pov, window=window)  # One-sided
    lambda_list = []
    for i in range(len(freqs)):
        lambda_list.append(-2j*np.pi*freqs[i]*damps[i] + 2*np.pi*freqs[i]*np.sqrt(1-damps[i]**2))
    lambda_list = np.asarray(lambda_list)
    #######################################################################
    # Mode shape
    if lambda_list.size == 0:
        print('No mode found!')
        Stable_phis = 0
    else:
        print(f'Finding mode shapes ...')
        phis = finding_mode_shape(lambda_list, Gyy, f_psd)
    return phis

"""## PSD function"""

def psd_func(y, dt, nseg=2, pov=0.5,window='hann'):
    """
        A function to calculate the PSD of the signals.

        :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
        :param dt: Time Resolution
        :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
        :param nseg: Number of segments in Welch's method
        :param pov: Percent of overlap
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.

        :return:
            PSD Matrix
            - Frequency domain's array
            - Number of the time steps in each segment
            - Number of channels
            - Time domain's array
        """
    fs = 1/dt
    n_row, n_col = y.shape
    # print('n_col', n_col)
    # print('n_row', n_row)
    # if np.round(np.log2(n_col)) > np.floor(np.log2(n_col)):
    #     Num_points = 2**np.round(np.log2(n_col))
    #     y = np.concatenate( (y, np.zeros((y.shape[0], Num_points-y.shape[1])) ), axis=1)
    # else:
    #     Num_points = 2**int(np.floor(np.log2(n_col)))
    #     y = y[:,0:Num_points]

    Num_points = n_col

    T_MAX_new = Num_points*dt
    delta_f_new = 1/T_MAX_new
    nxseg = int(Num_points//nseg) # number of points in every segment

    noverlap = int(nxseg // (1/pov)) # Number of overlapping points
    PSD_Mat = np.zeros((nxseg//2+1, n_row, n_row), dtype=complex)

    for i in range(n_row):
        for j in range(n_row):
            f_psd ,PSD_Mat[:,i,j] = csd(y[i,:],y[j,:], fs=fs, window=window, nperseg=nxseg, noverlap=noverlap)
    # nyq_lim = int(PSD_Mat.shape[0])
    return torch.tensor(PSD_Mat, dtype=torch.complex64), torch.tensor(f_psd, dtype=torch.complex64)

"""### 4.4.3.2 pLSCF approach for extracting mode shape (Corrected)"""

def finding_mode_shape(lamb, Gyy, f_psd):
    """
    This function uses found physical modes to calculate mode shapes (as the second phase).

    :param lamb: An array of complex values of the physical modes.
    :param Gyy: The PSD matrix.
    :param f_psd: Frequency domain's array
    :return: A list of mode shapes
    """
    l = Gyy.shape[1]

    lamb = lamb.reshape(1,-1)
    lamb_conj = np.conjugate(lamb).copy()
    lamb = np.concatenate((lamb,lamb_conj),axis=0)

    lamb = lamb.T.copy()
    lamb = lamb.reshape(-1)

    # lamb = lambda_list[o]

    f_psd_Nf_1 = f_psd.reshape(1,-1)
    lamb_list_mul = lamb.reshape(-1,1)

    lamb_list_psd = 1/(1j*2*torch.pi*f_psd_Nf_1 - 1j*lamb_list_mul)

    # # print(f'f_psd shape: {f_psd_Nf_1.shape} = 1*Nf')
    # # print(f'lamb_list: {lamb_list_mul.shape} = n*1,  n = order*l*2')
    # # print(f'1/(omg-lamb): {lamb_list_psd.shape} = n*Nf')

    Lambda_mat = lamb_list_psd@lamb_list_psd.T
    Lambda_mat = torch.kron(Lambda_mat, torch.eye(l,dtype=torch.complex64))
    # print(Lambda_mat)
    # # print(f'Lambda_mat shape: {Lambda_mat.shape} = nl*nl')

    G_mat = torch.zeros((len(lamb)*l, l), dtype=torch.complex64)
    lambda_eye = torch.kron(lamb_list_psd, torch.eye(l,dtype=torch.complex64))

    Gyy_reshaped = Gyy.reshape(-1,l)
    G_mat = lambda_eye.clone().to(torch.complex64)@Gyy_reshaped.clone().to(torch.complex64)
    # print(G_mat)
    # print(f'Gyy: {Gyy_reshaped.shape}')
    # print(f'G_mat shape: {G_mat.shape}')


    # phi = torch.zeros((l, int(len(lamb)//2)), dtype=torch.complex64)
    phi = []
    # # R_mat = torch.inverse(Lambda_mat)@G_mat

    R_mat = torch.linalg.solve(Lambda_mat.clone().to(torch.complex64),G_mat)

    ##################################################################
    ##################################################################
    ##################################################################
    counter_mode_shape = 0
    for i in range(1,len(lamb),2):
        R_i = R_mat[i*l:(i+1)*l, :]
        U, _ , _ = torch.linalg.svd(R_i)
        u = U[:,0]
        # phi[:,counter_mode_shape] = u
        phi.append(np.asarray(u))
        counter_mode_shape += 1

    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []

    for i in range(len(phi)):
        UU_comb = phi[i]
        Mode_shapes_phase.append(np.angle(UU_comb))
        Mode_shapes_amp.append(np.abs(np.real(UU_comb)))
    for i in range(len(phi)):
        Mode_shapes_sign.append(np.sign(np.cos(Mode_shapes_phase[i]-Mode_shapes_phase[i][0])))
        Mode_shapes.append(Mode_shapes_sign[i]*Mode_shapes_amp[i] / np.max(Mode_shapes_amp[i]))
    return Mode_shapes