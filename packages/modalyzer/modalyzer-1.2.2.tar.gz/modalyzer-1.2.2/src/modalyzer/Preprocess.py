# -*- coding: utf-8 -*-
"""Preprocess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FXeyKVfdsYinKm38OuFgrwXEyTrpupX3

# Importing modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from scipy.signal import butter, filtfilt, detrend, decimate, correlate
import scipy
from scipy.signal import welch, csd, find_peaks
from scipy.linalg import svd


# !pip install plotly
import plotly.express as px
import plotly.graph_objects as go
import datetime

from matplotlib.ticker import FuncFormatter, LogLocator
import importlib

"""# Preprocess function"""


def preprocess(df, t, do_detrend=False, do_sync=False, time_limit=(0, 1), channels_to_remove=(), decimate_downsample=0, filter_lim=0, filter_order=1, cmap_range=0.95, xlim=0, show_exact_initial_form=False, exact_form_xlim=0):
    """
    A function for performing preprocessing on the signals.

    - :param df: Whole data as a Pandas DataFrame (a 2D matrix)
    - :param t: Time array (as a Numpy array)
    - :param do_detrend: If True, performs detrend on data.
    - :param do_sync: If True, synchronizes the channels.
    - :param time_limit: A list with two numbers between 0 and 1. Indicates the time percentage of data to use. (e.g. [0.2, 0.4]).
    - :param channels_to_remove: A list containing channel numbers to remove from the data.
    - :param decimate_downsample: Must be int, if not 0, it performs decimation on the data.
    - :param filter_lim: A list of two numbers containing lower and upper frequencies for a band-pass ButterWorth filter. If the first number is 0, the filter will be low-pass and if the second number is 0, the filter will be high-pass.
    - :param filter_order: The order of ButterWorth filter.
    - :param cmap_range: A number to change the color map range. If all the channels are approximately the same, then increase the cmap_range. If there is white color in the channels, decreas its value.
    - :return:
        - preprocessed_data: Preprocessed data, in format of a 2D numpy array.
        - preprocessed_time: New time array, corresponding to the preprocessed_data.
    """
    t = np.array(t)
    dt = t[1]-t[0]
    t = t - t[0] + dt

    if isinstance(df, np.ndarray):
        if df.shape[1] > df.shape[0]:
            df = df.transpose()
        df = pd.DataFrame(df)

    legend_is_shown_flag = False
    if len(df.shape) == 1:
        df = df.reshape(-1,1)
    vertical_distance = 0.8
    colors = plt.cm.gnuplot2(np.linspace(0, cmap_range, df.shape[1]))  # Using a colormap

    ## time_limit must be between [0,1]
    if time_limit[0] == 0:
        time_start = 0
    elif time_limit[0]<0 or time_limit[0]>1 or time_limit[0]>time_limit[1]:
        time_start = 0
    else:
        # time_start = np.where(t >= time_limit[0])[0]
        time_start = int(time_limit[0]*len(t))

    if time_limit[1] == 1:
        time_end = len(t)
    elif time_limit[1]<0 or time_limit[1]>1 or time_limit[0]>time_limit[1]:
        time_end = 1
        print('Time limit has some issues, the whole time frame is picked.')
    else:
        # time_end = np.where(t <= time_limit[1])[-1]
        time_end = int(time_limit[1]*len(t))


    #############################
    #############################
    #############################
    #############################
    

    if show_exact_initial_form:

        
        # if df.shape[0] > 20000/df.shape[1]/(exact_form_xlim[1]-exact_form_xlim[0]):
        #     step_for_good_resolution = int(df.shape[0] // (20000/df.shape[1]/(exact_form_xlim[1]-exact_form_xlim[0])))
        # else:
        step_for_good_resolution = 1
        initial_form_dict = {'time':t[::step_for_good_resolution]/np.max(t)}
        initial_form_dict.update({f'channel-{i}':df.iloc[::step_for_good_resolution,i] for i in range(df.shape[1])})
        initial_form_dict = pd.DataFrame(initial_form_dict)

        # fig = go.Figure(data=go.Scattergl(x=initial_form_dict['time'], 
        #                             y=initial_form_dict['channel-0'], 
        #                             mode='markers'))
        
        fig = px.line(initial_form_dict, x="time", y=initial_form_dict.columns[1:])
        if exact_form_xlim == 0:
            fig.update_layout(
                # xaxis_range=[xlim[0],xlim[1]],  # Set the desired x-axis range
                xaxis_title='Time (%)',
                yaxis_title=r'Acceleration (m/s^2)'
            )
        else:
            fig.update_layout(
                xaxis_range=[exact_form_xlim[0],exact_form_xlim[1]],  # Set the desired x-axis range
                xaxis_title='Time (%)',
                yaxis_title=r'Acceleration (m/s^2)'
            )

        fig.show()
        del initial_form_dict
    # Plotting Informations
    num_precesses = 0
    if time_end != len(t) or time_start != 0:
        num_precesses += 1
    if filter_lim != 0:
        num_precesses += 1
    if decimate_downsample != 0:
        num_precesses += 1
    if do_detrend:
        num_precesses += 1
    if do_sync:
        num_precesses += 1
    if channels_to_remove:
        num_precesses += 1
    if xlim != 0:
        num_precesses += 1


    fig, ax = plt.subplots(num_precesses+1,1,figsize=(20,3*num_precesses))
    plot_counter = 0
    plt.subplots_adjust(wspace=0, hspace=vertical_distance)

    if time_end != len(t) or time_start != 0:
        if not legend_is_shown_flag:
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df.iloc[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        #############################################
        t = t[time_start:time_end]
        df = df.iloc[time_start:time_end, :]
        #############################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t, df.iloc[:, i], label=f'Channel {i + 1}')
        ax[plot_counter].set_title('After cutting time')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1

    # Filling all nan value with zeros
    # df.fillna(method='ffill')
    df = np.asarray(df)
    # Filter (Butterworth)
    if filter_lim != 0:

        if not legend_is_shown_flag:
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        #############################################
        Fs = 1/dt
        Fnyq = Fs/2
        if isinstance(filter_lim, (list)):
            if filter_lim[1] == 0:
                Wn = filter_lim[0] / Fnyq
                filter_type = 'highpass'
            elif filter_lim[0] == 0:
                Wn = filter_lim[1] / Fnyq
                filter_type = 'lowpass'
            else:
                Wn = [filter_lim[0]/Fnyq, filter_lim[1]/Fnyq]
                filter_type = 'bandpass'
        else:
            print('The filter lim must be a list of two numbers.')
        b, a = butter(filter_order, Wn, filter_type)
        df = filtfilt(b, a, df, axis=0)
        #############################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After filtering')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1
        # plt.show()


    # Detrend the data
    if do_detrend:

        if not legend_is_shown_flag:
            # fig, ax = plt.subplots(2,1,figsize=(20,8))
            # plt.subplots_adjust(wspace=0, hspace=vertical_distance)
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        ########################
        df = detrend(df, axis=0)
        ########################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After detrending')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1
        # plt.show()

    # Decimate
    if decimate_downsample != 0:
        if not legend_is_shown_flag:
            # fig, ax = plt.subplots(2,1,figsize=(20,8))
            # plt.subplots_adjust(wspace=0, hspace=vertical_distance)
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        ################################################
        df = decimate(df, decimate_downsample, axis = 0)
        t = np.linspace(t[0],t[-1],df.shape[0])
        ################################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After decimation')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1
        # plt.show()

    if channels_to_remove:
        if not legend_is_shown_flag:
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        ##########################################################
        for i in channels_to_remove:
            df[:,i-1] = np.zeros(df.shape[0])
        # df = df[np.abs(df).sum(axis=1) != 0]
        column_sums = df.sum(axis=0)

        df = df[:, column_sums != 0]

        # df = df_filtered.reshape(df_filtered.shape[0], -1)
        # df = df[:, df.sum(dim=0) != 0].reshape(df.shape[0], -1)
        ##########################################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After removing channels')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1


    if xlim != 0:
        if not legend_is_shown_flag:
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        ##########################################################
        ##########################################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After xlim')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_xlim([xlim[0], xlim[1]])
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1

    # df_cleaned = df.copy()
    ## Synchronization
    if do_sync:

        if not legend_is_shown_flag:
            # fig, ax = plt.subplots(2,1,figsize=(20,8))
            # plt.subplots_adjust(wspace=0, hspace=vertical_distance)
            ax[plot_counter].grid()
            ax[plot_counter].set_prop_cycle(color=colors)
            for i in range(df.shape[1]):
                ax[plot_counter].plot(t, df[:, i], label=f'Channel {i + 1}')
            ax[plot_counter].set_title('Initial form')
            ax[plot_counter].set_xlabel('Time (s)')
            ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')

            ax[plot_counter].legend(ncol=2,loc='upper left', bbox_to_anchor=(1, 1), title='Legend')
            # Adjust layout to make room for the legend
            plt.subplots_adjust(right=0.75)
            legend_is_shown_flag = True
            plot_counter += 1
        ##########################################################
        # Keeping only first 25% of the frequency range for synchronization
        Wn = 1/5
        filter_type = 'lowpass'
        b, a = butter(4, Wn, filter_type)
        df_lowpass = filtfilt(b, a, df, axis=0)

        # cor = np.zeros((df_cleaned.shape[1], df_cleaned.shape[1], df_cleaned.shape[0]))
        cor_max_idx = np.zeros((df_lowpass.shape[1], df_lowpass.shape[1]))
        col_max = np.zeros(df_lowpass.shape[1])
        row_max = np.zeros(df_lowpass.shape[1])
        for i in range(df_lowpass.shape[1]):
            for j in range(df_lowpass.shape[1]):
                temp_cor = np.abs(correlate(df_lowpass[:,i], df_lowpass[:,j], mode='full', method='direct')[int(df_lowpass.shape[0])-1:])
                cor_max_idx[i, j] = np.argmax(temp_cor)
            row_max[i] = np.max(cor_max_idx[i, :])
        for j in range(df_lowpass.shape[1]):
            col_max[j] = np.max(cor_max_idx[:, j])

        # row_or_col = np.argmin((np.min(row_max), np.min(col_max)))
        row_or_col = 0
        min_idx = (np.argmin(row_max), np.argmin(col_max))[row_or_col]
        if row_or_col == 0:
            best_comb = cor_max_idx[min_idx, :]
        else:
            best_comb = cor_max_idx[:, min_idx]
        max_best_comb = np.max(best_comb)
        df_sync = np.zeros((int(df_lowpass.shape[0] - max_best_comb), df_lowpass.shape[1]))
        for i in range(df_lowpass.shape[1]):
            if best_comb[i] == 0:
                df_sync[:, i] = df[int(max_best_comb):, i]
            else:
                df_sync[:, i] = df[int(max_best_comb - best_comb[i]): int(-best_comb[i]), i]

        df = np.array(df_sync)
        t = t[:int(-max_best_comb)]
        ##########################################################
        ax[plot_counter].grid()
        ax[plot_counter].set_prop_cycle(color=colors)
        for i in range(df.shape[1]):
            ax[plot_counter].plot(t,df[:,i], label=f'Channel {i+1}')
        ax[plot_counter].set_title('After synchronizing')
        ax[plot_counter].set_xlabel('Time (s)')
        ax[plot_counter].set_ylabel(r'Acceleration $(m/s^2)$')
        plot_counter += 1
        # plt.show()

    if channels_to_remove:
        zero_row = np.zeros((df.shape[0],))

        for index in sorted(channels_to_remove):
            df = np.insert(df, index-1, zero_row, axis=1)

    # if isinstance(data, np.ndarray):
    #     data = torch.tensor(np.asarray(data).copy())
    # if isinstance(data, pd.DataFrame):
    #     data = np.asarray(data)
    #     data = torch.tensor(np.asarray(data).copy())
    # if data.shape[0] > data.shape[1]:
    #     data = torch.transpose(data, 0,1) ## y.shape = [number_of_sensors, number_of_timesteps]

    plt.show()
    return df, t

"""# Table of results"""

def results_table(frequencies, damping_ratios):
    """
    This function will show a Pandas DataFrame containing frequencies and damping ratios

    :param frequencies: A list of physical modes' frequencies
    :param damping_ratios: A list of physical modes' damping ratios
    """
    result_df = {'Frequencies':map(float,frequencies), 'Damping Ratios':map(float,damping_ratios)}
    result = pd.DataFrame(result_df)
    return result

"""# Choosing modes to show"""

def choose_modes(frequencies,zetas,phis=0, mode_numbers=[]):
    """

    :param frequencies: A list of physical modes' frequencies
    :param zetas: A list of physical modes' damping ratios
    :param phis: A list of physical modes' mode shapes
    :param mode_numbers: a list of desired modes to extract (e.g. [0,2,3])
    :return:
        freqs_to_show : A list of chosen physical modes' frequencies
        - damps_to_show: A list of chosen physical modes' damping ratios
        - Mode_shapes_to_show: A list of chosen physical modes' mode shapes
    """
    if mode_numbers == []:
        mode_numbers = range(len(frequencies))
    freqs_to_show = []
    damps_to_show = []
    Mode_shapes_to_show = []
    if phis != 0:
        for i in mode_numbers:
            freqs_to_show.append(frequencies[i])
            damps_to_show.append(zetas[i])
            Mode_shapes_to_show.append(phis[i])
    else:
        for i in mode_numbers:
            freqs_to_show.append(frequencies[i])
            damps_to_show.append(zetas[i])
    return freqs_to_show, damps_to_show, Mode_shapes_to_show