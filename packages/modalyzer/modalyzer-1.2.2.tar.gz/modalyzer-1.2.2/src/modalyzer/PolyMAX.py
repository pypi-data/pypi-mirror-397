# -*- coding: utf-8 -*-
"""PolyMAX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W2nWlHg_VNByDcbAAT8bTuTm8JHGw4nn

# Importing Modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from scipy.signal import butter, filtfilt
import scipy
from scipy.signal import welch, csd
from scipy.linalg import svd

# !pip install plotly
import plotly.express as px

"""# Whole Operation"""


def PolyMAX(y, dt, order, criteria=(0.01, 0.05, 0.1), basis_order=1, nseg=2, pov=0.5, window='hann', positve_psd=True, real_RST=True, real_M=True,
            Num_poles_to_accept_a_mode=5, mode_shape_based_on_all_found_modes=False, no_mode_shape_stability=True):
    """
    This function performs PolyMAX algorithm on the response of structure.

    :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
    :param dt: Time Resolution
    :param order: Maximum polynomial order for the PolyMAX method.
    :param criteria: Criteria for considering a pole stable (e.g. [error of frequency, error of damping ratio, error of mode shape]).
    :param basis_order: (+1 or -1). It indicates the basis order of the polynomial.
    :param nseg: Number of segments in Welch's method
    :param pov: Percent of overlap
    :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
    :param Num_poles_to_accept_a_mode: Number of found stable modes in a frequency line to consider a mode physical.
    :param positve_psd: If True, it converts one-sided psd to positive psd.
    :param mode_shape_based_on_all_found_modes: If True, all mode shapes will be extracted based on all found modes (Default False).
    :param no_mode_shape_stability: If True, mode shapes will not be considered for assessing stability.
    :param real_RST: If True, the imaginary part of matrices R, S, and T will be discarded.
    :param real_M: If True, the imaginary part of matrix M will be discarded.
    :return:
        - Coord_dict: Information about poles (Output of methods like SSI, PolyMAX, and ITD)
        - Stable_frequencies: A list of physical modes' frequencies
        - Stable_zetas: A list of physical modes' damping ratios
        - Stable_phis: A list of physical modes' mode shapes


    """


    companion_matrix_form=2

    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if isinstance(y, pd.DataFrame):
        y = np.asarray(y)
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)  ## y.shape = [number_of_sensors, number_of_timesteps]
    y = y[y.sum(dim=1) != 0, :].reshape(-1, y.shape[1])

    # Num_Poles = int(order//5)
    # Num_Poles = int(order // Num_poles_to_accept_a_mode)
    Num_Poles = Num_poles_to_accept_a_mode
    Gyy, f_psd = psd_func_PolyMAX(y, dt, nseg=nseg, pov=pov, window=window)  # Positive or One-sided
    Gyy_one_sided = Gyy.clone()
    if positve_psd:
        new_Gyy = torch.zeros_like(Gyy, dtype=torch.complex64)
        for i in range(Gyy.shape[0]):
            complex_matrix = Gyy[i]
            new_Gyy[i] = 0.5*(complex_matrix - complex_matrix.conj().T) + torch.diag(torch.diag(Gyy[i]))
            new_Gyy[i] = new_Gyy[i].clone().conj()

        Gyy = new_Gyy.clone()
        del new_Gyy
    A = []
    C = []
    z_precalculated = precalc_z(f_psd, order, dt, basis_order)
    Upsilon_precalculated = precalc_Upsilon(Gyy, z_precalculated, order, f_psd)
    for o in range(1, order):

        R, S, T = R_S_T_calc(z_precalculated[:, :o + 1].repeat(Gyy.shape[1], 1, 1),
                             Upsilon_precalculated[:, :, :(o + 1) * Gyy.shape[1]], real_RST=real_RST)

        print(f'Calculating M matrix for order: {o} ...')
        A_temp, C_temp = M_calc(R, S, T, basis_order,real_M=real_M, companion_matrix_form=companion_matrix_form)
        A.append(A_temp)
        C.append(C_temp)

    ###### Using aaproach in 4.9
    print(f'Calculating modal parameters ...')

    f, zeta, phi = modal_parameters(A, C, dt)
    print(f'Finding stable poles ...')

    if no_mode_shape_stability:
        Coord_dict, Modal_info = Stable_Poles_without_phi(f, zeta, criteria, Num_Poles=Num_Poles)
        Stable_frequencies, Stable_zetas = Modal_info.values()
        lambda_list = []
        for i in range(len(Stable_frequencies)):
            lambda_list.append(-2j*np.pi*Stable_frequencies[i]*Stable_zetas[i] + 2*np.pi*Stable_frequencies[i]*np.sqrt(1-Stable_zetas[i]**2))
        lambda_list = np.asarray(lambda_list)
        #######################################################################
        # Mode shape

        if lambda_list.size == 0:
            print('No Mode Found!')
            Stable_phis = 0
        elif mode_shape_based_on_all_found_modes:
            print(f'Finding Mode Shapes ...')
            Stable_phis = finding_mode_shape(lambda_list, Gyy_one_sided, f_psd)
        else:
            Stable_phis = 0
    
    else:
        Coord_dict, Modal_info = Stable_Poles(f, zeta, phi, criteria, Num_Poles=Num_Poles)
        Stable_frequencies, Stable_zetas, Stable_phis = Modal_info.values()

    return Coord_dict, Stable_frequencies, Stable_zetas, Stable_phis

"""## 1. PSD"""

def psd_func_PolyMAX(y, dt, nseg=2, pov=0.5,window='hann'):
    """
        A function to calculate the PSD of the signals.

        :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
        :param dt: Time Resolution
        :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
        :param nseg: Number of segments in Welch's method
        :param pov: Percent of overlap
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.

        :return:
            PSD Matrix
            - Frequency domain's array
            - Number of the time steps in each segment
            - Number of channels
            - Time domain's array
    """

    if y.shape[0] > y.shape[1]:
        y = np.transposes(y)


    fs = 1/dt
    n_row, n_col = y.shape
    # print('n_col', n_col)
    # print('n_row', n_row)
    # if np.round(np.log2(n_col)) > np.floor(np.log2(n_col)):
    #     Num_points = 2**np.round(np.log2(n_col))
    #     y = np.concatenate( (y, np.zeros((y.shape[0], Num_points-y.shape[1])) ), axis=1)
    # else:
    #     Num_points = 2**int(np.floor(np.log2(n_col)))
    #     y = y[:,0:Num_points]

    Num_points = n_col

    T_MAX_new = Num_points*dt
    delta_f_new = 1/T_MAX_new
    nxseg = int(Num_points//nseg) # number of points in every segment

    noverlap = int(nxseg // (1/pov)) # Number of overlapping points
    PSD_Mat = np.zeros((nxseg//2+1, n_row, n_row), dtype=complex)

    for i in range(n_row):
        for j in range(n_row):
            f_psd ,PSD_Mat[:,i,j] = csd(y[i,:],y[j,:], fs=fs, window=window, nperseg=nxseg, noverlap=noverlap)
    # nyq_lim = int(PSD_Mat.shape[0])
    return torch.tensor(PSD_Mat, dtype=torch.complex64), torch.tensor(f_psd, dtype=torch.complex64)


def psd_func(y, dt, nseg=2, pov=0.5, window='hann', show_semilog=False, show_plot=True):
    """
        A function to calculate the PSD of the signals.

        :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
        :param dt: Time Resolution
        :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
        :param nseg: Number of segments in Welch's method
        :param pov: Percent of overlap
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.

        :return:
            PSD Matrix
            - Frequency domain's array
            - Number of the time steps in each segment
            - Number of channels
            - Time domain's array
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)

    fs = 1 / dt
    n_row, n_col = y.shape

    Num_points = 2 ** int(np.ceil(np.log2(n_col)))
    y = np.concatenate((y, np.zeros((y.shape[0], Num_points - y.shape[1]))), axis=1)

    T_MAX_new = Num_points * dt
    delta_f_new = 1 / T_MAX_new
    nxseg = int(Num_points // nseg)  # number of points in every segment

    noverlap = int(nxseg // (1 / pov))  # Number of overlapping points
    PSD_Mat = np.zeros((nxseg // 2 + 1, n_row, n_row), dtype=complex)

    for i in range(n_row):
        for j in range(n_row):
            f_psd, PSD_Mat[:, i, j] = csd(y[i, :], y[j, :], fs=fs, window=window, nperseg=nxseg, noverlap=noverlap)

    if show_plot:

        fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

        fig_total.suptitle('Power Spectral Density')

        ax1 = axis[0]
        ax2 = axis[1]

        for i in range(n_row):
            ax1.plot(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
        ax1.set_title(f'PSD')
        # ax1.legend()
        ax1.grid()
        ax1.set_xlabel('Frequency(Hz)')
        ax1.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')

        # plt.figure(figsize=(10, 6))

        if not show_semilog:
            for i in range(n_row):
                ax2.plot(f_psd.real, 10 * np.log10(PSD_Mat[:, i, i].real).real, label=f'channel{i + 1}')
            # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.set_title(r'$10\log$(PSD)')
            # ax2.legend()
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('log(Power Spectral Density) (dB)')

        else:
            for i in range(n_row):
                ax2.semilogy(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.set_title(r'PSD')
            # ax2.legend()
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')
        plt.show()

    return torch.tensor(PSD_Mat, dtype=torch.complex64), torch.tensor(f_psd, dtype=torch.complex64)


"""## Singular value decomposition of PSD"""

def svd_psd(PSD_mat, f_psd, show_semilog=False, show_plot=True):
    """
        A function to calculate the SVD of PSD.

        :param PSD_mat: A 3D PyTorch tensor (PSD Matrix) (Output of psd_func function)
        :param f_psd: A 1D PyTorch tensor (Frequency domain's array) (Output of psd_func function)
        :param nxseg: Number of the time steps in each segment (Output of psd_func function)
        :param num_chnl: Number of channels (Output of psd_func function)
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.
        :return:
            ss1: Singular Values
            - UU: Singular Vectors
    """
    nxseg = PSD_mat.shape[0]
    num_chnl = PSD_mat.shape[1]

    ss1 = np.zeros((PSD_mat.shape[0], num_chnl))
    UU = np.zeros((num_chnl, num_chnl, PSD_mat.shape[0]), dtype=complex)
    for kk in range(PSD_mat.shape[0]):
        UU1, SS1, _ = np.linalg.svd(PSD_mat[kk])
        ss1[kk, :] = abs(SS1)
        UU[:, :, kk] = UU1[:, :]

    if show_plot:

        fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

        ax1 = axis[0]
        ax2 = axis[1]

        fig_total.suptitle('First three singular values of PSD')
        if ss1.shape[1] >= 3:
            num_singular_val = 3
        else:
            num_singular_val = ss1.shape[1]

        for i in range(num_singular_val):
            ax1.plot(f_psd.real, ss1[:, i].real, label=f'singular value number {i + 1}')
        ax1.grid()
        ax1.legend(framealpha=0.9)
        ax1.set_title(f'SVD(PSD)')
        ax1.set_xlabel('Frequency(Hz)')
        ax1.set_ylabel(r'SVD of Power Spectral Density ($m^2/s^3$)')

        if show_semilog:
            for i in range(num_singular_val):
                ax2.semilogy(f_psd.real, ss1[:, i].real, label=f'singular value number {i + 1}')
                # ax2.plot(f_psd, 10*np.log10(ss1[:,i]), label=f'singular value number {i+1}')
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.legend(framealpha=0.9)
            ax2.set_title(r'SVD(PSD)')

            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('SVD of Power Spectral Density ($m^2/s^3$)')
        else:
            for i in range(num_singular_val):
                ax2.plot(f_psd.real, 10 * np.log10(ss1[:, i].real).real, label=f'singular value number {i + 1}')
            # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.legend(framealpha=0.9)
            ax2.set_title(r'SVD(PSD)')

            ax2.set_title(r'$10\log$(SVD(PSD))')
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('log(SVD of Power Spectral Density) (dB)')
        plt.show()

    return ss1, UU


def omit_first_singular_value(PSD_mat):
    pass
    new_PSD = torch.zeros(PSD_mat.shape, dtype=torch.complex64)
    for kk in range(PSD_mat.shape[0]):
        UU1, SS1, _ = torch.linalg.svd(PSD_mat[kk])
        S_omitted = SS1.clone()
        S_omitted[0] = 0
        new_PSD[kk] = UU1 @ np.diag(S_omitted) @ UU1.H
    return new_PSD




"""## 2. [Γ] & [Υ]

### Precalculating z's for Gamma matrix
"""

def precalc_z(f_psd, order, dt, basis_order, highlighted_frequency_range=[], highlighted_frequency_list=[], weight_frequency_list=10):
    z_precalculated = torch.zeros((len(f_psd), order+1), dtype=torch.complex64)
    w = torch.ones(len(f_psd))
    df = float(f_psd[1] - f_psd[0])
    if len(highlighted_frequency_list) > 0:
        for i in range(len(highlighted_frequency_list)):
            w_idx0 = int(highlighted_frequency_list[i] * 0.95 // df)
            w_idx1 = int(highlighted_frequency_list[i] * 1.05 // df)
            w[w_idx0:w_idx1] = torch.ones(int(w_idx1 - w_idx0)) * weight_frequency_list
    if len(highlighted_frequency_range) == 2:

        w_idx0 = int(highlighted_frequency_range[0] // df)
        w_idx1 = int(highlighted_frequency_range[1] // df)
        w[w_idx0:w_idx1] = torch.ones(int(w_idx1-w_idx0))*5.0
    if len(highlighted_frequency_range) == 3:
        df = float(f_psd[1] - f_psd[0])
        w_idx0 = int(highlighted_frequency_range[0] // df)
        w_idx1 = int(highlighted_frequency_range[1] // df)
        w[w_idx0:w_idx1] = torch.ones(int(w_idx1-w_idx0))*highlighted_frequency_range[2]
    for row in range(len(f_psd)):
        for col in range(order+1):
            z_precalculated[row,col] = w[row]*torch.exp(basis_order*1j*2*torch.pi*f_psd[row]*dt*col)

    return z_precalculated

def precalc_Upsilon(Gyy, z_precalculated, order, f_psd):
    l = Gyy.shape[1]
    Upsilon_precalculated = torch.zeros((l, len(f_psd), (order+1)*l), dtype=torch.complex64)

    for o in range(l):
        for row in range(len(f_psd)):
            Upsilon_precalculated[o,row,:] = torch.kron(-z_precalculated[row,:],Gyy[row,:,o])
    return Upsilon_precalculated

"""## 3. [R] & [S] & [T]"""

def R_S_T_calc(Gamma, Upsilon, real_RST=False):
    l = Gamma.shape[0]
    order = Gamma.shape[2]-1
    R = torch.zeros((l, order+1, order+1), dtype=torch.complex64)
    S = torch.zeros((l, order+1, l*(order+1)), dtype=torch.complex64)
    T = torch.zeros((l, l*(order+1), l*(order+1)), dtype=torch.complex64)
    for o in range(l):
        if real_RST:
            R[o] = torch.real(Gamma[o,:,:].conj().T@Gamma[o,:,:])
            S[o] = torch.real(Gamma[o,:,:].conj().T@Upsilon[o,:,:])
            T[o] = torch.real(Upsilon[o,:,:].conj().T@Upsilon[o,:,:])
        else:
            R[o] = Gamma[o,:,:].conj().T@Gamma[o,:,:]
            S[o] = Gamma[o,:,:].conj().T@Upsilon[o,:,:]
            T[o] = Upsilon[o,:,:].conj().T@Upsilon[o,:,:]
    return R, S, T

"""## 4. [M] and then [A] and [C]"""


def M_calc(R, S, T, basis_order, real_M=True, companion_matrix_form=2, use_cvxpy=False, use_pinv=True, use_lstsq=False):
    M = torch.zeros((T.shape[1:]), dtype=torch.complex64)
    o = R.shape[1] - 1  # o = order
    l = T.shape[0]
    # print(T.shape[0])
    # print(T[0].shape)
    beta = torch.zeros((l, (o + 1), l), dtype=torch.complex64)
    for l_i in range(l):
        M = M + T[l_i] - (S[l_i].conj().T @ torch.linalg.solve(R[l_i], S[l_i]))

    if real_M:
        M = torch.real(M).to(torch.complex64)

    if basis_order == 1:
        M_A = M[:o * l, :o * l]
        M_I = M[:o * l, o * l:]

        # M_A = M[:, :o * l]
        # M_I = M[:, o * l:]

        if use_cvxpy:
            import cvxpy as cp
            A_opt = cp.Variable((o * l, l))

            objective = cp.Minimize(cp.norm(M_A @ A_opt + M_I, 'fro'))

            prob = cp.Problem(objective)
            prob.solve()
            print("Status:", prob.status)
            a_A = A_opt.value
            try:
                if a_A == None:
                    a_A = torch.linalg.pinv(M_A) @ (-M_I)
            except:
                a_A = torch.tensor(a_A, dtype=torch.complex64)
        else:
            if use_pinv:
                a_A = torch.linalg.pinv(M_A) @ (-M_I)
            elif use_lstsq:
                a_A = torch.linalg.lstsq(-M_A, M_I)[0]
            else:
                a_A = torch.linalg.inv(M_A) @ (-M_I)

        # W = torch.eye(l*o, dtype=torch.complex64)
        # a_A =  torch.linalg.pinv(W @ M_A) @ W @ (-M_I)

        alpha = torch.cat((a_A, torch.eye(l, dtype=torch.complex64)), axis=0)
        for l_i in range(l):
            beta[l_i] = torch.linalg.solve(-R[l_i], S[l_i]) @ alpha
        A_i = alpha.reshape(-1, l, l)
        if companion_matrix_form == 1:
            A1 = torch.zeros((o * l, l), dtype=torch.complex64)
            for i in range(o):
                # A1[i*l:(i+1)*l, :] = torch.linalg.solve(-A_i[0], A_i[i+1])
                try:
                    A1[i * l:(i + 1) * l, :] = torch.linalg.solve(-A_i[0], A_i[o - i])
                except:
                    A1[i * l:(i + 1) * l, :] = torch.linalg.pinv(-A_i[0]) @ A_i[o - i]

            A2 = torch.cat(
                (torch.zeros((l, (o - 1) * l), dtype=torch.complex64), torch.eye((o - 1) * l, dtype=torch.complex64)),
                axis=0)
            A = torch.cat((A2, A1), axis=1)
        elif companion_matrix_form == 2:
            A1 = torch.zeros((l, o * l), dtype=torch.complex64)
            for i in range(o):
                try:
                    A1[:, i * l:(i + 1) * l] = torch.linalg.solve(-A_i[0], A_i[i + 1])
                except:
                    A1[:, i * l:(i + 1) * l] = torch.linalg.pinv(-A_i[0]) @ A_i[i + 1]
                # try:
                #     A1[:, i * l:(i + 1) * l] = torch.linalg.solve(-A_i[0], A_i[o - i])
                # except:
                #     A1[:, i * l:(i + 1) * l] = torch.linalg.pinv(-A_i[0]) @ A_i[o - i]

            A2 = torch.cat(
                (torch.eye((o - 1) * l, dtype=torch.complex64), torch.zeros(((o - 1) * l, l), dtype=torch.complex64)),
                axis=1)
            A = torch.cat((A1, A2), axis=0)
        # A = A.T
        # B_i = torch.swapaxes(beta.clone(),0,1)
        beta = beta.reshape(-1, l)
        B_i = torch.zeros((o + 1, l, l), dtype=torch.complex64)

        for bi in range(o + 1):
            B_i[i] = beta[bi::o + 1]
        # print(B_i)
        # print(B_i2)
        # are_same = torch.all(torch.eq(B_i, B_i2)).item()
        # print(are_same)
        C = torch.zeros((l, o * l), dtype=torch.complex64)

        try:
            B_A_o = B_i[0] @ A_i[0].inverse()
        except:
            B_A_o = B_i[0] @ torch.linalg.pinv(A_i[0])
        for i in range(o):
            C[:, i * l:(i + 1) * l] = B_i[o - i] - B_A_o @ A_i[o - i]


    elif basis_order == -1:
        # W = torch.eye(l*(o+1), dtype=torch.complex64)
        M_A = M[l:, l:]
        M_I = M[l:, :l]

        # M_A = M[:, l:]
        # M_I = M[:, :l]

        if use_cvxpy:
            import cvxpy as cp
            A_opt = cp.Variable((o * l, l))

            objective = cp.Minimize(cp.norm(M_A @ A_opt + M_I, 'fro'))

            prob = cp.Problem(objective)
            prob.solve()
            print("Status:", prob.status)
            a_A = A_opt.value
            try:
                if a_A == None:
                    a_A = torch.linalg.pinv(M_A) @ (-M_I)
            except:
                a_A = torch.tensor(a_A, dtype=torch.complex64)
        else:
            if use_pinv:
                a_A = torch.linalg.pinv(M_A) @ (-M_I)
            elif use_lstsq:
                a_A = torch.linalg.lstsq(-M_A, M_I)[0]
            else:
                a_A = torch.linalg.inv(M_A) @ (-M_I)

        alpha = torch.cat((torch.eye(l, dtype=torch.complex64), a_A), axis=0)
        for l_i in range(l):
            beta[l_i] = torch.linalg.solve(-R[l_i], S[l_i]) @ alpha
        A_i = alpha.reshape(-1, l, l)
        if companion_matrix_form == 1:

            A1 = torch.zeros((o * l, l), dtype=torch.complex64)
            for i in range(o):
                try:
                    A1[i * l:(i + 1) * l, :] = torch.linalg.solve(-A_i[o], A_i[i])
                except:
                    A1[i * l:(i + 1) * l, :] = torch.linalg.pinv(-A_i[o]) @ A_i[i]
                # A1[i*l:(i+1)*l, :] = torch.linalg.solve(-A_i[o], A_i[o-i-1])

            A2 = torch.cat(
                (torch.zeros((l, (o - 1) * l), dtype=torch.complex64), torch.eye((o - 1) * l, dtype=torch.complex64)),
                axis=0)
            A = torch.cat((A2, A1), axis=1)
        elif companion_matrix_form == 2:
            A1 = torch.zeros((l, o * l), dtype=torch.complex64)
            for i in range(o):
                # try:
                #     A1[:, i * l:(i + 1) * l] = torch.linalg.solve(-A_i[o], A_i[i])
                # except:
                #     A1[:, i * l:(i + 1) * l] = torch.linalg.pinv(-A_i[o]) @ A_i[i]
                try:
                    A1[:, i * l:(i + 1) * l] = torch.linalg.solve(-A_i[o], A_i[o - i - 1])
                except:
                    A1[:, i * l:(i + 1) * l] = torch.linalg.pinv(-A_i[o]) @ A_i[o - i - 1]
            A2 = torch.cat(
                (torch.eye((o - 1) * l, dtype=torch.complex64), torch.zeros(((o - 1) * l, l), dtype=torch.complex64)),
                axis=1)
            A = torch.cat((A1, A2), axis=0)

        B_i = torch.swapaxes(beta.clone(), 0, 1)
        # beta = torch.transpose(beta, 0, 1)
        # B_i = torch.zeros((o+1, l, l), dtype=torch.complex64)

        # for bi in range(o+1):
        #     B_i[i] = beta[bi]
        # print(B_i)
        # print(B_i2)
        # are_same = torch.all(torch.eq(B_i, B_i2)).item()
        # print(are_same)
        C = torch.zeros((l, o * l), dtype=torch.complex64)

        try:
            B_A_o = B_i[o] @ torch.linalg.inv(A_i[o])
        except:
            B_A_o = B_i[o] @ torch.linalg.pinv(A_i[o])
        for i in range(o):
            C[:, i * l:(i + 1) * l] = B_i[o - i - 1] - B_A_o @ A_i[o - i - 1]

    # return M
    # return torch.real(M)

    return A, C

def merge_modal_properties(f1, f2, z1, z2, p1, p2):
    l = np.max((p1[0].shape[0], p2[0].shape[0]))
    f = []
    zeta = []
    phi = []
    for i in range(len(f1)):
        if p1[i].shape[0] != l:
            phi.append(p2[i])
            f.append(f2[i])
            zeta.append(z2[i])
        elif p2[i].shape[0] != l:
            phi.append(p1[i])
            f.append(f1[i])
            zeta.append(z1[i])
        else:
            phi.append(torch.cat((p1[i],p2[i]), axis=1))
            f.append(torch.cat((f1[i],f2[i])))
            zeta.append(torch.cat((z1[i],z2[i])))


        f[i], f_idx = torch.sort(f[i])
        zeta[i] = zeta[i][f_idx]
        phi[i] = phi[i][:,f_idx]

        if f[i].numel() == 0:
            continue
        f[i], f_counts = torch.unique_consecutive(f[i], return_counts=True)
        c1 = 0
        f_uq_idx = []
        for j in range(len(f_counts)):
            f_uq_idx.append(c1)
            c1 += int(f_counts[j])
        # print('f_uq_idx: ',f_uq_idx)
        zeta[i] = zeta[i][f_uq_idx]
        phi[i] = phi[i][:, f_uq_idx]

    return f, zeta, phi


"""## 5. Poles

### Modal parameters (state space approach)
"""

def modal_parameters(A, C, dt):
    f = []
    zeta = []
    Phi = []
    for i in range(len(C)):
        C[i] = C[i].to(torch.complex64)
        L, V = torch.linalg.eig(A[i])

        # print('A[i].shape', A[i].shape)
        # print('C[i].shape', C[i].shape)

        Lambda = torch.log(L) / dt
        # print(Lambda)
        f.append(torch.abs(Lambda) / (2 * torch.pi))

        f[i], f_idx = torch.sort(f[i])
        # print(f[i])
        zeta.append(-torch.real(Lambda) / torch.abs(Lambda))
        zeta[i] = zeta[i][f_idx]
        Phi.append(C[i] @ V)
        Phi[i] = Phi[i][:, f_idx]
        # eliminate complex conjugate pairs
        # print('zeta: ',zeta[i])
        if f[i].numel() == 0:
            continue
        f[i], f_counts = torch.unique_consecutive(f[i], return_counts=True)
        c1 = 0
        f_uq_idx = []
        for j in range(len(f_counts)):
            f_uq_idx.append(c1)
            c1 += int(f_counts[j])
        # print('f_uq_idx: ',f_uq_idx)
        zeta[i] = zeta[i][f_uq_idx]
        Phi[i] = Phi[i][:, f_uq_idx]

        if zeta[i].numel() > 0:
            # Removing negative damping ratios
            non_negative_mask = zeta[i] > 0
            non_negative_zeta_indices = torch.nonzero(non_negative_mask).squeeze()
            f[i] = f[i][non_negative_zeta_indices]
            zeta[i] = zeta[i][non_negative_zeta_indices]
            Phi[i] = Phi[i][:, non_negative_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)
        if zeta[i].numel() > 0:
            # Removing big (more than 20%) damping ratios
            non_big_mask = zeta[i] < 0.2
            non_big_zeta_indices = torch.nonzero(non_big_mask).squeeze()
            f[i] = f[i][non_big_zeta_indices]
            zeta[i] = zeta[i][non_big_zeta_indices]
            Phi[i] = Phi[i][:, non_big_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)
    return f, zeta, Phi


"""### Modal parameters for more accurate mode shapes"""


def modal_parameters_accurate(A, C, dt, criteria, stable_f):
    f = []
    zeta = []
    Phi = []
    for i in range(len(C)):
        C[i] = C[i].to(torch.complex64)
        L, V = torch.linalg.eig(A[i])

        # print('A[i].shape', A[i].shape)
        # print('C[i].shape', C[i].shape)

        Lambda = torch.log(L) / dt

        f.append(torch.abs(Lambda) / (2 * torch.pi))
        f[i], f_idx = torch.sort(f[i])
        j_idx = 0
        f_idx_to_remove = []
        for j in f[i]:
            flag_stable = False
            for k in stable_f:
                if torch.abs((j - k) / j) < criteria[0]:
                    flag_stable = True
                    break
            if flag_stable == False:
                f_idx_to_remove.append(j_idx)
            j_idx += 1

        f_idx_to_remain = [x for x in range(len(f_idx)) if x not in f_idx_to_remove]
        f[i] = f[i][f_idx_to_remain]
        f_idx = f_idx[f_idx_to_remain]

        zeta.append(-torch.real(Lambda) / torch.abs(Lambda))
        zeta[i] = zeta[i][f_idx]
        Phi.append(C[i] @ V)
        Phi[i] = Phi[i][:, f_idx]
        # eliminate complex conjugate pairs
        # print('zeta: ',zeta[i])
        if f[i].numel() == 0:
            continue
        f[i], f_counts = torch.unique_consecutive(f[i], return_counts=True)
        c1 = 0
        f_uq_idx = []
        for j in range(len(f_counts)):
            f_uq_idx.append(c1)
            c1 += int(f_counts[j])
        # print('f_uq_idx: ',f_uq_idx)
        zeta[i] = zeta[i][f_uq_idx]
        Phi[i] = Phi[i][:, f_uq_idx]
        if zeta[i].numel() > 0:
            # Removing negative damping ratios
            non_negative_mask = zeta[i] > 0
            non_negative_zeta_indices = torch.nonzero(non_negative_mask).squeeze()
            f[i] = f[i][non_negative_zeta_indices]
            zeta[i] = zeta[i][non_negative_zeta_indices]
            Phi[i] = Phi[i][:, non_negative_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)
        if zeta[i].numel() > 0:
            # Removing big (more than 30%) damping ratios
            non_big_mask = zeta[i] < 0.3
            non_big_zeta_indices = torch.nonzero(non_big_mask).squeeze()
            f[i] = f[i][non_big_zeta_indices]
            zeta[i] = zeta[i][non_big_zeta_indices]
            Phi[i] = Phi[i][:, non_big_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)
    return f, zeta, Phi

"""### 4.4.3.2 pLSCF approach for extracting modal parameters (Corrected)"""

def finding_mode_shape(lamb, Gyy, f_psd):
    """
    This function uses found physical modes to calculate mode shapes (as the second phase).

    :param lamb: An array of complex values of the physical modes.
    :param Gyy: The PSD matrix.
    :param f_psd: Frequency domain's array
    :return: A list of mode shapes
    """
    l = Gyy.shape[1]

    lamb = lamb.reshape(1,-1)
    lamb_conj = np.conjugate(lamb).copy()
    lamb = np.concatenate((lamb,lamb_conj),axis=0)

    lamb = lamb.T.copy()
    lamb = lamb.reshape(-1)

    # lamb = lambda_list[o]

    f_psd_Nf_1 = f_psd.reshape(1,-1)
    lamb_list_mul = lamb.reshape(-1,1)

    lamb_list_psd = 1/(1j*2*torch.pi*f_psd_Nf_1 - 1j*lamb_list_mul)

    # # print(f'f_psd shape: {f_psd_Nf_1.shape} = 1*Nf')
    # # print(f'lamb_list: {lamb_list_mul.shape} = n*1,  n = order*l*2')
    # # print(f'1/(omg-lamb): {lamb_list_psd.shape} = n*Nf')

    Lambda_mat = lamb_list_psd@lamb_list_psd.T
    Lambda_mat = torch.kron(Lambda_mat, torch.eye(l,dtype=torch.complex64))
    # print(Lambda_mat)
    # # print(f'Lambda_mat shape: {Lambda_mat.shape} = nl*nl')

    G_mat = torch.zeros((len(lamb)*l, l), dtype=torch.complex64)
    lambda_eye = torch.kron(lamb_list_psd, torch.eye(l,dtype=torch.complex64))

    Gyy_reshaped = Gyy.reshape(-1,l)
    G_mat = lambda_eye.clone().to(torch.complex64)@Gyy_reshaped.clone().to(torch.complex64)
    # print(G_mat)
    # print(f'Gyy: {Gyy_reshaped.shape}')
    # print(f'G_mat shape: {G_mat.shape}')


    # phi = torch.zeros((l, int(len(lamb)//2)), dtype=torch.complex64)
    phi = []
    # # R_mat = torch.inverse(Lambda_mat)@G_mat

    R_mat = torch.linalg.solve(Lambda_mat.clone().to(torch.complex64),G_mat)
    ##################################################################
    ##################################################################
    ##################################################################
    counter_mode_shape = 0
    for i in range(1,len(lamb),2):
        R_i = R_mat[i*l:(i+1)*l, :]
        U, _ , _ = torch.linalg.svd(R_i)
        u = U[:,0]
        # phi[:,counter_mode_shape] = u
        phi.append(np.asarray(u))
        counter_mode_shape += 1

    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []

    for i in range(len(phi)):
        UU_comb = phi[i]
        Mode_shapes_phase.append(np.angle(UU_comb))
        Mode_shapes_amp.append(np.abs(np.real(UU_comb)))
    for i in range(len(phi)):
        Mode_shapes_sign.append(np.sign(np.cos(Mode_shapes_phase[i]-Mode_shapes_phase[i][0])))
        Mode_shapes.append(Mode_shapes_sign[i]*Mode_shapes_amp[i] / np.max(Mode_shapes_amp[i]))
    return Mode_shapes

"""### Independent Mode Shape Calculator"""
def independent_mode_shape(freqs, damps, y, dt, nseg=2, pov=0.5, window='hann'):
    """
    This function if based on a method that uses frequencies and damping ratios to extract mode shapes.
    This method is used internally in PolyMAX and ITD, though here we provided an independent form.
    This independent function let the user find the mode shapes by simply having the frequencies and damping ratios.

    :param freqs: A list of physical modes' frequencies
    :param damps:A list of physical modes' damping ratios
    :param y: A 2D Numpy array containing the response of the structure
    :param dt: Time Resolution
    :param nseg: Number of segments in Welch's method
    :param pov: Percent of overlap
    :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
    :return: A list of mode shapes
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if isinstance(y, pd.DataFrame):
        y = np.asarray(y)
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)  ## y.shape = [number_of_sensors, number_of_timesteps]
    print('Calculating PSD...')
    Gyy, f_psd = psd_func_PolyMAX(y, dt, nseg=nseg, pov=pov, window=window)  # One-sided
    lambda_list = []
    for i in range(len(freqs)):
        lambda_list.append(-2j*np.pi*freqs[i]*damps[i] + 2*np.pi*freqs[i]*np.sqrt(1-damps[i]**2))
    lambda_list = np.asarray(lambda_list)
    #######################################################################
    # Mode shape
    if lambda_list.size == 0:
        print('No mode found!')
        Stable_phis = 0
    else:
        print(f'Finding mode shapes ...')
        phis = finding_mode_shape(lambda_list, Gyy, f_psd)
    return phis
"""## Stable Poles

### MAC calculation
"""

def MAC_Calculation(Mode_shape1, Mode_shape2):
    MAC=( torch.dot(Mode_shape1,Mode_shape2)**2 / (torch.dot(Mode_shape1,Mode_shape1) * torch.dot(Mode_shape2,Mode_shape2) ) )
    return MAC

"""### Stable poles function without mode shapes"""

def Stable_Poles_without_phi(f, zeta, criteria, Num_Poles):
    # Criteria is a list of numbers which show the similarity criteria between two consecutive poles to assume them stable
    err_f = criteria[0]
    err_zeta = criteria[1]
    stable = []
    x_scatter_not_stable = []
    y_scatter_not_stable = []
    x_scatter_stable = []
    y_scatter_stable = []
    z_scatter_stable = []

    x_scatter_stable_noZeta = []
    y_scatter_stable_noZeta = []

    stable_frequencies_dict = {}
    stable_frequencies_dict_avg = {}
    stable_zetas_dict_avg = {}
    stable_frequencies = []
    stable_zetas = []
    for i in range(len(f)-1):
        f1 = f[i]
        f2 = f[i+1]
        zeta1 = zeta[i]
        zeta2 = zeta[i+1]

        stable.append(torch.zeros_like(f2))
        if f1.numel() == 0 or f2.numel() == 0:
            continue
        for j2 in range(len(f2)):
            j2_f = f2[j2]
            j2_z = zeta2[j2]
            for j1 in range(len(f1)):
                j1_f = f1[j1]
                j1_z = zeta1[j1]
                if (j1_f-j2_f)/j1_f > err_f:
                    break
                #################################################################################################
                ## For the cases all parameters are reliable
                #################################################################################################
                if torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f    and    torch.abs(j2_z-j1_z)/torch.abs(j1_z) < err_zeta  \
                  and   j2_z<0.1:#  and j2_z>0:
                    stable[i][j2] = 1
                    x_scatter_stable.append(j2_f)
                    y_scatter_stable.append(i+1)
                    z_scatter_stable.append(j2_z)
                    if stable_frequencies_dict == {}:
                        stable_frequencies_dict.update({j2_f:1})
                        stable_frequencies_dict_avg.update({j2_f:1})
                        stable_zetas_dict_avg.update({j2_f:j2_z})
                        # stable_phis_dict_avg.update({j2_f:j2_ph})
                        # stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                        is_same_freq = True
                    else:
                        stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                        for kk in stable_frequencies_dict.keys():
                            is_same_freq = False
                            if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                is_same_freq = True
                                kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                stable_zetas_dict_avg.pop(kk)
                                stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                stable_frequencies_dict_avg.pop(kk)
                                stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                break
                        if not is_same_freq:
                            # stable_phis_dict_avg.update({j2_f:j2_ph})
                            stable_zetas_dict_avg.update({j2_f:j2_z})
                            stable_frequencies_dict_avg.update({j2_f:1})

                    break  # The pole is stable no need to check more of j1
                #################################################################################################
                ## For the cases that damping ratios are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f:
                    x_scatter_stable_noZeta.append(j2_f)
                    y_scatter_stable_noZeta.append(i+1)
            x_scatter_not_stable.append(j2_f)
            y_scatter_not_stable.append(i+1)
        stable[i] = list(map(bool, stable[i]))

    ###############################################################################################
    # A loop for adding stable poles with number more than a limit to a list as natural frequencies
    ###############################################################################################
    how_many_stable_poles = Num_Poles
    for kk in stable_frequencies_dict_avg.keys():
        if stable_frequencies_dict_avg[kk]>=how_many_stable_poles and kk not in stable_frequencies:
            stable_frequencies.append(kk)
            stable_zetas.append(stable_zetas_dict_avg[kk])

            ## Finding the stable pole having the nearest frequency to the mean frequency
            # diff_freq = np.asarray(stable_phis_dict[kk]['freq']) - np.asarray(kk)
            # min_diff_freq_idx = np.argmin(diff_freq)

    sorted_idx = np.argsort(np.array(stable_frequencies))
    stable_zetas_sorted_by_freq = []
    for i in sorted_idx:
        stable_zetas_sorted_by_freq.append(stable_zetas[i])


    # Mode_shapes = []
    # Mode_shapes_amp = []
    # Mode_shapes_phase = []
    # Mode_shapes_sign = []
    # for mode in range(len(stable_phis_sorted_by_freq)):
    #     Mode_shapes_phase.append(torch.angle(stable_phis_sorted_by_freq[mode]))
    #     Mode_shapes_amp.append(torch.abs(stable_phis_sorted_by_freq[mode]))
    #     Mode_shapes_sign.append(torch.sign(torch.cos(Mode_shapes_phase[mode]-Mode_shapes_phase[mode][0])))
    #     Mode_shapes.append(Mode_shapes_sign[mode]*Mode_shapes_amp[mode] / torch.max(Mode_shapes_amp[mode]))


    stable_frequencies.sort()
    return {'x_NS':x_scatter_not_stable, 'y_NS':y_scatter_not_stable, 'x_S':x_scatter_stable, 'y_S':y_scatter_stable, 'z_S':z_scatter_stable, \
            'x_S_noZeta':x_scatter_stable_noZeta, 'y_S_noZeta':y_scatter_stable_noZeta}, \
     {'frequencies':stable_frequencies, 'damping_ratios':stable_zetas_sorted_by_freq}

"""### Stable poles function"""

def Stable_Poles(f, zeta, phi, criteria, Num_Poles):
    # Criteria is a list of numbers which show the similarity criteria between two consecutive poles to assume them stable
    err_f = criteria[0]
    err_zeta = criteria[1]
    err_phi = criteria[2]
    stable = []
    x_scatter_not_stable = []
    y_scatter_not_stable = []
    x_scatter_stable = []
    y_scatter_stable = []
    z_scatter_stable = []
    ph_stable = []

    x_scatter_stable_noZeta = []
    y_scatter_stable_noZeta = []
    ph_stable_noZeta = []

    x_scatter_stable_noZeta_noPhi = []
    y_scatter_stable_noZeta_noPhi = []

    stable_frequencies_dict = {}
    stable_frequencies_dict_avg = {}
    stable_zetas_dict_avg = {}
    stable_phis_dict = {}
    stable_phis_dict_avg = {}
    stable_frequencies = []
    stable_zetas = []
    stable_phis = []
    for i in range(len(f)-1):
        f1 = f[i]
        f2 = f[i+1]
        zeta1 = zeta[i]
        zeta2 = zeta[i+1]
        phi1 = phi[i]
        phi2 = phi[i+1]

        stable.append(torch.zeros_like(f2))
        if f1.numel() == 0 or f2.numel() == 0:
            continue
        for j2 in range(len(f2)):
            j2_f = f2[j2]
            j2_z = zeta2[j2]
            j2_ph = phi2[:,j2]
            for j1 in range(len(f1)):
                j1_f = f1[j1]
                j1_z = zeta1[j1]
                j1_ph = phi1[:,j1]
                # print(j2_ph)
                # print(j1_ph)
                if j2_ph.shape != j1_ph.shape:
                    continue
                mac_phi = MAC_Calculation(j2_ph,j1_ph)
                if (j1_f-j2_f)/j1_f > err_f:
                    break
                #################################################################################################
                ## For the cases all parameters are reliable
                #################################################################################################
                if torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f    and    torch.abs(j2_z-j1_z)/torch.abs(j1_z) < err_zeta  \
                 and     torch.abs(1-mac_phi) < err_phi and j2_z>0:#   and   j2_z<0.1  :
                    stable[i][j2] = 1
                    x_scatter_stable.append(j2_f)
                    y_scatter_stable.append(i+1)
                    z_scatter_stable.append(j2_z)
                    ph_stable.append(j2_ph)
                    if stable_frequencies_dict == {}:
                        stable_frequencies_dict.update({j2_f:1})
                        stable_frequencies_dict_avg.update({j2_f:1})
                        stable_zetas_dict_avg.update({j2_f:j2_z})
                        # stable_phis_dict_avg.update({j2_f:j2_ph})
                        stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                        is_same_freq = True
                    else:
                        stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                        for kk in stable_frequencies_dict.keys():
                            is_same_freq = False
                            if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                is_same_freq = True
                                kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                # phi_avg_value = (stable_phis_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_ph)/(stable_frequencies_dict_avg[kk]+1)
                                # stable_phis_dict_avg.pop(kk)
                                # stable_phis_dict_avg.update({kk_new:phi_value_new})

                                stable_zetas_dict_avg.pop(kk)
                                stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                phi_value_new = stable_phis_dict[kk].copy()
                                phi_value_new['freq'].append(j2_f)
                                phi_value_new['phi'].append(j2_ph)

################
                                # Mode_shapes_phase_temp = torch.angle(j1_ph)
                                # Mode_shapes_amp_temp = torch.abs(j1_ph)
                                # Mode_shapes_sign_temp = torch.sign(torch.cos(Mode_shapes_phase_temp-Mode_shapes_phase_temp[0]))
                                # Mode_shapes_temp = Mode_shapes_sign_temp*Mode_shapes_amp_temp / torch.max(Mode_shapes_amp_temp)
                                # print(f'frquency = {j1_f} Green \nmode shape = {Mode_shapes_temp}')
################
                                stable_phis_dict.pop(kk)
                                stable_phis_dict.update({kk_new:phi_value_new})

                                kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                stable_frequencies_dict_avg.pop(kk)
                                stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                break
                        if not is_same_freq:
                            # stable_phis_dict_avg.update({j2_f:j2_ph})
                            stable_zetas_dict_avg.update({j2_f:j2_z})
                            stable_frequencies_dict_avg.update({j2_f:1})
                            stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})

                    break  # The pole is stable no need to check more of j1
                #################################################################################################
                ## For the cases that damping ratios are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f  and torch.abs(1-mac_phi) < err_phi and j2_z>0:
                    x_scatter_stable_noZeta.append(j2_f)
                    y_scatter_stable_noZeta.append(i+1)
                    ph_stable_noZeta.append(j2_ph)
################
                    # Mode_shapes_phase_temp = torch.angle(j1_ph)
                    # Mode_shapes_amp_temp = torch.abs(j1_ph)
                    # Mode_shapes_sign_temp = torch.sign(torch.cos(Mode_shapes_phase_temp-Mode_shapes_phase_temp[0]))
                    # Mode_shapes_temp = Mode_shapes_sign_temp*Mode_shapes_amp_temp / torch.max(Mode_shapes_amp_temp)
                    # print(f'frquency = {j1_f} Blue \nmode shape = {Mode_shapes_temp}')
################
                #################################################################################################
                ## For the cases that damping ratios and mode shapes are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f and j2_z>0:
                    x_scatter_stable_noZeta_noPhi.append(j2_f)
                    y_scatter_stable_noZeta_noPhi.append(i+1)
################
                    # Mode_shapes_phase_temp = torch.angle(j1_ph)
                    # Mode_shapes_amp_temp = torch.abs(j1_ph)
                    # Mode_shapes_sign_temp = torch.sign(torch.cos(Mode_shapes_phase_temp-Mode_shapes_phase_temp[0]))
                    # Mode_shapes_temp = Mode_shapes_sign_temp*Mode_shapes_amp_temp / torch.max(Mode_shapes_amp_temp)
                    # print(f'frquency = {j1_f} Orange \nmode shape = {Mode_shapes_temp}')
################
            x_scatter_not_stable.append(j2_f)
            y_scatter_not_stable.append(i+1)
        stable[i] = list(map(bool, stable[i]))

    ###############################################################################################
    # A loop for adding stable poles with number more than a limit to a list as natural frequencies
    ###############################################################################################
    how_many_stable_poles = Num_Poles
    for kk in stable_frequencies_dict_avg.keys():
        if stable_frequencies_dict_avg[kk]>=how_many_stable_poles and kk not in stable_frequencies:
            stable_frequencies.append(kk)
            stable_zetas.append(stable_zetas_dict_avg[kk])

            ## Finding the stable pole having the nearest frequency to the mean frequency
            diff_freq = np.asarray(stable_phis_dict[kk]['freq']) - np.asarray(kk)
            min_diff_freq_idx = np.argmin(diff_freq)
            stable_phis.append(stable_phis_dict[kk]['phi'][min_diff_freq_idx])

    sorted_idx = np.argsort(np.array(stable_frequencies))
    stable_zetas_sorted_by_freq = []
    stable_phis_sorted_by_freq = []
    for i in sorted_idx:
        stable_zetas_sorted_by_freq.append(stable_zetas[i])
        stable_phis_sorted_by_freq.append(stable_phis[i])


    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []
    for mode in range(len(stable_phis_sorted_by_freq)):
        Mode_shapes_phase.append(torch.angle(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_amp.append(torch.abs(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_sign.append(torch.sign(torch.cos(Mode_shapes_phase[mode]-Mode_shapes_phase[mode][0])))
        Mode_shapes.append(Mode_shapes_sign[mode]*Mode_shapes_amp[mode] / torch.max(Mode_shapes_amp[mode]))


    stable_frequencies.sort()
    return {'x_NS':x_scatter_not_stable, 'y_NS':y_scatter_not_stable, 'x_S':x_scatter_stable, 'y_S':y_scatter_stable, 'z_S':z_scatter_stable, 'ph_stable':ph_stable, \
            'x_S_noZeta':x_scatter_stable_noZeta, 'y_S_noZeta':y_scatter_stable_noZeta, 'ph_stable_noZeta':ph_stable_noZeta, \
            'x_S_noZeta_noPhi':x_scatter_stable_noZeta_noPhi, 'y_S_noZeta_noPhi':y_scatter_stable_noZeta_noPhi}, \
     {'frequencies':stable_frequencies, 'damping_ratios':stable_zetas_sorted_by_freq, 'mode_shapes':Mode_shapes}

"""### Stable Poles for accurate mode shapes"""

def Stable_Poles_accurate(f, zeta, phi, criteria):
    # Criteria is a list of numbers which show the similarity criteria between two consecutive poles to assume them stable
    err_f = criteria[0]
    err_zeta = criteria[1]
    err_phi = criteria[2]
    stable = []
    x_scatter_not_stable = []
    y_scatter_not_stable = []
    x_scatter_stable = []
    y_scatter_stable = []
    z_scatter_stable = []
    ph_stable = []

    x_scatter_stable_noZeta = []
    y_scatter_stable_noZeta = []
    ph_stable_noZeta = []

    x_scatter_stable_noZeta_noPhi = []
    y_scatter_stable_noZeta_noPhi = []

    stable_frequencies_dict = {}
    stable_frequencies_dict_avg = {}
    stable_zetas_dict_avg = {}
    stable_phis_dict = {}
    stable_phis_dict_avg = {}
    stable_frequencies = []
    stable_zetas = []
    stable_phis = []
    for i in range(len(f)-1):
        f1 = f[i]
        f2 = f[i+1]
        zeta1 = zeta[i]
        zeta2 = zeta[i+1]
        phi1 = phi[i]
        phi2 = phi[i+1]

        stable.append(torch.zeros_like(f2))
        if f1.numel() == 0 or f2.numel() == 0:
            continue
        for j2 in range(len(f2)):
            j2_f = f2[j2]
            j2_z = zeta2[j2]
            j2_ph = phi2[:,j2]
            for j1 in range(len(f1)):
                j1_f = f1[j1]
                j1_z = zeta1[j1]
                j1_ph = phi1[:,j1]
                # print(j2_ph)
                # print(j1_ph)
                if j2_ph.shape != j1_ph.shape:
                    continue
                mac_phi = MAC_Calculation(j2_ph,j1_ph)
                if (j1_f-j2_f)/j1_f > err_f:
                    break
                #################################################################################################
                ## For the cases all parameters are reliable
                #################################################################################################
                # if torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f    and    torch.abs(j2_z-j1_z)/torch.abs(j1_z) < err_zeta  \
                #  and     torch.abs(1-mac_phi) < err_phi*10 and j2_z>0:#   and   j2_z<0.1  :
                if torch.abs(1-mac_phi) < err_phi*2 and j2_z>0:
                    stable[i][j2] = 1
                    x_scatter_stable.append(j2_f)
                    y_scatter_stable.append(i+1)
                    z_scatter_stable.append(j2_z)
                    ph_stable.append(j2_ph)
                    if stable_frequencies_dict == {}:
                        stable_frequencies_dict.update({j2_f:1})
                        stable_frequencies_dict_avg.update({j2_f:1})
                        stable_zetas_dict_avg.update({j2_f:j2_z})
                        # stable_phis_dict_avg.update({j2_f:j2_ph})
                        stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                        is_same_freq = True
                    else:
                        stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                        for kk in stable_frequencies_dict.keys():
                            is_same_freq = False
                            if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                is_same_freq = True
                                kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                # phi_avg_value = (stable_phis_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_ph)/(stable_frequencies_dict_avg[kk]+1)
                                # stable_phis_dict_avg.pop(kk)
                                # stable_phis_dict_avg.update({kk_new:phi_value_new})

                                stable_zetas_dict_avg.pop(kk)
                                stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                phi_value_new = stable_phis_dict[kk].copy()
                                phi_value_new['freq'].append(j2_f)
                                phi_value_new['phi'].append(j2_ph)

################
                                # Mode_shapes_phase_temp = torch.angle(j1_ph)
                                # Mode_shapes_amp_temp = torch.abs(j1_ph)
                                # Mode_shapes_sign_temp = torch.sign(torch.cos(Mode_shapes_phase_temp-Mode_shapes_phase_temp[0]))
                                # Mode_shapes_temp = Mode_shapes_sign_temp*Mode_shapes_amp_temp / torch.max(Mode_shapes_amp_temp)
                                # print(f'frquency = {j1_f} Green \nmode shape = {Mode_shapes_temp}')
################
                                stable_phis_dict.pop(kk)
                                stable_phis_dict.update({kk_new:phi_value_new})

                                kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                stable_frequencies_dict_avg.pop(kk)
                                stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                break
                        if not is_same_freq:
                            # stable_phis_dict_avg.update({j2_f:j2_ph})
                            stable_zetas_dict_avg.update({j2_f:j2_z})
                            stable_frequencies_dict_avg.update({j2_f:1})
                            stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})

                    break  # The pole is stable no need to check more of j1
#                 #################################################################################################
#                 ## For the cases that damping ratios are not very reliable
#                 #################################################################################################
#                 elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f  and torch.abs(1-mac_phi) < err_phi*10 and j2_z>0:
#                     x_scatter_stable_noZeta.append(j2_f)
#                     y_scatter_stable_noZeta.append(i+1)
#                     ph_stable_noZeta.append(j2_ph)
# ################
#                     # Mode_shapes_phase_temp = torch.angle(j1_ph)
#                     # Mode_shapes_amp_temp = torch.abs(j1_ph)
#                     # Mode_shapes_sign_temp = torch.sign(torch.cos(Mode_shapes_phase_temp-Mode_shapes_phase_temp[0]))
#                     # Mode_shapes_temp = Mode_shapes_sign_temp*Mode_shapes_amp_temp / torch.max(Mode_shapes_amp_temp)
#                     # print(f'frquency = {j1_f} Blue \nmode shape = {Mode_shapes_temp}')
################

            x_scatter_not_stable.append(j2_f)
            y_scatter_not_stable.append(i+1)
        stable[i] = list(map(bool, stable[i]))

    ###############################################################################################
    # A loop for adding stable poles with number more than a limit to a list as natural frequencies
    ###############################################################################################
    how_many_stable_poles = 1
    for kk in stable_frequencies_dict_avg.keys():
        if stable_frequencies_dict_avg[kk]>=how_many_stable_poles and kk not in stable_frequencies:
            stable_frequencies.append(kk)
            stable_zetas.append(stable_zetas_dict_avg[kk])

            ## Finding the stable pole having the nearest frequency to the mean frequency
            diff_freq = np.asarray(stable_phis_dict[kk]['freq']) - np.asarray(kk)
            min_diff_freq_idx = np.argmin(diff_freq)
            stable_phis.append(stable_phis_dict[kk]['phi'][min_diff_freq_idx])

    sorted_idx = np.argsort(np.array(stable_frequencies))
    stable_zetas_sorted_by_freq = []
    stable_phis_sorted_by_freq = []
    for i in sorted_idx:
        stable_zetas_sorted_by_freq.append(stable_zetas[i])
        stable_phis_sorted_by_freq.append(stable_phis[i])


    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []
    for mode in range(len(stable_phis_sorted_by_freq)):
        Mode_shapes_phase.append(torch.angle(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_amp.append(torch.abs(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_sign.append(torch.sign(torch.cos(Mode_shapes_phase[mode]-Mode_shapes_phase[mode][0])))
        Mode_shapes.append(Mode_shapes_sign[mode]*Mode_shapes_amp[mode] / torch.max(Mode_shapes_amp[mode]))


    stable_frequencies.sort()
    return {'x_NS':x_scatter_not_stable, 'y_NS':y_scatter_not_stable, 'x_S':x_scatter_stable, 'y_S':y_scatter_stable, 'z_S':z_scatter_stable, 'ph_stable':ph_stable, \
            'x_S_noZeta':x_scatter_stable_noZeta, 'y_S_noZeta':y_scatter_stable_noZeta, 'ph_stable_noZeta':ph_stable_noZeta, \
            'x_S_noZeta_noPhi':x_scatter_stable_noZeta_noPhi, 'y_S_noZeta_noPhi':y_scatter_stable_noZeta_noPhi}, \
     {'frequencies':stable_frequencies, 'damping_ratios':stable_zetas_sorted_by_freq, 'mode_shapes':Mode_shapes}

"""## Mode shape

# Diagrams

## Stabilization Diagram"""

def fix_coord_dict(input_dict):
    # Dictionary with all possible keys
    all_keys = {'x_NS', 'y_NS', 'x_S', 'y_S', 'z_S', 'ph_stable',
                'x_S_noZeta', 'y_S_noZeta', 'ph_stable_noZeta',
                'x_S_noZeta_noPhi', 'y_S_noZeta_noPhi',
                'X_bound_cov', 'y_bound_cov', 'z_bound_cov',
                'X_bound_cov_stable_nozeta', 'y_bound_cov_stable_nozeta', 'z_bound_cov_stable_nozeta',
                'X_bound_cov_stable_nozeta_nophi', 'y_bound_cov_stable_nozeta_nophi', 'z_bound_cov_stable_nozeta_nophi',
                'X_bound_cov_notstable', 'y_bound_cov_notstable', 'z_bound_cov_notstable'}

    # Iterate over all possible keys and check if they're in the input dictionary
    copy_dict = input_dict.copy()
    for key in all_keys:
        if key not in input_dict:
            copy_dict[key] = []  # If key is missing, add it with an empty list

    return copy_dict

def stabilization_diagram(Coord_dict, Stable_frequencies, Stable_zetas, without_mode_shape=False, add_damping_indicator=False, xlim=0, ylim=0, scale_unc=1.,
                          damp_ylim=0, add_PSD_SVD=False, f_psd=[], ss1=[], show_second_singular_value=False, show_title=False, only_show_stable=False, draw_unc=False):
    """
        This function is a general function to plot stabilization diagram.

        :param Coord_dict: Information about poles (Output of methods like SSI, PolyMAX, and ITD)
        :param Stable_frequencies: A list of physical modes' frequencies
        :param Stable_zetas: A list of physical modes' damping ratios
        :param without_mode_shape: A bool value, if True the mode shapes are not considered (suitable for ITD and PolyMAX).
        :param add_damping_indicator: A bool value, if True some text indicator will be shown.
        :param xlim: A list of two numbers indicating the xlim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete xlim)
        :param ylim: A list of two numbers indicating the ylim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete ylim)
        :param damp_ylim: A list of two numbers indicating the ylim of the damping ratio plot. (e.g. [2,10]) (0 acts as the complete ylim)
        :param add_PSD_SVD: A bool value, if True first singular value diagram will be shown behind the stabilization diagram.
        :param f_psd: If add_PSD_SVD=True, a frequency domain's array must be provided.
        :param ss1: If add_PSD_SVD=True, an SVD of PSD array must be provided.
    """

    if 'x_S_noZeta_noPhi' not in Coord_dict.keys():
        without_mode_shape = True

    Coord_dict = fix_coord_dict(Coord_dict)

    if Coord_dict['X_bound_cov_notstable'] == [] and draw_unc:
        draw_unc = False
        print('There is no uncertainty information available!')


    
    if without_mode_shape:
        if not add_PSD_SVD:
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # ax1 = axis[0]
            # ax2 = axis[1]

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')
            
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim) 
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)

            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)
            # plt.show()

            # plt.subplot(2,1,2)
            fig_total, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)

            ax2.grid()
            # plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            scatt3 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('Singular values of PSD (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                # plt1_2.set_zorder(0.5)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(which='both')

            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3] ,framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))


            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)
            
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)

            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid(which='both')
            plt.show()
    else:
        if not add_PSD_SVD:
            # fig_total, axis = plt.subplots(2, 1, figsize=(10, 10))
            #
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)
            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()
            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)


            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)

            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            # ax2.grid()
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.grid(visible=True, axis='x')
            ax2.grid(visible=True, which='both', axis='y')
            plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                scatt3 = ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt3 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            scatt4 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')


            COV_TOL = 1e10
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc, Coord_dict['x_S'][i]-np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc]
                if Coord_dict['X_bound_cov'][i] < COV_TOL:
                    if draw_unc:
                        ax1.plot(x_plot_cov, y_plot_cov, color='tab:green')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta'][i], Coord_dict['y_bound_cov_stable_nozeta'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc, Coord_dict['x_S_noZeta'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:blue')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta_nophi'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta_nophi'][i], Coord_dict['y_bound_cov_stable_nozeta_nophi'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta_noPhi'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc, Coord_dict['x_S_noZeta_noPhi'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta_nophi'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:orange')

            # for i in range(len(Coord_dict['X_bound_cov_notstable'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_notstable'][i], Coord_dict['y_bound_cov_notstable'][i]]
            #     x_plot_cov = [Coord_dict['x_NS'][i]+np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc, Coord_dict['x_NS'][i]-np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_notstable'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:red')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()


            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3, scatt4], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid()
            # ax2.grid(visible=True,axis='x')
            # ax2.grid(visible=True,which='both',axis='y')
            plt.show()

"""## Mode shape diagram

### Farrar mode shape function
"""

def Farrar_Mode_shape_diagram(Mode_shapes):
    number_dof = len(Mode_shapes[0])
    fig, axis = plt.subplots(1, len(Mode_shapes), sharey=True, figsize=(8, 5))
    ax1 = axis[0]
    plt.subplots_adjust(wspace=0.5, hspace=0.5)
    Points = []
    for i in range(len(Mode_shapes)):
        Points.append({'x':[], 'y':list(range(1,number_dof+1))})

    for j in range(len(Mode_shapes)):
        plt.subplot(1, len(Mode_shapes), j+1)

        for i in range(number_dof):
            Points[j]['x'].append(Mode_shapes[j][i])
            if i == 0:
                continue
            plt.plot([Points[j]['x'][i],Points[j]['x'][i-1]], [Points[j]['y'][i], Points[j]['y'][i-1]],'-bo', markersize = 6 )
            plt.plot([0, 0], [Points[j]['y'][i], Points[j]['y'][i-1]],'-mo', markersize = 6 )
            plt.ylabel('Floors')
            plt.xlabel('Relative Displacement')
            plt.legend([f'mode {j+1}', 'Undamaged'], framealpha=0.9)
            plt.xlim([-1.1,1.1])
            plt.ylim([0.8,4.3])

        plt.grid()
        # Set the y-axis ticks to be at every integer value
    ax1.set_yticks(range(0, number_dof+1, 1))

    # Format the y-axis labels to remove the decimal part
    ax1.set_yticklabels(['{:.0f}'.format(y) for y in range(0, number_dof+1, 1)])
    plt.show()

"""### Italy Bridge 2 mode shape function"""

def Bridge2_Mode_shape_diagram(Mode_shapes):
    alpha = np.pi/9
    beta = np.pi/6
    L1 = 12
    # L2_dis = [15,2,14,14,2,15,15,0,-15,-15,-2,-14,-14,-2,-15]
    # L2 = [15]
    # for i in range(len(L2_dis)):
    #     L2.append(L2[-1]+L2_dis[i])
    L2 = [13.5, 22.5, 30.5, 44.5, 58.5, 66.5, 75.5, 89, 89, 75.5, 66.5, 58.5, 44.5, 30.5, 22.5, 13.5]
    P_plot = {'x':[],'y':[]}
    S_plot = []
    for i in range(16): # THIS PLOT CAN BE DRAWN BY 16 POINTS + 2 REFRENCE POINTS
        S_plot.append({'x':[],'y':[]})
    Alt_MSh_Still = np.zeros(16) # Altered Mode Shape
    Alt_MSh = np.zeros((len(Mode_shapes),16)) # Altered Mode Shape
    for i in range(len(Mode_shapes)):
        Alt_MSh[i,[0,2,3,4,6,11,12,13]] = Mode_shapes[i][[3,1,0,2,4,7,5,6]]



    A_Coord = L1*np.array([np.sin(alpha), 0])
    B_Coord = L1*np.array([0, np.cos(alpha)])

    LinkLine = np.zeros((16, len(Mode_shapes), 2, 2))

    S = np.zeros((16, len(Mode_shapes), 2))
    scale_factor = 10 # Mode Shape scalar ###################
    for j in range(len(Mode_shapes)):
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])
        for i in range(8):
            S[i,j,:] = A_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)]) + scale_factor*np.array([0, Alt_MSh[j,i]])
            LinkLine[i,j,0,:] = A_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
        for i in range(8,16):
            S[i,j,:] = B_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)]) + scale_factor*np.array([0, Alt_MSh[j,i]])
            LinkLine[i,j,0,:] = B_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
        S_plot[j]['x'].append(B_Coord[0])
        S_plot[j]['y'].append(B_Coord[1])
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        P_plot['x'].append(B_Coord[0])
        P_plot['y'].append(B_Coord[1])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])


    fig, axis = plt.subplots(len(Mode_shapes),1,sharex=True, sharey=True, figsize=(10, 10))
    plt.subplots_adjust(wspace=0.2, hspace=0.2)
    for j in range(len(Mode_shapes)):
        plt.subplot(len(Mode_shapes), 1, j+1)
        ax1 = plt.gca()
        ax1.set_yticks([])
        ax1.set_xticks([])
        for i in range(len(P_plot['x'])):
            x = P_plot['x'][i]
            y = P_plot['y'][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-r')

            x_old = x
            y_old = y
        for i in range(len(S_plot[j]['x'])):
            x = S_plot[j]['x'][i]
            y = S_plot[j]['y'][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-b', linewidth=.7)

            x_old = x
            y_old = y
        for i in range(16):
            plt.plot([LinkLine[i,j,0,0],LinkLine[i,j,1,0]],[LinkLine[i,j,0,1],LinkLine[i,j,1,1]], '-m', linewidth=.5)
            if Alt_MSh[j,i] != 0:
                x_text = (LinkLine[i,j,0,0]+LinkLine[i,j,1,0])/2
                y_text = (LinkLine[i,j,0,1]+LinkLine[i,j,1,1])/2
                plt.text(x_text, y_text, f"{'{:.2f}'.format(Alt_MSh[j,i])}", fontsize = 'small')

    plt.show()


"""# Big Data Mode Shape"""
def Big_Bridge_Mode_shape_diagram(Mode_shapes, perspective='yx'):
    # perspective one of ['yx', 'yz']
    #######################
    # Changing Mode Shapes dimensions from 78 to (26, 3)
    for i in range(len(Mode_shapes)):
        Mode_shapes[i] = Mode_shapes[i].reshape(26,3)
    #######################

    #######################
    # *2 The Dataset x and y are alternated.
    #######################

    L1 = []
    L2 = []
    for sens_name in sens_names:
        L1.append(coord_df[coord_df['sens_pos'] == sens_name]['y']) # *2
        L2.append(coord_df[coord_df['sens_pos'] == sens_name]['x']) # *2
    L1 = np.asarray(L1)
    L2 = np.asarray(L2)


    P_plot = {'x':[],'y':[],'z':[]}
    S_plot = []
    N_alt_point = 28 # THIS PLOT CAN BE DRAWN BY N_alt_point(28) POINTS + 2 REFRENCE POINTS
    L1_Alt = np.zeros(N_alt_point)
    L2_Alt = np.zeros(N_alt_point)

    L1_Alt[[0,1,2,3,4,5,6,7,8,9,10,11,12,15,16,17,18,19,20,21,22,23,24,25,26,27]] = L1[[0,1,2,3,8,9,10,11,12,18,19,20,21,25,24,23,22,17,16,15,14,13,7,6,5,4]].reshape(-1)
    L1_Alt[[13]] = np.array(coord_df[coord_df['sens_pos'] == 'C4.1.5'][['y']]).reshape(-1)
    L1_Alt[[14]] = np.array(coord_df[coord_df['sens_pos'] == 'C4.2.5'][['y']]).reshape(-1)
    L1 = L1_Alt

    L2_Alt[[0,1,2,3,4,5,6,7,8,9,10,11,12,15,16,17,18,19,20,21,22,23,24,25,26,27]] = L2[[0,1,2,3,8,9,10,11,12,18,19,20,21,25,24,23,22,17,16,15,14,13,7,6,5,4]].reshape(-1)
    L2_Alt[[13]] = np.array(coord_df[coord_df['sens_pos'] == 'C4.1.5'][['x']]).reshape(-1)
    L2_Alt[[14]] = np.array(coord_df[coord_df['sens_pos'] == 'C4.2.5'][['x']]).reshape(-1)
    L2 = L2_Alt

    for i in range(len(Mode_shapes)):
        S_plot.append({'x':[],'y':[],'z':[]})
    Alt_MSh_Still = np.zeros((N_alt_point,3)) # Altered Mode Shape
    Alt_MSh = np.zeros((len(Mode_shapes),N_alt_point, 3)) # Altered Mode Shape

    for i in range(len(Mode_shapes)):
        Alt_MSh[i,[0,1,2,3,4,5,6,7,8,9,10,11,12,15,16,17,18,19,20,21,22,23,24,25,26,27], :] = \
        Mode_shapes[i][[0,1,2,3,8,9,10,11,12,18,19,20,21,25,24,23,22,17,16,15,14,13,7,6,5,4], :]



    A_Coord = np.array(coord_df[coord_df['sens_pos'] == 'C2.1.3'][['y','x','z']]).reshape(-1)
    B_Coord = np.array(coord_df[coord_df['sens_pos'] == 'C2.2.3'][['y','x','z']]).reshape(-1)
    LinkLine = np.zeros((N_alt_point, len(Mode_shapes), 2, 3)) ## (Coord, num_of_modeshapes, before_after, x_y_z)

    S = np.zeros((N_alt_point, len(Mode_shapes), 3))
    scale_factor = np.array([100, 10, 10]) # Mode Shape scalar ###################
    for j in range(len(Mode_shapes)):
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        S_plot[j]['z'].append(A_Coord[2])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])
        P_plot['z'].append(A_Coord[2])
        for i in range(int(N_alt_point//2)):
            S[i,j,:] = np.array([L1[i], L2[i], 0]) +  scale_factor * Alt_MSh[j,i,:]
            LinkLine[i,j,0,:] = np.array([L1[i], L2[i], 0])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            S_plot[j]['z'].append(S[i,j,2])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
            P_plot['z'].append(LinkLine[i,j,0,2])
        for i in range(int(N_alt_point//2),N_alt_point):
            S[i,j,:] = np.array([L1[i], L2[i], 0]) +  scale_factor * Alt_MSh[j,i,:]
            LinkLine[i,j,0,:] = np.array([L1[i], L2[i], 0])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            S_plot[j]['z'].append(S[i,j,2])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
            P_plot['z'].append(LinkLine[i,j,0,2])
        S_plot[j]['x'].append(B_Coord[0])
        S_plot[j]['y'].append(B_Coord[1])
        S_plot[j]['z'].append(B_Coord[2])
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        S_plot[j]['z'].append(A_Coord[2])
        P_plot['x'].append(B_Coord[0])
        P_plot['y'].append(B_Coord[1])
        P_plot['z'].append(B_Coord[2])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])
        P_plot['z'].append(A_Coord[2])


    perspective_horizontal = perspective[0]
    horizontal_axis_number = int('xyz'.find(perspective_horizontal))
    perspective_vertical = perspective[1]
    vertical_axis_number = int('xyz'.find(perspective_vertical))

    fig, axis = plt.subplots(len(Mode_shapes),1,sharex=True, sharey=True, figsize=(15, 15))
    plt.subplots_adjust(wspace=0.2, hspace=0.2)
    for j in range(len(Mode_shapes)):
        plt.subplot(len(Mode_shapes), 1, j+1)
        ax1 = plt.gca()
        ax1.set_yticks([])
        ax1.set_xticks([])
        for i in range(len(P_plot[perspective_horizontal])):
            x = P_plot[perspective_horizontal][i]
            y = P_plot[perspective_vertical][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-r')

            x_old = x
            y_old = y
        for i in range(len(S_plot[j][perspective_horizontal])):
            x = S_plot[j][perspective_horizontal][i]
            y = S_plot[j][perspective_vertical][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-b', linewidth=.7)

            x_old = x
            y_old = y
        for i in range(N_alt_point):
            plt.plot([LinkLine[i,j,0,horizontal_axis_number],LinkLine[i,j,1,horizontal_axis_number]],[LinkLine[i,j,0,vertical_axis_number],LinkLine[i,j,1,vertical_axis_number]], '-m', linewidth=.5)
            if (Alt_MSh[j,i] != 0).any():
                x_text = (LinkLine[i,j,0,horizontal_axis_number]+LinkLine[i,j,1,horizontal_axis_number])/2
                y_text = (LinkLine[i,j,0,vertical_axis_number]+LinkLine[i,j,1,vertical_axis_number])/2
                plt.text(x_text, y_text, f"{perspective_horizontal}: {'{:.2f}'.format(Alt_MSh[j,i,horizontal_axis_number])}", fontsize = 'small')
                plt.text(x_text, y_text-3, f"{perspective_vertical}: {'{:.2f}'.format(Alt_MSh[j,i,vertical_axis_number])}", fontsize = 'small')

    plt.show()