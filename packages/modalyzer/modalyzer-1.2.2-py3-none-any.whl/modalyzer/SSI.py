# -*- coding: utf-8 -*-
"""SSI_cov.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cCcKEGbEB4KsgEYL6pFDWhjir9rAKN5C

# Importing Modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from scipy.signal import butter, filtfilt
import scipy
from scipy.signal import welch, csd
from scipy.linalg import svd
from matplotlib.ticker import FuncFormatter
import time as TIME
# !pip install plotly
import plotly.express as px

"""# SSI-COV funtions

## Assembling [Rᵢ]
"""

def Assembling_R(y, lag, device='cpu'):
    """

    :param y:
    :param lag:
    :param device:
    :return:
    """
    if not torch.is_tensor(y):
        y = torch.tensor(y, dtype=torch.float).to(device)
    l = y.shape[0]
    N = y.shape[1]
    R = torch.zeros((2*lag, l, l), dtype=torch.float).to(device)
    for i in range(1,2*lag+1):
        R[i-1,:,:] = 1/(N-lag) * torch.matmul(y[:,:N-i], torch.transpose(y[:,i:N], 0,1))
    R0 = 1/(N-lag) * torch.matmul(y[:,:N], torch.transpose(y[:,0:N], 0,1))
    return R, R0

"""## Assembling Toeplitz Block Matrix"""

def Assembling_T(R, lag, device='cpu'):
    """

    :param R:
    :param lag:
    :param device:
    :return:
    """
    T = torch.tensor([]).to(device)
    T_lag = torch.tensor([]).to(device)

    T_row = torch.tensor([]).to(device)
    for i in range(lag-1, -1, -1):
        T_row = torch.cat((T_row, R[i,:,:]), axis=1)
    T = torch.cat((T,T_row), axis=0)

    for j in range(lag, 2*lag-1):
        T_row = torch.tensor([]).to(device)
        for i in range(j, j-lag, -1):
            T_row = torch.cat((T_row, R[i,:,:]), axis=1)
        T = torch.cat((T,T_row), axis=0)
        T_lag = torch.cat((T_lag,T_row), axis=0)
    T_row = torch.tensor([]).to(device)
    for i in range(2*lag-1, lag-1, -1):
        T_row = torch.cat((T_row, R[i,:,:]), axis=1)
    T_lag = torch.cat((T_lag,T_row), axis=0)
    return T, T_lag

"""## Calculating [Oᵢ] and [Γᵢ] and [A], [G] and [C]"""

def Calc_O_Gamma(T, T_lagged, l, order, method=1, device='cpu'):
    """

    :param T:
    :param T_lagged:
    :param l:
    :param order:
    :param method:
    :param device:
    :return:
    """
    device='cpu'
    [U,S,V] = torch.svd(T)
    # S1 = torch.zeros((order, S.shape[0]))
    # U1 = torch.zeros((order, U.shape[0], U.shape[1]))
    # Vt1 = torch.zeros((order, Vt.shape[0], Vt.shape[1]))
    C = []
    G = []
    A = []

    for i in range(1, order+1):
        S1 = S[:i]
        U1 = U[:,:i]
        Vt1 = V[:,:i].T
        Sig = torch.sqrt(torch.diag(S1))
        O = U1@Sig
        Gamma = Sig@Vt1
        C.append(O[0:l,:])
        G.append(Gamma[:, Gamma.shape[1]-l+1:])
        if method == 1:
            A.append(torch.inverse(Sig)@(U1.T)@T_lagged@(Vt1.T)@torch.inverse(Sig))
        elif method == 2:
            O_down = O[l:,:]
            O_up = O[:O.shape[0]-l,:]
            A.append(torch.linalg.pinv(O_up)@O_down)
    return A, C, G

def Calc_O_max(H, l, order, device='cpu'):
    """

    :param T:
    :param order:
    :param device:
    :return:
    """
    C = []
    A = []

    [U,S,V] = torch.svd(H)
    # S1 = torch.zeros((order, S.shape[0]))
    # U1 = torch.zeros((order, U.shape[0], U.shape[1]))
    # Vt1 = torch.zeros((order, Vt.shape[0], Vt.shape[1]))
    
    S1 = S[:]
    U1 = U[:,:]
    Vt1 = V[:,:].T
    Sig = torch.sqrt(torch.diag(S1))
    Om = U1@Sig

    for i in range(2, order+1):
        O = Om[:,:i]
        C.append(O[0:l,:])
        O_down = O[l:,:]
        O_up = O[:O.shape[0]-l,:]
        A.append(torch.linalg.pinv(O_up)@O_down)

    return Om, A, C

"""## Whole operation function"""

def Assembling_H_L(R,lag,device='cpu'):
    H_L = torch.tensor([])
    HL_row = torch.tensor([])
    # for i in range(lag-1, -1, -1):
    for i in range(0, lag):
        HL_row = torch.cat((HL_row, R[i,:,:]), axis=1)
    H_L = torch.cat((H_L,HL_row), axis=0)

    for j in range(1, lag):
        HL_row = torch.tensor([])
        for i in range(j, lag+j):
            HL_row = torch.cat((HL_row, R[i,:,:]), axis=1)
        # for i in range(1, lag-j):
        #     HL_row = torch.cat((HL_row, R[i,:,:]), axis=1)

        H_L = torch.cat((H_L,HL_row), axis=0)

    return H_L
    

# def Calc_SigmaH_T(y,lag,nb,device='cpu'):
#     if not torch.is_tensor(y):
#         y = torch.tensor(y, dtype=torch.float).to(device)
#     l = y.shape[0]
#     N = y.shape[1]
#     Nb = int(N//nb)
#     N = Nb*nb

#     y_Nb = torch.zeros((nb, l, Nb), dtype=torch.float).to(device)

#     for i in range(nb):
#         y_Nb[i] = np.sqrt(Nb)/np.sqrt(N) * y[:, Nb*i:Nb*(i+1)]
    
#     # R = torch.zeros((nb, 2*lag, l, l), dtype=torch.float).to(device)
#     R = torch.zeros((nb, lag, lag, l, l), dtype=torch.float).to(device)
#     for j in range(nb):
#         for i in range(1,lag+1):
#             for k in range(1,lag+1):
#                 R[j,i-1,k-1,:,:] = 1/(Nb-lag) * torch.matmul(y_Nb[:,:Nb-i-k+1], torch.transpose(y_Nb[:,i+k-1:Nb], 0,1))
#         # R0 = 1/(N-lag) * torch.matmul(y[:,:N], torch.transpose(y[:,0:N], 0,1))
#     R_hat = torch.mean(R, dim=0)

#     h_tilde = R - R_hat
#     h_tilde = h_tilde.reshape(h_tilde.shape[0], -1)
#     T = 1/(np.sqrt(nb*(nb-1))) * h_tilde

#     return T.T

def Calc_SigmaH_T(y, lag, nb, device='cpu'):
    if not torch.is_tensor(y):
        y = torch.tensor(y, dtype=torch.float32).to(device)       # float32 is fine
    else:
        y = y.to(device).to(torch.float32)

    l = y.shape[0]
    N = y.shape[1]
    Nb = int(N // nb)
    N = Nb * nb

    # use torch.sqrt to stay on-device
    y_Nb = torch.zeros((nb, l, Nb), dtype=torch.float32, device=device)
    scale = torch.sqrt(torch.tensor(Nb / N, dtype=torch.float32, device=device))
    for i in range(nb):
        y_Nb[i] = scale * y[:, Nb*i:Nb*(i+1)]

    # R[j, i-1, k-1, :, :] will store R_{i+k-1} for block j
    R = torch.zeros((nb, lag, lag, l, l), dtype=torch.float32, device=device)

    for j in range(nb):
        Y = y_Nb[j]                                    # <<< use the j-th block
        for i in range(1, lag+1):
            for k in range(1, lag+1):
                s = i + k - 1                          # <<< correlation lag index
                # M = Nb - s                             # <<< number of usable pairs
                # slices of equal length M:
                A = Y[:, :Nb-s]                           # y_t
                B = Y[:, s:Nb]                        # y_{t+s}
                R[j, i-1, k-1, :, :] = (A @ B.T) / (Nb-s)   # unbiased: divide by Nb - s


    R_hat = torch.mean(R, dim=0)

    h_tilde = R - R_hat
    h_tilde = h_tilde.reshape(h_tilde.shape[0], -1)     # (nb, dimH)
    T = h_tilde.T / torch.sqrt(torch.tensor(nb*(nb+1), dtype=torch.float32, device=device))

    return T                                         # (dimH, nb)



# def Calc_SigmaH_T(y, lag, nb, device='cpu', unbiased=True):
#     """
#     Build T such that Σ_H ≈ T @ T.T for the covariance-driven subspace matrix H_cov
#     with p+1 = q = lag (block-Hankel of correlations R_{i+k-1}).

#     y: (r, N) tensor or array (rows = channels)
#     lag: integer, p+1 = q = lag
#     nb: number of blocks
#     returns: T of shape ((lag*lag*r*r), nb)
#     """
#     # --- to tensor on device ---
#     if not torch.is_tensor(y):
#         y = torch.tensor(y, dtype=torch.float32)
#     y = y.to(device)
#     r, N = y.shape

#     # --- split into nb blocks of equal length Nb ---
#     Nb = int(N // nb)
#     N = Nb * nb  # trim remainder
#     y = y[:, :N]

#     # optional block normalization (paper Eq. 16):
#     # y_Nb[j] = sqrt(Nb)/sqrt(N) * y_block
#     scale = (Nb / N) ** 0.5
#     y_blocks = [scale * y[:, j*Nb:(j+1)*Nb] for j in range(nb)]  # list of (r, Nb)

#     # allocate Hankel of correlations for each block
#     # H_cov^(j) has shape (lag, lag, r, r)
#     R = torch.empty((nb, lag, lag, r, r), dtype=y.dtype, device=device)

#     for j in range(nb):
#         Y = y_blocks[j]  # (r, Nb)
#         # for each block (i,k), place R_{s} with s = i+k-1
#         for i in range(1, lag+1):
#             for k in range(1, lag+1):
#                 s = i + k - 1  # actual correlation lag
#                 M = Nb - s     # number of terms
#                 # slices of equal length M:
#                 A = Y[:, :M]           # (r, M)
#                 B = Y[:, s:s+M]        # (r, M)
#                 # correlation: sum_t y_t y_{t+s}^T
#                 C = A @ B.T            # (r, r)
#                 if unbiased:
#                     C = C / M          # unbiased (paper’s R̂_i uses N-i)
#                 else:
#                     C = C / Nb         # biased
#                 R[j, i-1, k-1, :, :] = C

#     # mean across blocks (j)
#     R_hat = R.mean(dim=0)                         # (lag, lag, r, r)
#     h_tilde = (R - R_hat).reshape(nb, -1)         # (nb, lag*lag*r*r)
#     # T columns are the centered samples, scaled by 1/sqrt(nb(nb-1))
#     T = h_tilde.T / (nb * (nb-1))**0.5            # ((lag*lag*r*r), nb)

#     T = T.to(torch.float)
#     return T

def Calc_Q_max(H_L,O,T,order,lag,l,nb):
    O_down = O[l:,:]
    O_up = O[:O.shape[0]-l,:]

    I_n = torch.eye(l*(lag))
    I_r = torch.eye(l)
    Z_r = torch.zeros((l,l*(lag-1)))

    # IIZ = torch.kron(I_n, torch.cat((I_r,Z_r),dim=1))
    IrZ = torch.cat((I_r,Z_r),dim=1)
    
    S1 = torch.cat((torch.eye(l*(lag-1)), torch.zeros((l*(lag-1),l))),dim=1)
    S2 = torch.cat((torch.zeros((l*(lag-1),l)), (torch.eye(l*(lag-1)))),dim=1)


    Q1 = []
    Q2 = []
    Q3 = []
    Q4 = []

    JOH_T = []

    ui, si, vi_H = torch.linalg.svd(H_L)
    
    starting_time = TIME.time()
    for i in range(len(si)):
        zero_v = torch.cat((torch.zeros((l*(lag)-1,l*(lag))), 2*vi_H[i:i+1,:]), dim=0) ## or vi_H[:,i]
        K_i = torch.linalg.inv(torch.eye(H_L.shape[1]) + zero_v - (H_L.H)@H_L/si[i]**2)

        zero_u = torch.cat((torch.zeros((l*(lag)-1,l*(lag))), ui[:,i:i+1].H), dim=0) ## or ui[i,:]
        
        B_i_1_item_part1 = torch.eye(l*(lag)) + (H_L@K_i/si[i])@(H_L.H/si[i]-zero_u)
        B_i_1_item_part2 = H_L@K_i / si[i]
        B_i_1 = torch.cat((B_i_1_item_part1, B_i_1_item_part2), dim=1)

        T_i_1 = torch.kron(torch.eye(l*(lag)), ui[:,i:i+1].H)@T
        T_i_2 = torch.kron(vi_H[i:i+1,:], torch.eye(l*(lag)))@T

        T_i_u_v = torch.cat((T_i_2 - ui[:,i:i+1]  @  (ui[:,i:i+1].H@T_i_2) , (T_i_1 - vi_H[i:i+1,:].H@(vi_H[i:i+1,:]@T_i_1))), dim=0)

        JOH_T_i = 0.5*(si[i]**-.5)*ui[:,i:i+1]@(vi_H[i:i+1,:]@T_i_1) + (si[i]**-.5)*B_i_1@T_i_u_v

        Q1.append(O_up.T@S1@JOH_T_i)
        Q2.append(O_down.T@S1@JOH_T_i)
        Q3.append(O_up.T@S2@JOH_T_i)
        Q4.append(IrZ@JOH_T_i)

        if (i+1)%(int(len(si)//10)) == 0:
            ending_time = TIME.time()
            elapsed_time = ending_time - starting_time
            print(f'Computing Qmax pack ... ({i+1}/{len(si)}), time = {elapsed_time:.2f}s')
            starting_time = TIME.time()
        # JOH_T.append(JOH_T_i)

    # JOH_T = torch.stack(JOH_T, dim=0)
    # JOH_T = JOH_T.reshape(-1, JOH_T.shape[2])


    # Q1 = torch.kron(torch.eye(l*lag), O_up.T@S1) @ JOH_T
    # Q2 = torch.kron(torch.eye(l*lag), O_down.T@S1) @ JOH_T
    # Q3 = torch.kron(torch.eye(l*lag), O_up.T@S2) @ JOH_T
    # Q4 = IIZ @ JOH_T

    Q1 = torch.stack(Q1, dim=0)
    Q2 = torch.stack(Q2, dim=0)
    Q3 = torch.stack(Q3, dim=0)
    Q4 = torch.stack(Q4, dim=0)


    Q1 = Q1.reshape(-1, nb)
    Q2 = Q2.reshape(-1, nb)
    Q3 = Q3.reshape(-1, nb)
    Q4 = Q4.reshape(-1, nb)

    return Q1, Q2, Q3, Q4




def Calc_unc_bounds(order, dt, l, lag, Omax, Q_pack, poles_info, An, Cn):
    f, zeta, phi, lamb, left_vec, right_vec = poles_info

    # print('left_vec',len(left_vec))
    # print('left_vec',left_vec[5].shape)
    # print('right_vec',len(right_vec))
    # print('right_vec',right_vec[5].shape)

    Qm1, Qm2, Qm3, Qm4 = Q_pack

    nm = lag*l

    f_cov = []
    xi_cov = []
    phi_re_cov = []
    phi_im_cov = []
    phi_cov = []


    for i in range(2,order+1):
        if i%(int(order//10)) == 0:
            print(f'Computing order: {i}/{order}')
        compatible_i_idx = i - 2

        A = An[compatible_i_idx]
        C = Cn[compatible_i_idx]

        IZ_S4 = torch.cat((torch.eye(i), torch.zeros((i,nm-i))),dim=1)
        # print('IZ_S4', IZ_S4.shape)
        S4_n = torch.kron(IZ_S4, IZ_S4)
        # print('S4_n', S4_n.shape)
        IZ_Q4 = torch.cat((torch.eye(i*l), torch.zeros((i*l,l*(nm-i)))),dim=1)
        # print('IZ_Q4', IZ_Q4.shape)

        # print('Qm1', Qm1.shape)
        # print('Qm2', Qm2.shape)
        # print('Qm3', Qm3.shape)
        # print('Qm4', Qm4.shape)
        # print('S4_n', S4_n.shape)
        Q1 = torch.matmul(S4_n, Qm1)
        Q2 = torch.matmul(S4_n, Qm2)
        Q3 = torch.matmul(S4_n, Qm3)
        Q4 = torch.matmul(IZ_Q4, Qm4)

        O = Omax[:,:i]
        O_down = O[l:,:]
        O_up = O[:O.shape[0]-l,:]
        OupOup = torch.inverse(O_up.T@O_up)
        OupOup = OupOup.to(torch.complex64)

        I_n = torch.eye(i)         # I_n, shape (n, n)
        E_n = torch.eye(i)         # columns are e_1,...,e_n

        blocks = []
        for j in range(i):
            e_i = E_n[:, j:j+1]                                # e_i, shape (n, 1)
            kron_block = torch.kron(I_n, e_i)                  # shape (n*n, n)
            blocks.append(kron_block)
            # print('kron_block', kron_block.shape)


        Pnn = torch.cat(blocks, dim=1)                         # shape (n*n, n*n)
        # print('Pnn', Pnn.shape)
        
        PnnIQ1 = (Pnn + torch.eye((i)**2))@Q1

        PnnQ2Q3 = Pnn@Q2+Q3

        f_cov_array = []
        xi_cov_array = []
        phi_re_cov_array = []
        phi_im_cov_array = []
        phi_cov_array = []
        # print('f', f)
        # print('f', f[compatible_i_idx].shape)
        for j in range(f[compatible_i_idx].shape[0]):

            # print('lamb', len(lamb))
            # print('lamb', (lamb[0].shape))
            # print('left_vec', len(left_vec))
            # print('left_vec', left_vec[compatible_i_idx].shape)
            # print(torch.kron(left_vec[compatible_i_idx][:,j:j+1].T, torch.eye(i)).shape)
            # print((-lamb[compatible_i_idx][j]*PnnIQ1+PnnQ2Q3).shape)
            
            Qi = torch.kron(left_vec[compatible_i_idx][:,j:j+1].T, torch.eye(i))@(-lamb[compatible_i_idx][j]*PnnIQ1+PnnQ2Q3)
            Qi = Qi.to(torch.complex64)
            ## Lemma 5.
            lamb_tilde = torch.log(lamb[compatible_i_idx][j])/dt
            J_f_xi_lamb = 1/(dt* torch.abs(lamb[compatible_i_idx][j])**2 *torch.abs(lamb_tilde)) * \
                torch.tensor([[1/(2*torch.pi),0],[0,100/torch.abs(lamb_tilde)**2]]) @ \
                torch.tensor([[torch.real(lamb_tilde),torch.imag(lamb_tilde)],[-torch.imag(lamb_tilde)**2,torch.real(lamb_tilde)*torch.imag(lamb_tilde)]]) @ \
                torch.tensor([[torch.real(lamb[compatible_i_idx][j]),torch.imag(lamb[compatible_i_idx][j])],[-torch.imag(lamb[compatible_i_idx][j]),torch.real(lamb[compatible_i_idx][j])]])

            # J_f_lamb = J_f_xi_lamb[0,:]
            # J_xi_lamb = J_f_xi_lamb[1,:]

            left_right_vec_dot = 1/torch.dot(right_vec[compatible_i_idx][:,j:j+1].H.reshape(-1), left_vec[compatible_i_idx][:,j:j+1].reshape(-1)) 
            left_right_vec_dot_right = left_right_vec_dot * right_vec[compatible_i_idx][:,j:j+1].H
            

            JJJ_lamb_H_T = left_right_vec_dot_right @ OupOup @ Qi ######## row vector or col vector ???


            JJJ_lamb_H_T_re_im = torch.cat([torch.real(JJJ_lamb_H_T),torch.imag(JJJ_lamb_H_T)],dim=0)
            U_f_xi = J_f_xi_lamb@JJJ_lamb_H_T_re_im

            
            JJJ_phi_H_T = torch.linalg.pinv(lamb[compatible_i_idx][j]*torch.eye(i) - A) @ \
                  (torch.eye(i) - (left_vec[compatible_i_idx][:,j:j+1]@right_vec[compatible_i_idx][:,j:j+1].H) / left_right_vec_dot) @ \
                  OupOup @ Qi
            
            k = torch.argmax(torch.abs(phi[compatible_i_idx][:,j])) # index of the dof for max normalization to 1
            torch.argmax
            # print(len(phi))
            # print('phi',len(phi))
            # print('phi',phi[compatible_i_idx].shape)
            if phi[compatible_i_idx].shape[-1] != l and phi[compatible_i_idx].shape[0] != l:
                phi[compatible_i_idx] = torch.ones((l,1))
            elif phi[compatible_i_idx].shape[-1] == l and phi[compatible_i_idx].shape[0] != l:
                phi[compatible_i_idx] = phi[compatible_i_idx].T

            # print('torch.zeros((l,k))', torch.zeros((l,k)).shape)
            # print('phi',phi[compatible_i_idx].shape)
            # print('torch.zeros((l,l-k-1))', torch.zeros((l,l-k-1)).shape)

            ZphiZ = torch.cat((torch.zeros((l,k)), phi[compatible_i_idx][:,j:j+1], torch.zeros((l,l-k-1))),dim=1)

            kron_left_eye = torch.kron(left_vec[compatible_i_idx][:,j:j+1].T,torch.eye(l))
            # print('1',(C@left_vec[compatible_i_idx][:,j:j+1])[k].shape)
            # print('2',(torch.eye(l)-ZphiZ).shape)
            # print('3',(C@JJJ_phi_H_T).shape)
            # print('4',kron_left_eye.shape)
            # print('5',Q4.shape)


            JJJ_phi_A_C_H_T = 1/(C@left_vec[compatible_i_idx][:,j:j+1])[k] * \
                (torch.eye(l)-ZphiZ).to(torch.complex64) @ (C@JJJ_phi_H_T + kron_left_eye @ Q4.to(torch.complex64))
            U_phi = torch.cat((torch.real(JJJ_phi_A_C_H_T),torch.imag(JJJ_phi_A_C_H_T)),dim=0)

    
            cov_f_xi = U_f_xi@ U_f_xi.T

            cov_f = cov_f_xi[0,0]
            f_cov_array.append(cov_f)

            cov_xi = cov_f_xi[1,1]
            xi_cov_array.append(cov_xi)

            cov_real_imag_phi = U_phi@ U_phi.T

            cov_phi_re = cov_real_imag_phi[0:l,0:l]
            phi_re_cov_array.append(cov_phi_re)

            cov_phi_im = cov_real_imag_phi[l:,l:]
            phi_im_cov_array.append(cov_phi_im)
            
            cov_phi = torch.sqrt(torch.diag(cov_phi_re) + torch.diag(cov_phi_im))
            cov_phi_mean = torch.mean(cov_phi)
            phi_cov_array.append(cov_phi_mean)

            # print(cov_f_xi)
            # print(cov_real_imag_phi)

            # f_cov_order.append(cov_f_xi)
            # zeta_cov_order = []
            # phi_real_cov_order = []
            # phi_imag_cov_order = []

        f_cov_array = torch.stack(f_cov_array, dim=0) if len(f_cov_array) else torch.empty((0,))
        xi_cov_array = torch.stack(xi_cov_array, dim=0) if len(xi_cov_array) else torch.empty((0,))
        phi_re_cov_array = torch.stack(phi_re_cov_array, dim=0) if len(phi_re_cov_array) else torch.empty((0,))
        phi_im_cov_array = torch.stack(phi_im_cov_array, dim=0) if len(phi_im_cov_array) else torch.empty((0,))

        
        f_cov.append(f_cov_array)
        # print('f_cov',f_cov)
        xi_cov.append(xi_cov_array)
        phi_re_cov.append(phi_re_cov_array)
        phi_im_cov.append(phi_im_cov_array)
        phi_cov.append(phi_cov_array)

    return f_cov, xi_cov, phi_cov

def SSI_COV_UNC(y, dt, nb=10, order=100, lag=20, criteria=[], Num_Poles=5, unc_criteria=[], device='cpu'):
    """

    :param y:
    :param order:
    :param lag:
    :param method:
    :param device:
    :return:
    """
    l = y.shape[0]
    R, R0 = Assembling_R(y,lag,device=device)
    
    # Toeplitz, T_lagged = Assembling_T(R,lag,device=device) # Toepiltz
    
    H_L = Assembling_H_L(R,lag,device=device)
    Omax, An, Cn = Calc_O_max(H_L, l, order, device=device)
    f, zeta, phi, lamb, left_vec, right_vec = modal_parameters(An,Cn,dt)
    poles_info = (f, zeta, phi, lamb, left_vec, right_vec)
    T = Calc_SigmaH_T(y,lag,nb)

    Qm1, Qm2, Qm3, Qm4 = Calc_Q_max(H_L,Omax,T,order=order,lag=lag,l=l,nb=nb)
    Q_pack = (Qm1, Qm2, Qm3, Qm4)

    f_cov, xi_cov, phi_cov = Calc_unc_bounds(order=order, dt=dt, l=l, lag=lag, Omax=Omax, Q_pack=Q_pack, poles_info=poles_info, An=An, Cn=Cn)

    Unc_info = {'freq': f_cov, 'damp': xi_cov, 'msh': phi_cov}

    # print('f_cov',len(f_cov))
    # counter_f_cov = 0
    # for i in range(len(f_cov)):
    #     for j in range(len(f_cov[i])):
    #         counter_f_cov += 1
    # print('counter_f_cov',counter_f_cov)
    # print('xi_cov',len(xi_cov))
    # print('phi_re_cov',len(phi_re_cov))

    for i in range(len(phi)):
        if phi[i].dtype == torch.float:
            phi[i] = phi[i].to(torch.complex64)
    Coord_dict, Modal_info = Stable_Poles(f,zeta,phi,criteria,Num_Poles, f_cov, xi_cov, phi_cov,unc_criteria=unc_criteria)
    print('#######################')

    return Coord_dict, Modal_info, Unc_info

def SSI_COV(y, order=100, lag=20, method=1, device='cpu'):
    """

    :param y:
    :param order:
    :param lag:
    :param method:
    :param device:
    :return:
    """
    l = y.shape[0]
    R, R0 = Assembling_R(y,lag,device=device)
    T, T_lagged = Assembling_T(R,lag,device=device) # Toepiltz
    A, C, G = Calc_O_Gamma(T, T_lagged, l, order, method=method, device=device)
    return A, C, G, R0


def Calculatin_W1_W2(R, R0, lag):
    """

    :param R:
    :param lag:
    :param device:
    :return:
    """

    R0 = torch.unsqueeze(R0, 0)
    R = torch.cat((R0,R), axis=0)
    T_plus = torch.tensor([])
    T_minus = torch.tensor([])

    T_row_plus = torch.tensor([])
    T_row_minus = torch.tensor([])
    # for i in range(lag-1, -1, -1):
    for i in range(0, lag):
        if i == 0:
            T_row_plus = torch.cat((T_row_plus, R[i,:,:]), axis=1)
        if i > 0:
            T_row_plus = torch.cat((T_row_plus, R[i,:,:].T), axis=1)
        T_row_minus = torch.cat((T_row_minus, R[i,:,:]), axis=1)
    T_plus = torch.cat((T_plus,T_row_plus), axis=0)
    T_minus = torch.cat((T_minus,T_row_minus), axis=0)


    for j in range(1, lag):
        T_row_plus = torch.tensor([])
        T_row_minus = torch.tensor([])

        for i in range(j, 0, -1):
            T_row_plus = torch.cat((T_row_plus, R[i,:,:]), axis=1)
            T_row_minus = torch.cat((T_row_minus, R[i,:,:].T), axis=1)

        # print(T_row_plus.shape)
        # print(T_row_minus.shape)

        T_row_plus = torch.cat((T_row_plus, R[0,:,:]), axis=1)
        T_row_minus = torch.cat((T_row_minus, R[0,:,:]), axis=1)

        # print(T_row_plus.shape)
        # print(T_row_minus.shape)

        for i in range(1, lag-j):
            T_row_plus = torch.cat((T_row_plus, R[i,:,:].T), axis=1)
            T_row_minus = torch.cat((T_row_minus, R[i,:,:]), axis=1)

        # print(T_row_plus.shape)
        # print(T_row_minus.shape)
    
        T_plus = torch.cat((T_plus,T_row_plus), axis=0)
        T_minus = torch.cat((T_minus,T_row_minus), axis=0)


    # print("min diagonal:", np.min(np.diag(T_plus)))

    # Eigenvalues (for real symmetric use eigvalsh)
    tol = 1e-12  # scale this to your problem magnitude

    w = np.linalg.eigvalsh(T_plus)
    min_eig = w[0]
    if min_eig <= 0:
        T_plus += ( -min_eig + tol ) * np.eye(T_plus.shape[0])

    w = np.linalg.eigvalsh(T_minus)
    min_eig = w[0]
    if min_eig <= 0:
        T_minus += ( -min_eig + tol ) * np.eye(T_minus.shape[0])

    L_plus = torch.linalg.cholesky(T_plus)
    L_minus = torch.linalg.cholesky(T_minus)

    W1 = torch.inverse(L_plus)
    W2 = torch.inverse(L_minus)

    return W1, W2

def SSI_COV_CVA(y, order=100, lag=20, method=1, device='cpu'):
    """

    :param y:
    :param order:
    :param lag:
    :param method:
    :param device:
    :return:
    """
    l = y.shape[0]
    R, R0 = Assembling_R(y,lag,device=device)

    # Computing Weights
    W1, W2 = Calculatin_W1_W2(R, R0, lag)
    W1 = W1.to(torch.float)
    W2 = W2.to(torch.float)

    T, T_lagged = Assembling_T(R,lag,device=device)
    T = W2 @ T @ W1
    T_lagged = W2 @ T_lagged @ W1
    A, C, G = Calc_O_Gamma_CVA(T, T_lagged, l, order, W1, W2, method=method, device=device)
    return A, C, G, R0


def Calc_O_Gamma_CVA(T, T_lagged, l, order, W1, W2, method=1, device='cpu'):
    """

    :param T:
    :param T_lagged:
    :param l:
    :param order:
    :param method:
    :param device:
    :return:
    """
    device='cpu'
    [U,S,V] = torch.svd(T)
    # S1 = torch.zeros((order, S.shape[0]))
    # U1 = torch.zeros((order, U.shape[0], U.shape[1]))
    # Vt1 = torch.zeros((order, Vt.shape[0], Vt.shape[1]))
    C = []
    G = []
    A = []

    for i in range(1, order+1):
        S1 = S[:i]
        U1 = U[:,:i]
        Vt1 = V[:,:i].T
        Sig = torch.sqrt(torch.diag(S1))
        O = torch.inverse(W1) @ U1 @ Sig
        Gamma = Sig @ Vt1  @ torch.inverse(W2) 
        C.append(O[0:l,:])
        G.append(Gamma[:, Gamma.shape[1]-l+1:])
        if method == 1:
            A.append(torch.inverse(Sig)@(U1.T)@T_lagged@(Vt1.T)@torch.inverse(Sig))
        elif method == 2:
            O_down = O[l:,:]
            O_up = O[:O.shape[0]-l,:]
            A.append(torch.linalg.pinv(O_up)@O_down)
    return A, C, G

"""# SSI-DATA functions

## Assembling Hankel Block Matrix
"""

def Assembling_H(y, num_block_rows,  device='cpu'):
    """

    :param y:
    :param num_block_rows:
    :param device:
    :return:
    """
    l = y.shape[0]
    N = y.shape[1]
    num_block_cols = N-2*num_block_rows+1

    H = torch.zeros((2*l*num_block_rows, num_block_cols), dtype = torch.float).to(device)
    for i in range(2*num_block_rows):
        for j in range(num_block_cols):
            H[i*l:i*l+l, j] = y[:, i+j]
    H = H / np.sqrt(num_block_cols)
    return H

"""## Calculating State Space Matrices"""

def calc_A_C(H, l, N, order, num_block_rows, method=1, device='cpu'):
    """

    :param H:
    :param l:
    :param N:
    :param order:
    :param num_block_rows:
    :param method:
    :param device:
    :return:
    """
    num_block_cols = N-2*num_block_rows+1
    Qt, Lt = torch.linalg.qr(H.T)
    Q = Qt.T
    L = Lt.T
    Pi = L[l*num_block_rows:, :l*num_block_rows]@Q[:l*num_block_rows, :num_block_cols]
    Pi_1 = L[l*(num_block_rows+1):, :l*(num_block_rows+1)]@Q[:l*(num_block_rows+1), :num_block_cols]
    Yi_i = L[l*num_block_rows:l*(num_block_rows+1), :l*(num_block_rows+1)]@Q[:l*(num_block_rows+1), :num_block_cols]

    [U,s,Vt] = torch.linalg.svd(Pi)

    # S1 = s[s != 0]
    # U1 = U[:, s != 0]

    S1 = s
    U1 = U

    A = []
    C = []

    for i in range(1, order+1):

        S1_i = S1[:i]
        U1_i = U1[:,:i]
        # Vt1_i = Vt1[:i, :]
        Sig = torch.sqrt(torch.diag(S1_i))
        Oi = U1_i@Sig
        # print(f'Oi shape: {Oi.shape}')
        S_hat_i = torch.linalg.pinv(Oi)@Pi
        # print(f'S_hat_i shape: {S_hat_i.shape}')
        Oi_up = Oi[:Oi.shape[0]-l, :]
        # print(f'Oi_up shape: {Oi_up.shape}')
        S_hat_i1 = torch.linalg.pinv(Oi_up)@Pi_1
        # print(f'S_hat_i1 shape: {S_hat_i1.shape}')
        A_mat = S_hat_i1@torch.linalg.pinv(S_hat_i)
        C_mat = Yi_i@torch.linalg.pinv(S_hat_i)
        # print(f'A shape: {A_mat.shape}')
        # print(f'C shape: {C_mat.shape}')
        A.append(A_mat)
        C.append(C_mat)

    return A, C

"""## Whole operation function"""

def SSI_DATA(y, order=100, num_block_rows=20, method=1, device='cpu'):
    """

    :param y:
    :param order:
    :param num_block_rows:
    :param method:
    :param device:
    :return:
    """
    l = y.shape[0]
    N = y.shape[1]
    H = Assembling_H(y, num_block_rows, device=device)
    A, C = calc_A_C(H, l, N, order, num_block_rows, method=1, device=device)
    return A, C

"""# Finding Poles

## MAC function
"""

def MAC_Calculation(Mode_shape1, Mode_shape2):
    """

    :param Mode_shape1:
    :param Mode_shape2:
    :return:
    """
    MAC=( torch.dot(Mode_shape1,Mode_shape2)**2 / (torch.dot(Mode_shape1,Mode_shape1) * torch.dot(Mode_shape2,Mode_shape2) ) )
    return MAC

"""## Calculating modal parameters"""

def modal_parameters(A,C,dt):
    """

    :param A:
    :param C:
    :param dt:
    :return:
    """
    f = []
    zeta = []
    Phi = []
    lamb_list = []
    leftvec_list = []
    rightvec_list = []
    # C = C[1:]
    # A = A[1:]
    for i in range(len(C)):
        C[i] = C[i].to(torch.complex64)
        L, V = torch.linalg.eig(A[i])
        _, right_vector = torch.linalg.eig(A[i].H)

        lamb_list.append(L)
        leftvec_list.append(V)
        rightvec_list.append(right_vector.H)

        Lambda = torch.log(L)/dt

        f.append(torch.abs(Lambda)/(2*torch.pi))
        f[i], f_idx = torch.sort(f[i])
        # print(f[i])
        zeta.append(-torch.real(Lambda)/torch.abs(Lambda))
        zeta[i] = zeta[i][f_idx]
        Phi.append(C[i]@V)
        Phi[i] = Phi[i][:,f_idx]
        # eliminate complex conjugate pairs
        # print('zeta: ',zeta[i])
        if f[i].numel() == 0:
            continue
        f[i], f_counts = torch.unique_consecutive(f[i], return_counts=True)
        c1 = 0
        f_uq_idx = []
        for j in range(len(f_counts)):
            f_uq_idx.append(c1)
            c1 += int(f_counts[j])
        # print('f_uq_idx: ',f_uq_idx)
        zeta[i] = zeta[i][f_uq_idx]
        Phi[i] = Phi[i][:,f_uq_idx]

        if zeta[i].numel() > 0:
            # Removing negative damping ratios
            non_negative_mask = zeta[i] > 0
            non_negative_zeta_indices = torch.nonzero(non_negative_mask).squeeze()
            f[i] = f[i][non_negative_zeta_indices]
            zeta[i] = zeta[i][non_negative_zeta_indices]
            Phi[i] = Phi[i][:, non_negative_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)

        if zeta[i].numel() > 0:
            # Removing big (more than 30%) damping ratios
            non_big_mask = zeta[i] < 0.3
            non_big_zeta_indices = torch.nonzero(non_big_mask).squeeze()
            f[i] = f[i][non_big_zeta_indices]
            zeta[i] = zeta[i][non_big_zeta_indices]
            Phi[i] = Phi[i][:, non_big_zeta_indices]
        f[i] = f[i].reshape(-1)
        zeta[i] = zeta[i].reshape(-1)
        if len(Phi[i].shape) == 1:
            Phi[i] = Phi[i].reshape(1, -1)

    return f, zeta, Phi, lamb_list, leftvec_list, rightvec_list

"""## Finding stable poles"""

def Stable_Poles(f, zeta, phi, criteria, Num_Poles, f_cov=0, zeta_cov=0, phi_cov=0, check_unc=True, unc_criteria=[]):
    """

    :param f:
    :param zeta:
    :param phi:
    :param criteria:
    :param Num_Poles:
    :return:
    """

    if f_cov == 0:
        check_unc = False 
    # Criteria is a list of numbers which show the similarity criteria between two consecutive poles to assume them stable
    err_f = criteria[0]
    err_zeta = criteria[1]
    err_phi = criteria[2]


    err_cov_f = np.inf
    err_cov_zeta = np.inf
    err_cov_phi = np.inf

    if unc_criteria:
        err_cov_f = unc_criteria[0]
        try:
            err_cov_zeta = unc_criteria[1]
            try: 
                err_cov_phi = unc_criteria[2]
            except:
                pass
        except:
            pass



    stable = []
    x_scatter_not_stable = []
    y_scatter_not_stable = []
    x_scatter_stable = []
    y_scatter_stable = []
    z_scatter_stable = []
    ph_stable = []

    x_scatter_stable_noZeta = []
    y_scatter_stable_noZeta = []
    ph_stable_noZeta = []

    x_scatter_stable_noZeta_noPhi = []
    y_scatter_stable_noZeta_noPhi = []

    stable_frequencies_dict = {}
    stable_frequencies_dict_avg = {}
    stable_zetas_dict_avg = {}
    stable_phis_dict = {}
    stable_phis_dict_avg = {}
    stable_frequencies = []
    stable_zetas = []
    stable_phis = []


    X_bound_cov = []
    y_bound_cov = []
    z_bound_cov = []

    X_bound_cov_stable_nozeta = []
    y_bound_cov_stable_nozeta = []
    z_bound_cov_stable_nozeta = []

    X_bound_cov_stable_nozeta_nophi = []
    y_bound_cov_stable_nozeta_nophi = []
    z_bound_cov_stable_nozeta_nophi = []

    X_bound_cov_notstable = []
    y_bound_cov_notstable = []
    z_bound_cov_notstable = []


    for i in range(len(f)-1):
        f1 = f[i]
        f2 = f[i+1]

        if check_unc:
            f_c = f_cov[i+1]
            z_c = zeta_cov[i+1]
            phi_c = phi_cov[i+1]

        zeta1 = zeta[i]
        zeta2 = zeta[i+1]
        phi1 = phi[i]
        phi2 = phi[i+1]

        stable.append(torch.zeros_like(f2))
        if f1.numel() == 0 or f2.numel() == 0:
            continue
        for j2 in range(len(f2)):
            j2_f = f2[j2]
            j2_z = zeta2[j2]
            j2_ph = phi2[:,j2]

            if check_unc:
                j2_f_c = torch.sqrt(f_c[j2])
                j2_z_c = torch.sqrt(z_c[j2])
                j2_phi_c = phi_c[j2]

            for j1 in range(len(f1)):
                any_kind_of_stable = False 

                j1_f = f1[j1]
                j1_z = zeta1[j1]
                j1_ph = phi1[:,j1]

                if j2_ph.shape != j1_ph.shape:
                    continue

                mac_phi = MAC_Calculation(j2_ph,j1_ph)
                if (j1_f-j2_f)/j1_f > err_f:
                    break
                #################################################################################################
                ## For the cases all parameters are reliable
                #################################################################################################


                if torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f    and    torch.abs(j2_z-j1_z)/torch.abs(j1_z) < err_zeta  \
                 and     torch.abs(1-mac_phi) < err_phi   and   j2_z<0.1  and j2_z>0:
                    
                    # print('err_cov_phi', err_cov_phi)
                    # print('j2_phi_c', j2_phi_c)
                    # print('j2_f_c', j2_f_c)
                    if check_unc:

                        if j2_f_c < err_cov_f and j2_z_c < err_cov_zeta and j2_phi_c < err_cov_phi:
                            any_kind_of_stable = True
                            
                            stable[i][j2] = 1
                            
                            x_scatter_stable.append(j2_f)
                            y_scatter_stable.append(i+1)
                            z_scatter_stable.append(j2_z)

                            if check_unc:
                                X_bound_cov.append(j2_f_c)
                                y_bound_cov.append(i+1)
                                z_bound_cov.append(j2_z_c)


                            ph_stable.append(j2_ph)
                            if stable_frequencies_dict == {}:
                                stable_frequencies_dict.update({j2_f:1})
                                stable_frequencies_dict_avg.update({j2_f:1})
                                stable_zetas_dict_avg.update({j2_f:j2_z})
                                # stable_phis_dict_avg.update({j2_f:j2_ph})
                                stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                                is_same_freq = True
                            else:
                                stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                                for kk in stable_frequencies_dict.keys():
                                    is_same_freq = False
                                    if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                        is_same_freq = True
                                        kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                        zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                        # phi_avg_value = (stable_phis_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_ph)/(stable_frequencies_dict_avg[kk]+1)
                                        # stable_phis_dict_avg.pop(kk)
                                        # stable_phis_dict_avg.update({kk_new:phi_value_new})

                                        stable_zetas_dict_avg.pop(kk)
                                        stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                        phi_value_new = stable_phis_dict[kk].copy()
                                        phi_value_new['freq'].append(j2_f)
                                        phi_value_new['phi'].append(j2_ph)

                                        stable_phis_dict.pop(kk)
                                        stable_phis_dict.update({kk_new:phi_value_new})

                                        kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                        stable_frequencies_dict_avg.pop(kk)
                                        stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                        break
                                if not is_same_freq:
                                    # stable_phis_dict_avg.update({j2_f:j2_ph})
                                    stable_zetas_dict_avg.update({j2_f:j2_z})
                                    stable_frequencies_dict_avg.update({j2_f:1})
                                    stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})

                            break  # The pole is stable no need to check more of j1
                
                    else:
                        any_kind_of_stable = True
                            
                        stable[i][j2] = 1
                        
                        x_scatter_stable.append(j2_f)
                        y_scatter_stable.append(i+1)
                        z_scatter_stable.append(j2_z)

                        if check_unc:
                            X_bound_cov.append(j2_f_c)
                            y_bound_cov.append(i+1)
                            z_bound_cov.append(j2_z_c)


                        ph_stable.append(j2_ph)
                        if stable_frequencies_dict == {}:
                            stable_frequencies_dict.update({j2_f:1})
                            stable_frequencies_dict_avg.update({j2_f:1})
                            stable_zetas_dict_avg.update({j2_f:j2_z})
                            # stable_phis_dict_avg.update({j2_f:j2_ph})
                            stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})
                            is_same_freq = True
                        else:
                            stable_frequencies_dict = stable_frequencies_dict_avg.copy()
                            for kk in stable_frequencies_dict.keys():
                                is_same_freq = False
                                if torch.abs(j2_f-kk)/torch.abs(kk) < err_f:
                                    is_same_freq = True
                                    kk_new = (kk*stable_frequencies_dict_avg[kk]+j2_f) / (stable_frequencies_dict_avg[kk] + 1)
                                    zeta_avg_value = (stable_zetas_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_z)/(stable_frequencies_dict_avg[kk]+1)

                                    # phi_avg_value = (stable_phis_dict_avg[kk] * stable_frequencies_dict_avg[kk] + j2_ph)/(stable_frequencies_dict_avg[kk]+1)
                                    # stable_phis_dict_avg.pop(kk)
                                    # stable_phis_dict_avg.update({kk_new:phi_value_new})

                                    stable_zetas_dict_avg.pop(kk)
                                    stable_zetas_dict_avg.update({kk_new:zeta_avg_value})

                                    phi_value_new = stable_phis_dict[kk].copy()
                                    phi_value_new['freq'].append(j2_f)
                                    phi_value_new['phi'].append(j2_ph)

                                    stable_phis_dict.pop(kk)
                                    stable_phis_dict.update({kk_new:phi_value_new})

                                    kk_new_value = stable_frequencies_dict_avg[kk] + 1
                                    stable_frequencies_dict_avg.pop(kk)
                                    stable_frequencies_dict_avg.update({kk_new:kk_new_value})
                                    break
                            if not is_same_freq:
                                # stable_phis_dict_avg.update({j2_f:j2_ph})
                                stable_zetas_dict_avg.update({j2_f:j2_z})
                                stable_frequencies_dict_avg.update({j2_f:1})
                                stable_phis_dict.update({j2_f:{'freq':[j2_f],'phi':[j2_ph]}})

                        break  # The pole is stable no need to check more of j1
                
                #################################################################################################
                ## For the cases that damping ratios are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f  and torch.abs(1-mac_phi) < err_phi and j2_z>0:
                    if check_unc:

                        if j2_f_c < err_cov_f and j2_phi_c < err_cov_phi:

                            any_kind_of_stable = True
                            x_scatter_stable_noZeta.append(j2_f)
                            y_scatter_stable_noZeta.append(i+1)
                            if check_unc:
                                X_bound_cov_stable_nozeta.append(j2_f_c)
                                y_bound_cov_stable_nozeta.append(i+1)
                                z_bound_cov_stable_nozeta.append(j2_z_c)

                            ph_stable_noZeta.append(j2_ph)
                            break
                    else:
                        any_kind_of_stable = True
                        x_scatter_stable_noZeta.append(j2_f)
                        y_scatter_stable_noZeta.append(i+1)
                        if check_unc:
                            X_bound_cov_stable_nozeta.append(j2_f_c)
                            y_bound_cov_stable_nozeta.append(i+1)
                            z_bound_cov_stable_nozeta.append(j2_z_c)

                        ph_stable_noZeta.append(j2_ph)
                        break
                #################################################################################################
                ## For the cases that damping ratios and mode shapes are not very reliable
                #################################################################################################
                elif torch.abs(j2_f-j1_f)/torch.abs(j1_f) < err_f and j2_z>0:
                    if check_unc:
                    
                        if j2_f_c < err_cov_f:
                            any_kind_of_stable = True
                            x_scatter_stable_noZeta_noPhi.append(j2_f)
                            y_scatter_stable_noZeta_noPhi.append(i+1)
                            if check_unc:
                                X_bound_cov_stable_nozeta_nophi.append(j2_f_c)
                                y_bound_cov_stable_nozeta_nophi.append(i+1)
                                z_bound_cov_stable_nozeta_nophi.append(j2_z_c)
                            break
                    else:
                        any_kind_of_stable = True
                        x_scatter_stable_noZeta_noPhi.append(j2_f)
                        y_scatter_stable_noZeta_noPhi.append(i+1)
                        if check_unc:
                            X_bound_cov_stable_nozeta_nophi.append(j2_f_c)
                            y_bound_cov_stable_nozeta_nophi.append(i+1)
                            z_bound_cov_stable_nozeta_nophi.append(j2_z_c)
                        break
                        
            if not any_kind_of_stable:
                x_scatter_not_stable.append(j2_f)
                y_scatter_not_stable.append(i+1)
                if check_unc:
                    X_bound_cov_notstable.append(j2_f_c)
                    y_bound_cov_notstable.append(i+1)
                    z_bound_cov_notstable.append(j2_z_c)

        stable[i] = list(map(bool, stable[i]))

    ###############################################################################################
    # A loop for adding stable poles with number more than a limit to a list as natural frequencies
    ###############################################################################################
    how_many_stable_poles = Num_Poles
    for kk in stable_frequencies_dict_avg.keys():
        if stable_frequencies_dict_avg[kk]>=how_many_stable_poles and kk not in stable_frequencies:
            stable_frequencies.append(kk)
            stable_zetas.append(stable_zetas_dict_avg[kk])

            ## Finding the stable pole having the nearest frequency to the mean frequency
            diff_freq = np.asarray(stable_phis_dict[kk]['freq']) - np.asarray(kk)
            min_diff_freq_idx = np.argmin(diff_freq)
            stable_phis.append(stable_phis_dict[kk]['phi'][min_diff_freq_idx])

    sorted_idx = np.argsort(np.array(stable_frequencies))
    stable_zetas_sorted_by_freq = []
    stable_phis_sorted_by_freq = []
    for i in sorted_idx:
        stable_zetas_sorted_by_freq.append(stable_zetas[i])
        stable_phis_sorted_by_freq.append(stable_phis[i])


    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []
    for mode in range(len(stable_phis_sorted_by_freq)):
        Mode_shapes_phase.append(torch.angle(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_amp.append(torch.abs(stable_phis_sorted_by_freq[mode]))
        Mode_shapes_sign.append(torch.sign(torch.cos(Mode_shapes_phase[mode]-Mode_shapes_phase[mode][0])))
        Mode_shapes.append(Mode_shapes_sign[mode]*Mode_shapes_amp[mode] / torch.max(Mode_shapes_amp[mode]))


    stable_frequencies.sort()
    return {'x_NS':x_scatter_not_stable, 'y_NS':y_scatter_not_stable, 'x_S':x_scatter_stable, 'y_S':y_scatter_stable, 'z_S':z_scatter_stable, 'ph_stable':ph_stable, \
            'x_S_noZeta':x_scatter_stable_noZeta, 'y_S_noZeta':y_scatter_stable_noZeta, 'ph_stable_noZeta':ph_stable_noZeta, \
            'x_S_noZeta_noPhi':x_scatter_stable_noZeta_noPhi, 'y_S_noZeta_noPhi':y_scatter_stable_noZeta_noPhi, \
            'X_bound_cov':X_bound_cov, 'y_bound_cov':y_bound_cov, 'z_bound_cov': z_bound_cov, \
            'X_bound_cov_stable_nozeta':X_bound_cov_stable_nozeta, 'y_bound_cov_stable_nozeta':y_bound_cov_stable_nozeta, 'z_bound_cov_stable_nozeta': z_bound_cov_stable_nozeta, \
            'X_bound_cov_stable_nozeta_nophi':X_bound_cov_stable_nozeta_nophi, 'y_bound_cov_stable_nozeta_nophi':y_bound_cov_stable_nozeta_nophi, 'z_bound_cov_stable_nozeta_nophi': z_bound_cov_stable_nozeta_nophi, \
            'X_bound_cov_notstable':X_bound_cov_notstable, 'y_bound_cov_notstable':y_bound_cov_notstable, 'z_bound_cov_notstable': z_bound_cov_notstable}, \
     {'frequencies':stable_frequencies, 'damping_ratios':stable_zetas_sorted_by_freq, 'mode_shapes':Mode_shapes}

"""# Diagrams

## Stabilization Diagram
"""
def fix_coord_dict(input_dict):
    # Dictionary with all possible keys
    all_keys = {'x_NS', 'y_NS', 'x_S', 'y_S', 'z_S', 'ph_stable',
                'x_S_noZeta', 'y_S_noZeta', 'ph_stable_noZeta',
                'x_S_noZeta_noPhi', 'y_S_noZeta_noPhi',
                'X_bound_cov', 'y_bound_cov', 'z_bound_cov',
                'X_bound_cov_stable_nozeta', 'y_bound_cov_stable_nozeta', 'z_bound_cov_stable_nozeta',
                'X_bound_cov_stable_nozeta_nophi', 'y_bound_cov_stable_nozeta_nophi', 'z_bound_cov_stable_nozeta_nophi',
                'X_bound_cov_notstable', 'y_bound_cov_notstable', 'z_bound_cov_notstable'}

    # Iterate over all possible keys and check if they're in the input dictionary
    copy_dict = input_dict.copy()
    for key in all_keys:
        if key not in input_dict:
            copy_dict[key] = []  # If key is missing, add it with an empty list

    return copy_dict

def stabilization_diagram(Coord_dict, Stable_frequencies, Stable_zetas, without_mode_shape=False, add_damping_indicator=False, xlim=0, ylim=0, scale_unc=1.,
                          damp_ylim=0, add_PSD_SVD=False, f_psd=[], ss1=[], show_second_singular_value=False, show_title=False, only_show_stable=False, draw_unc=False):
    """
        This function is a general function to plot stabilization diagram.

        :param Coord_dict: Information about poles (Output of methods like SSI, PolyMAX, and ITD)
        :param Stable_frequencies: A list of physical modes' frequencies
        :param Stable_zetas: A list of physical modes' damping ratios
        :param without_mode_shape: A bool value, if True the mode shapes are not considered (suitable for ITD and PolyMAX).
        :param add_damping_indicator: A bool value, if True some text indicator will be shown.
        :param xlim: A list of two numbers indicating the xlim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete xlim)
        :param ylim: A list of two numbers indicating the ylim of the stabilization diagram. (e.g. [2,10]) (0 acts as the complete ylim)
        :param damp_ylim: A list of two numbers indicating the ylim of the damping ratio plot. (e.g. [2,10]) (0 acts as the complete ylim)
        :param add_PSD_SVD: A bool value, if True first singular value diagram will be shown behind the stabilization diagram.
        :param f_psd: If add_PSD_SVD=True, a frequency domain's array must be provided.
        :param ss1: If add_PSD_SVD=True, an SVD of PSD array must be provided.
    """

    if 'x_S_noZeta_noPhi' not in Coord_dict.keys():
        without_mode_shape = True

    Coord_dict = fix_coord_dict(Coord_dict)

    if Coord_dict['X_bound_cov_notstable'] == [] and draw_unc:
        draw_unc = False
        print('There is no uncertainty information available!')


    
    if without_mode_shape:
        if not add_PSD_SVD:
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # ax1 = axis[0]
            # ax2 = axis[1]

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')
            
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim) 
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)

            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)
            # plt.show()

            # plt.subplot(2,1,2)
            fig_total, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)

            ax2.grid()
            # plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:orange',
                            label='Stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            # ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color ='tab:orange', label='Only stable in freq')
            scatt3 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('Singular values of PSD (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                # plt1_2.set_zorder(0.5)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(which='both')

            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3] ,framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))


            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis
            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)
            
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)

            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid(which='both')
            plt.show()
    else:
        if not add_PSD_SVD:
            # fig_total, axis = plt.subplots(2, 1, figsize=(10, 10))
            #
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig_total, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            # plt.subplot(2,1,1)
            if not only_show_stable:
                ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')

            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+Coord_dict['X_bound_cov'][i]*scale_unc, Coord_dict['x_S'][i]-Coord_dict['X_bound_cov'][i]*scale_unc]
                if draw_unc:
                    ax1.plot(x_plot_cov, y_plot_cov, 'b-')

            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            ax1.grid()
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order')
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.13)
            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()
            leg = ax1.legend(framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.18), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)


            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.08)

            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                plt.ylim([0, 10])
            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))
            # ax2.grid()
            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.grid(visible=True, axis='x')
            ax2.grid(visible=True, which='both', axis='y')
            plt.show()

        ########################################################################################################################
        elif add_PSD_SVD:
            # fig, axis = plt.subplots(2, 1, figsize=(10, 10))
            # ax1 = axis[0]
            # ax2 = axis[1]
            fig, ax1 = plt.subplots(1, 1, figsize=(10, 7))

            #  = plt.subplots()
            color = 'black'
            if show_title:
                ax1.set_title('Natural Frequencies (Stable Poles)')
            else:
                ax1.set_title(' ', y=1.3)
            ax1.set_xlabel('Frequency (Hz)')
            ax1.set_ylabel('Order', color=color)
            if not only_show_stable:
                scatt1 = ax1.scatter(Coord_dict['x_NS'], Coord_dict['y_NS'], marker='*', color='tab:red', s=2, alpha=0.3,
                            label='Not stable')
                scatt2 = ax1.scatter(Coord_dict['x_S_noZeta'], Coord_dict['y_S_noZeta'], marker='o', color='tab:blue',
                            label='Stable in freq and mac')
                scatt3 = ax1.scatter(Coord_dict['x_S_noZeta_noPhi'], Coord_dict['y_S_noZeta_noPhi'], marker='o', color='tab:orange',
                            label='Only stable in freq')
            else:
                scatt1 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt2 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
                scatt3 = ax1.scatter([], [], marker='*', color='tab:red', s=2, alpha=0.3, label='Not stable')
            scatt4 = ax1.scatter(Coord_dict['x_S'], Coord_dict['y_S'], marker='o', color='tab:green', label='Fully stable')


            COV_TOL = 1e10
            for i in range(len(Coord_dict['X_bound_cov'])):
                y_plot_cov = [Coord_dict['y_bound_cov'][i], Coord_dict['y_bound_cov'][i]]
                x_plot_cov = [Coord_dict['x_S'][i]+np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc, Coord_dict['x_S'][i]-np.sqrt(Coord_dict['X_bound_cov'][i])*scale_unc]
                if Coord_dict['X_bound_cov'][i] < COV_TOL:
                    if draw_unc:
                        ax1.plot(x_plot_cov, y_plot_cov, color='tab:green')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta'][i], Coord_dict['y_bound_cov_stable_nozeta'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc, Coord_dict['x_S_noZeta'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:blue')

            # for i in range(len(Coord_dict['X_bound_cov_stable_nozeta_nophi'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_stable_nozeta_nophi'][i], Coord_dict['y_bound_cov_stable_nozeta_nophi'][i]]
            #     x_plot_cov = [Coord_dict['x_S_noZeta_noPhi'][i]+np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc, Coord_dict['x_S_noZeta_noPhi'][i]-np.sqrt(Coord_dict['X_bound_cov_stable_nozeta_nophi'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_stable_nozeta_nophi'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:orange')

            # for i in range(len(Coord_dict['X_bound_cov_notstable'])):
            #     y_plot_cov = [Coord_dict['y_bound_cov_notstable'][i], Coord_dict['y_bound_cov_notstable'][i]]
            #     x_plot_cov = [Coord_dict['x_NS'][i]+np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc, Coord_dict['x_NS'][i]-np.sqrt(Coord_dict['X_bound_cov_notstable'][i])*scale_unc]
            #     if Coord_dict['X_bound_cov_notstable'][i] < COV_TOL:
            #         if draw_unc:
            #             ax1.plot(x_plot_cov, y_plot_cov, color='tab:red')

            ax1.tick_params(axis='y', labelcolor=color)

            ax1_2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax1_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax1_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax1_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax1_2.add_artist(plot_2_singular_value)
                leg_svd = ax1.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax1_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax1_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax1_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax1.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.165), ncol=2, title='Legend of singular values')
                ax1.add_artist(leg_svd)

            ax1.grid(visible=True, axis='x')
            ax1.grid(visible=True, which='both', axis='y')
            ax1.minorticks_on()


            fig.tight_layout()  # otherwise the right y-label is slightly clipped
            if xlim != 0:
                ax1.set_xlim(xlim)
            if ylim != 0:
                ax1.set_ylim(ylim)
            leg = ax1.legend(handles=[scatt1, scatt2, scatt3, scatt4], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.37), ncol=2, title='Legend of poles')
            leg.set_zorder(5)
            ax1.add_artist(leg)

            fig, ax2 = plt.subplots(1, 1, figsize=(10, 7))

            scatt_s = ax2.scatter(np.array(Coord_dict['x_S']), 100 * np.array(Coord_dict['z_S']), marker='*', color='tab:green', label='Stable poles')

            ax2_2 = ax2.twinx()  # instantiate a second Axes that shares the same x-axis

            color = 'tab:blue'
            if np.mean(ss1[:, 0]) > 0:
                ax2_2.set_ylabel(r'SVD(PSD) $(m^2/s^3)$', color=color)  # we already handled the x-label with ax1
            else:
                ax2_2.set_ylabel(r'$10\log$(SVD(PSD)) (dB)', color=color)  # we already handled the x-label with ax1

            if show_second_singular_value:
                color = 'tab:blue'
                # ax1_2.set_ylabel('log(SVD of Power Spectral Density) (dB)',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5,alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)

                color = 'cyan'
                plot_2_singular_value, = ax2_2.plot(f_psd, ss1[:, 1], color=color, zorder=0.5,alpha=0.3, label='Second singular value')
                ax2_2.add_artist(plot_2_singular_value)
                leg_svd = ax2.legend(handles=[plot_singular_value, plot_2_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

                # plt1_2.set_zorder(0.5)
            else:
                color = 'tab:blue'
                # ax1_2.set_ylabel('First singular value',color=color)  # we already handled the x-label with ax1
                plot_singular_value, = ax2_2.plot(f_psd, ss1[:, 0], color=color, zorder=0.5, alpha=0.3, label='First singular value')
                ax2_2.add_artist(plot_singular_value)
                # plt1_2.set_zorder(0.5)
                ax2_2.tick_params(axis='y', labelcolor=color)
                leg_svd = ax2.legend(handles=[plot_singular_value], framealpha=1., loc='upper center', bbox_to_anchor=(0.5, 1.13), ncol=2, title='Legend of singular values')
                ax2.add_artist(leg_svd)

            if show_title:
                ax2.set_title('Damping Ratio/Frequency')
            else:
                ax2.set_title(' ', y=1.2)
            ax2.set_xlabel('Frequency (Hz)')
            ax2.set_ylabel('Damping Ratio (%)')
            if xlim != 0:
                ax2.set_xlim(xlim)
            else:
                ax2.set_xlim(ax1.get_xlim())
            if damp_ylim != 0:
                ax2.set_ylim(damp_ylim)
            else:
                ax2.set_ylim([0, 10])

            ylim_get = ax2.get_ylim()
            xlim_get = ax2.get_xlim()
            relative_anotator_x = (xlim_get[1] - xlim_get[0]) / 5
            relative_anotator_y = (ylim_get[1] - ylim_get[0]) / 9
            scatt_p = 0
            for i in range(len(Stable_frequencies)):
                ax2.plot([Stable_frequencies[i].numpy(), Stable_frequencies[i].numpy()], ylim_get, '--k', alpha=0.4)
                ax2.plot(xlim_get, [100 * Stable_zetas[i].numpy(), 100 * Stable_zetas[i].numpy()], '--k', alpha=0.4)
                scatt_p = ax2.scatter([Stable_frequencies[i].numpy()], [100 * Stable_zetas[i].numpy()], s=100, marker='+',
                            color='r', label='Final extracted modes')
                if add_damping_indicator:
                    ax2.annotate(
                        f"Frequency: {'{:.2f}'.format(Stable_frequencies[i])}Hz\nDamping: {'{:.2f}'.format(100 * Stable_zetas[i].numpy())}%",
                        xy=(Stable_frequencies[i], 100 * Stable_zetas[i].numpy()), xytext=(
                            Stable_frequencies[i] - relative_anotator_x,
                            100 * Stable_zetas[i].numpy() - relative_anotator_y),
                        arrowprops=dict(facecolor='black', shrink=0.003))

            if scatt_p == 0:
                leg = ax2.legend(handles=[scatt_s], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            else:
                leg = ax2.legend(handles=[scatt_s, scatt_p], framealpha=1.,loc='upper center', bbox_to_anchor=(0.5, 1.25), ncol=2, title='Legend of poles')
            ax2.add_artist(leg)
            ax2.tick_params()
            ax2.grid()
            # ax2.grid(visible=True,axis='x')
            # ax2.grid(visible=True,which='both',axis='y')
            plt.show()

"""## Mode shape diagram

### Farrar mode shape function
"""

def Farrar_Mode_shape_diagram(Mode_shapes):
    number_dof = len(Mode_shapes[0])
    fig, axis = plt.subplots(1, len(Mode_shapes), sharey=True, figsize=(8, 5))
    ax1 = axis[0]
    plt.subplots_adjust(wspace=0.5, hspace=0.5)
    Points = []
    for i in range(len(Mode_shapes)):
        Points.append({'x':[], 'y':list(range(1,number_dof+1))})

    for j in range(len(Mode_shapes)):
        plt.subplot(1, len(Mode_shapes), j+1)

        for i in range(number_dof):
            Points[j]['x'].append(Mode_shapes[j][i])
            if i == 0:
                continue
            plt.plot([Points[j]['x'][i],Points[j]['x'][i-1]], [Points[j]['y'][i], Points[j]['y'][i-1]],'-bo', markersize = 6 )
            plt.plot([0, 0], [Points[j]['y'][i], Points[j]['y'][i-1]],'-mo', markersize = 6 )
            plt.ylabel('Floors')
            plt.xlabel('Relative displacement')
            plt.legend([f'mode {j+1}', 'Undamaged'], framealpha=0.9,zorder=5,loc='best')
            plt.xlim([-1.1,1.1])
            plt.ylim([0.8,4.3])

        plt.grid()
        # Set the y-axis ticks to be at every integer value
    ax1.set_yticks(range(0, number_dof+1, 1))

    # Format the y-axis labels to remove the decimal part
    ax1.set_yticklabels(['{:.0f}'.format(y) for y in range(0, number_dof+1, 1)])
    plt.show()

"""### Italy Bridge 2 mode shape function"""

def Bridge2_Mode_shape_diagram(Mode_shapes):
    alpha = np.pi/9
    beta = np.pi/6
    L1 = 12
    # L2_dis = [15,2,14,14,2,15,15,0,-15,-15,-2,-14,-14,-2,-15]
    # L2 = [15]
    # for i in range(len(L2_dis)):
    #     L2.append(L2[-1]+L2_dis[i])
    L2 = [13.5, 22.5, 30.5, 44.5, 58.5, 66.5, 75.5, 89, 89, 75.5, 66.5, 58.5, 44.5, 30.5, 22.5, 13.5]
    P_plot = {'x':[],'y':[]}
    S_plot = []
    for i in range(16): # THIS PLOT CAN BE DRAWN BY 16 POINTS + 2 REFRENCE POINTS
        S_plot.append({'x':[],'y':[]})
    Alt_MSh_Still = np.zeros(16) # Altered Mode Shape
    Alt_MSh = np.zeros((len(Mode_shapes),16)) # Altered Mode Shape
    for i in range(len(Mode_shapes)):
        Alt_MSh[i,[0,2,3,4,6,11,12,13]] = Mode_shapes[i][[3,1,0,2,4,7,5,6]]



    A_Coord = L1*np.array([np.sin(alpha), 0])
    B_Coord = L1*np.array([0, np.cos(alpha)])

    LinkLine = np.zeros((16, len(Mode_shapes), 2, 2))

    S = np.zeros((16, len(Mode_shapes), 2))
    scale_factor = 10 # Mode Shape scalar ###################
    for j in range(len(Mode_shapes)):
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])
        for i in range(8):
            S[i,j,:] = A_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)]) + scale_factor*np.array([0, Alt_MSh[j,i]])
            LinkLine[i,j,0,:] = A_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
        for i in range(8,16):
            S[i,j,:] = B_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)]) + scale_factor*np.array([0, Alt_MSh[j,i]])
            LinkLine[i,j,0,:] = B_Coord + L2[i]*np.array([np.cos(beta), np.sin(beta)])
            LinkLine[i,j,1,:] = S[i,j,:]
            S_plot[j]['x'].append(S[i,j,0])
            S_plot[j]['y'].append(S[i,j,1])
            P_plot['x'].append(LinkLine[i,j,0,0])
            P_plot['y'].append(LinkLine[i,j,0,1])
        S_plot[j]['x'].append(B_Coord[0])
        S_plot[j]['y'].append(B_Coord[1])
        S_plot[j]['x'].append(A_Coord[0])
        S_plot[j]['y'].append(A_Coord[1])
        P_plot['x'].append(B_Coord[0])
        P_plot['y'].append(B_Coord[1])
        P_plot['x'].append(A_Coord[0])
        P_plot['y'].append(A_Coord[1])


    fig, axis = plt.subplots(len(Mode_shapes),1,sharex=True, sharey=True, figsize=(10, 10))
    plt.subplots_adjust(wspace=0.2, hspace=0.2)
    for j in range(len(Mode_shapes)):
        plt.subplot(len(Mode_shapes), 1, j+1)
        ax1 = plt.gca()
        ax1.set_yticks([])
        ax1.set_xticks([])
        for i in range(len(P_plot['x'])):
            x = P_plot['x'][i]
            y = P_plot['y'][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-r')

            x_old = x
            y_old = y
        for i in range(len(S_plot[j]['x'])):
            x = S_plot[j]['x'][i]
            y = S_plot[j]['y'][i]
            if i == 0:
                x_old = x
                y_old = y
                continue
            plt.plot([x_old,x],[y_old,y], '-b', linewidth=.7)

            x_old = x
            y_old = y
        for i in range(16):
            plt.plot([LinkLine[i,j,0,0],LinkLine[i,j,1,0]],[LinkLine[i,j,0,1],LinkLine[i,j,1,1]], '-m', linewidth=.5)
            if Alt_MSh[j,i] != 0:
                x_text = (LinkLine[i,j,0,0]+LinkLine[i,j,1,0])/2
                y_text = (LinkLine[i,j,0,1]+LinkLine[i,j,1,1])/2
                plt.text(x_text, y_text, f"{'{:.2f}'.format(Alt_MSh[j,i])}", fontsize = 'small')

    plt.show()

"""# Full SSI Alg"""

def SSI_Alg(y,order,lag,dt,criteria = [0.01, 0.05, 0.02],alg='cov',method=1, nb=10, Num_poles_to_accept_a_mode='auto',uncertainty=False,unc_criteria=[]):
    """
    :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
    :param order: Maximum state space model order for the SSI method.
    :param lag: Maximum lag for 'cov' algorithm and number of block rows for 'data' algorithm.
    :param dt: Time Resolution
    :param criteria: Criteria for considering a pole stable (e.g. [error of frequency, error of damping ratio, error of mode shape]).
    :param alg: ('data' or 'cov' or 'cva')
    :param method: (1 or 2) for 'cov' algorithm.
    :param Num_poles_to_accept_a_mode: Number of found stable modes in a frequency line to consider a mode physical.
    :param uncertainty: If True and alg=='cov', the algorithm compute the uncertainty of the estimated parameters. 
    :param unc_criteria: Criteria for considering a pole stable (using the covariance bound calculated for uncertainty calculation).
    :return:
        Coord_dict: Information about poles (Output of methods like SSI, PolyMAX, and ITD)
        - Stable_frequencies: A list of physical modes' frequencies
        - Stable_zetas: A list of physical modes' damping ratios
        - Stable_phis: A list of physical modes' mode shapes
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if isinstance(y, pd.DataFrame):
        y = np.asarray(y)
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0,1)
    if Num_poles_to_accept_a_mode=='auto':
        Num_Poles = int(order // 5)
    else:
        Num_Poles = Num_poles_to_accept_a_mode
    
    if uncertainty:
        if alg=='cov':
            Coord_dict, Modal_info, Unc_info  = SSI_COV_UNC(y,dt,nb,order,lag,criteria,Num_Poles,unc_criteria=unc_criteria)
            Stable_frequencies, Stable_zetas, Stable_phis = Modal_info.values()
            freq_cov, zeta_cov, phi_cov = Unc_info.values()

        else:
            print("For uncertainty computation, the alg should be 'cov'.")
    else:
        if alg=='cov':
            A, C, _, _ = SSI_COV(y, order, lag, method=method)
        elif alg=='cva':
            A, C, _, _ = SSI_COV_CVA(y, order, lag, method=method)
        elif alg=='data':
            num_block_rows = lag
            A, C = SSI_DATA(y, order, num_block_rows)
            # print(A)
        f, zeta, phi, _, _, _ = modal_parameters(A,C,dt)
        # print(f,zeta,phi)
        # [0.01, 0.05, 0.02]
        Coord_dict, Modal_info = Stable_Poles(f,zeta,phi,criteria,Num_Poles,check_unc=False)
        Stable_frequencies, Stable_zetas, Stable_phis = Modal_info.values()

    return Coord_dict, Stable_frequencies, Stable_zetas, Stable_phis

"""# PSD and SVD of PSD function

## PSD
"""

def scientific_formatter(x, pos):
    return f"$10^{{{int(x)}}}$"


def scientific_formatter(x, pos):
    return f"$10^{{{int(x)}}}$"


def psd_func(y, dt, nseg=2, pov=0.5, window='hann', show_semilog=False, show_plot=True):
    """
        A function to calculate the PSD of the signals.

        :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
        :param dt: Time Resolution
        :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
        :param nseg: Number of segments in Welch's method
        :param pov: Percent of overlap
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.

        :return:
            PSD Matrix
            - Frequency domain's array
            - Number of the time steps in each segment
            - Number of channels
            - Time domain's array
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)

    fs = 1 / dt
    n_row, n_col = y.shape

    Num_points = 2 ** int(np.ceil(np.log2(n_col)))
    y = np.concatenate((y, np.zeros((y.shape[0], Num_points - y.shape[1]))), axis=1)

    T_MAX_new = Num_points * dt
    delta_f_new = 1 / T_MAX_new
    nxseg = int(Num_points // nseg)  # number of points in every segment

    noverlap = int(nxseg // (1 / pov))  # Number of overlapping points
    PSD_Mat = np.zeros((nxseg // 2 + 1, n_row, n_row), dtype=complex)

    for i in range(n_row):
        for j in range(n_row):
            f_psd, PSD_Mat[:, i, j] = csd(y[i, :], y[j, :], fs=fs, window=window, nperseg=nxseg, noverlap=noverlap)

    if show_plot:

        fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

        fig_total.suptitle('Power Spectral Density')

        ax1 = axis[0]
        ax2 = axis[1]

        for i in range(n_row):
            ax1.plot(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
        ax1.set_title(f'PSD')
        # ax1.legend()
        ax1.grid()
        ax1.set_xlabel('Frequency(Hz)')
        ax1.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')

        # plt.figure(figsize=(10, 6))

        if not show_semilog:
            for i in range(n_row):
                ax2.plot(f_psd.real, 10 * np.log10(PSD_Mat[:, i, i].real).real, label=f'channel{i + 1}')
            # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.set_title(r'$10\log$(PSD)')
            # ax2.legend()
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('log(Power Spectral Density) (dB)')

        else:
            for i in range(n_row):
                ax2.semilogy(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.set_title(r'PSD')
            # ax2.legend()
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')
        plt.show()

    return torch.tensor(PSD_Mat, dtype=torch.complex64), torch.tensor(f_psd, dtype=torch.complex64)

"""## Singular value decomposition of PSD"""

def svd_psd(PSD_mat, f_psd, show_semilog=False, show_plot=True):
    """
        A function to calculate the SVD of PSD.

        :param PSD_mat: A 3D PyTorch tensor (PSD Matrix) (Output of psd_func function)
        :param f_psd: A 1D PyTorch tensor (Frequency domain's array) (Output of psd_func function)
        :param nxseg: Number of the time steps in each segment (Output of psd_func function)
        :param num_chnl: Number of channels (Output of psd_func function)
        :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.
        :return:
            ss1: Singular Values
            - UU: Singular Vectors
    """
    nxseg = PSD_mat.shape[0]
    num_chnl = PSD_mat.shape[1]

    ss1 = np.zeros((PSD_mat.shape[0], num_chnl))
    UU = np.zeros((num_chnl, num_chnl, PSD_mat.shape[0]), dtype=complex)
    for kk in range(PSD_mat.shape[0]):
        UU1, SS1, _ = np.linalg.svd(PSD_mat[kk])
        ss1[kk, :] = abs(SS1)
        UU[:, :, kk] = UU1[:, :]

    if show_plot:

        fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

        ax1 = axis[0]
        ax2 = axis[1]

        fig_total.suptitle('First three singular values of PSD')
        if ss1.shape[1] >= 3:
            num_singular_val = 3
        else:
            num_singular_val = ss1.shape[1]

        for i in range(num_singular_val):
            ax1.plot(f_psd.real, ss1[:, i].real, label=f'singular value number {i + 1}')
        ax1.grid()
        ax1.legend(framealpha=0.9)
        ax1.set_title(f'SVD(PSD)')
        ax1.set_xlabel('Frequency(Hz)')
        ax1.set_ylabel(r'SVD of Power Spectral Density ($m^2/s^3$)')

        if show_semilog:
            for i in range(num_singular_val):
                ax2.semilogy(f_psd.real, ss1[:, i].real, label=f'singular value number {i + 1}')
                # ax2.plot(f_psd, 10*np.log10(ss1[:,i]), label=f'singular value number {i+1}')
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.legend(framealpha=0.9)
            ax2.set_title(r'SVD(PSD)')

            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('SVD of Power Spectral Density ($m^2/s^3$)')
        else:
            for i in range(num_singular_val):
                ax2.plot(f_psd.real, 10 * np.log10(ss1[:, i].real).real, label=f'singular value number {i + 1}')
            # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
            ax2.minorticks_on()
            ax2.grid(True)
            ax2.grid(True, which='minor', axis='y')

            ax2.legend(framealpha=0.9)
            ax2.set_title(r'SVD(PSD)')

            ax2.set_title(r'$10\log$(SVD(PSD))')
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('log(SVD of Power Spectral Density) (dB)')
        plt.show()

    return ss1, UU

