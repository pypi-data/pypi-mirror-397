# -*- coding: utf-8 -*-
"""FDD_EFDD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZbFFi_I-IIxXYyiRBpBS6-5v_pU7Yian

# Importing Modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import scipy
from scipy.signal import butter, filtfilt
from scipy.signal import welch, csd, find_peaks
from scipy.linalg import svd

# !pip install plotly
import plotly.express as px
import datetime
import torch
from matplotlib.ticker import FuncFormatter, LogLocator

"""# PSD and SVD of PSD function

## PSD
"""

def scientific_formatter(x, pos):
    return f"$10^{{{int(x)}}}$"


def psd_func_EFDD(y, dt, window='hann', nseg=2, pov=0.5, show_semilog=False, xlim=0, ylim=0):
    """
    A function to calculate the PSD of the signals.

    :param y: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
    :param dt: Time Resolution
    :param window: Window type in the Welch's method (e.g. 'hann', 'bohman', 'hamming')
    :param nseg: Number of segments in Welch's method
    :param pov: Percent of overlap
    :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.

    :return:
        PSD Matrix
        - Frequency domain's array
        - Number of the time steps in each segment
        - Number of channels
        - Time domain's array
    """
    if isinstance(y, np.ndarray):
        y = torch.tensor(np.asarray(y).copy())
    if y.shape[0] > y.shape[1]:
        y = torch.transpose(y, 0, 1)

    Tmax = dt * y.shape[1]
    t = np.arange(dt, Tmax, dt) # time array

    fs = 1 / dt
    n_row, n_col = y.shape

    if np.round(np.log2(n_col)) > np.floor(np.log2(n_col)):
        Num_points = 2 ** int(np.round(np.log2(n_col)))
        y = np.concatenate((y, np.zeros((y.shape[0], Num_points - y.shape[1]))), axis=1)
    else:
        Num_points = int(2 ** int(np.floor(np.log2(n_col))))
        y = y[:, 0:Num_points]
    T_MAX_new = Num_points * dt
    delta_f_new = 1 / T_MAX_new
    nxseg = int(Num_points // nseg)  # number of points in every segment

    noverlap = int(nxseg // (1 / pov))  # Number of overlapping points
    PSD_Mat = np.zeros((nxseg // 2 + 1, n_row, n_row), dtype=complex)

    for i in range(n_row):
        for j in range(n_row):
            f_psd, PSD_Mat[:, i, j] = csd(y[i, :], y[j, :], fs=fs, window=window, nperseg=nxseg, noverlap=noverlap)

    fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

    fig_total.suptitle('Power Spectral Density')

    ax1 = axis[0]
    ax2 = axis[1]

    for i in range(n_row):
        ax1.plot(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
    ax1.set_title(f'PSD')
    # ax1.legend()
    if xlim != 0:
        ax1.set_xlim([xlim[0], xlim[1]])
        
    ax1.grid(color='gray', alpha=0.4)
    ax1.set_xlabel('Frequency(Hz)')
    ax1.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')

    # plt.figure(figsize=(10, 6))

    if not show_semilog:
        for i in range(n_row):
            ax2.plot(f_psd.real, 10 * np.log10(PSD_Mat[:, i, i].real), label=f'channel{i + 1}')
        # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
        ax2.minorticks_on()
        ax2.grid(True, color='gray', alpha=0.4)
        ax2.grid(True, which='minor', axis='y', color='gray', alpha=0.4)

        ax2.set_title(r'$10\log$(PSD)')
        if xlim != 0:
            ax2.set_xlim([xlim[0], xlim[1]])
        if ylim != 0:
            ax2.set_ylim([ylim[0], ylim[1]])
        # ax2.legend()
        ax2.set_xlabel('Frequency(Hz)')
        ax2.set_ylabel('log(Power Spectral Density) (dB)')

    else:
        for i in range(n_row):
            ax2.semilogy(f_psd.real, PSD_Mat[:, i, i].real, label=f'channel{i + 1}')
        ax2.minorticks_on()
        ax2.grid(True, color='gray', alpha=0.4)
        ax2.grid(True, which='minor', axis='y', color='gray', alpha=0.4)

        ax2.set_title(r'PSD')
        if xlim != 0:
            ax2.set_xlim([xlim[0], xlim[1]])

        if ylim != 0:
            ax2.set_ylim([10**(ylim[0]/10), 10**(ylim[1]/10)])
        # ax2.legend()
        ax2.set_xlabel('Frequency(Hz)')
        ax2.set_ylabel(r'Power Spectral Density ($m^2/s^3$)')
    plt.show()

    return torch.tensor(PSD_Mat, dtype=torch.complex64), torch.tensor(f_psd, dtype=torch.complex64), t

"""## Singular value decomposition of PSD"""

def svd_psd(PSD_mat, f_psd, show_semilog=False, xlim=0, show_plot=True):
    """
    A function to calculate the SVD of PSD.

    :param PSD_mat: A 3D PyTorch tensor (PSD Matrix) (Output of psd_func function)
    :param f_psd: A 1D PyTorch tensor (Frequency domain's array) (Output of psd_func function)
    :param nxseg: Number of the time steps in each segment (Output of psd_func function)
    :param num_chnl: Number of channels (Output of psd_func function)
    :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.
    :return:
        ss1: Singular Values
        - UU: Singular Vectors
    """
    nxseg = PSD_mat.shape[0]
    num_chnl = PSD_mat.shape[1]

    ss1 = np.zeros((nxseg, num_chnl))
    UU = np.zeros((num_chnl, num_chnl, nxseg), dtype=complex)
    for kk in range(nxseg):
        UU1, SS1, _ = np.linalg.svd(PSD_mat[kk])
        ss1[kk, :] = abs(SS1)
        UU[:, :, kk] = UU1[:, :]

    if show_plot:
        fig_total, axis = plt.subplots(1, 2, figsize=(15, 6))

        ax1 = axis[0]
        ax2 = axis[1]

        fig_total.suptitle('First three singular values of PSD')
        if ss1.shape[1] >= 3:
            num_singular_val = 3
        else:
            num_singular_val = ss1.shape[1]

        for i in range(num_singular_val):
            ax1.plot(f_psd.real, ss1[:, i].real, label=f'Singular value number {i + 1}')
        ax1.grid(color='gray', alpha=0.4)
        leg = ax1.legend(framealpha=0.9)
        leg.set_zorder(5.1)
        ax1.set_title(f'SVD(PSD)')
        if xlim != 0:
            ax1.set_xlim([xlim[0], xlim[1]])
        ax1.set_xlabel('Frequency(Hz)')
        ax1.set_ylabel(r'SVD of Power Spectral Density ($m^2/s^3$)')

        if show_semilog:
            for i in range(num_singular_val):
                ax2.semilogy(f_psd.real, ss1[:, i].real, label=f'Singular value number {i + 1}')
                # ax2.plot(f_psd, 10*np.log10(ss1[:,i]), label=f'Singular value number {i+1}')
            ax2.minorticks_on()
            ax2.grid(True, color='gray', alpha=0.4)
            ax2.grid(True, which='minor', axis='y', color='gray', alpha=0.4)

            leg = ax2.legend(framealpha=0.9)
            leg.set_zorder(5.1)
            ax2.set_title(r'SVD(PSD)')
            if xlim != 0:
                ax2.set_xlim([xlim[0], xlim[1]])

            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('SVD of Power Spectral Density ($m^2/s^3$)')
        else:
            for i in range(num_singular_val):
                ax2.plot(f_psd.real, 10 * np.log10(ss1[:, i].real).real, label=f'Singular value number {i + 1}')
            # plt.gca().yaxis.set_major_formatter(FuncFormatter(scientific_formatter))
            ax2.minorticks_on()
            ax2.grid(True, color='gray', alpha=0.4)
            ax2.grid(True, which='minor', axis='y', color='gray', alpha=0.4)

            leg = ax2.legend(framealpha=0.9)
            leg.set_zorder(5.1)
            ax2.set_title(r'SVD(PSD)')

            ax2.set_title(r'$10\log$(SVD(PSD))')
            if xlim != 0:
                ax2.set_xlim([xlim[0], xlim[1]])
            ax2.set_xlabel('Frequency(Hz)')
            ax2.set_ylabel('log(SVD of Power Spectral Density) (dB)')
        plt.show()

    return ss1, UU

"""## SVD of PSD Diagram (for choosing peaks)"""

def SVD_PSD_Diagram(f_psd, ss1, xlim=0):
    """
    A function to draw diagrams of PSD and SVD of PSD.

    :param f_psd: A 1D PyTorch tensor (Frequency domain's array) (Output of psd_func function)
    :param ss1: Singular Values
    :param xlim: A list of two numbers indicating the xlim of the plots. (e.g. [2,10]) (0 acts as the complete xlim)
    """
    keys1 = []
    values1 = []
    if ss1.shape[1] >= 3:
        num_singular_val = 3
    else:
        num_singular_val = ss1.shape[1]

    for j in range(num_singular_val):
        values1.append(np.asarray(ss1[:,j].real))
        keys1.append(f'Signular value No.{j+1}')

    df_dict = {'frequency':np.asarray(f_psd.real)}
    df_dict2 = {k:v for (k,v) in zip(keys1,values1)}
    df_dict.update(df_dict2)
    df_plot = pd.DataFrame(df_dict)

    # df_plot = pd.DataFrame({'frequency':f_psd, '1st signular value':np.log10(ss1[:,0]), '2nd signular value':np.log10(ss1[:,1]), '3rd signular value':np.log10(ss1[:,2])})

    fig = px.line(df_plot, x="frequency", y=df_plot.columns[1:])
    if xlim != 0:
        fig.update_layout(
            xaxis_range=[xlim[0],xlim[1]],  # Set the desired x-axis range
            xaxis_title='Frequency (Hz)',
            yaxis_title=r'$\text{SVD of Power Spectral Density } (m^2/s^3)$'
        )
    else:
        fig.update_layout(
            xaxis_range=[f_psd[0].real,f_psd[-1].real],  # Set the desired x-axis range
            xaxis_title='Frequency (Hz)',
            yaxis_title=r'$\text{SVD of Power Spectral Density } (m^2/s^3)$'
        )
    fig.show()

    ## LOG SVD
    for j in range(num_singular_val):
        values1.append(np.asarray(10*np.log10(ss1[:,j].real)))
        keys1.append(f'Signular value No.{j+1}')

    df_dict = {'frequency':np.asarray(f_psd.real)}
    df_dict2 = {k:v for (k,v) in zip(keys1,values1)}
    df_dict.update(df_dict2)
    df_plot = pd.DataFrame(df_dict)
    fig = px.line(df_plot, x="frequency", y=df_plot.columns[1:])#y=df_plot.columns[1:]) #
    # elif which_mode == #number:
    #     ...
    # elif which_mode == #list:
    #     ...

    if xlim != 0:
        fig.update_layout(
            xaxis_range=[xlim[0],xlim[1]],  # Set the desired x-axis range
            xaxis_title='Frequency (Hz)',
            yaxis_title=r'$\text{log(SVD of Power Spectral Density) (dB)}$'
        )
    else:
        fig.update_layout(
            xaxis_range=[f_psd[0].real,f_psd[-1].real],  # Set the desired x-axis range
            xaxis_title='Frequency (Hz)',
            yaxis_title=r'$\text{log(SVD of Power Spectral Density) (dB)}$'
        )
    fig.show()

"""# Calculating Mode Shapes

## Real Mode Shapes
"""

def Calculate_Mode_Shape(f_psd, Natural_frequencies, UU):
    """
    A function to calculate the mode shapes based on singular vectors.

    :param f_psd:
    :param Natural_frequencies:
    :param UU:
    :return: Mode shapes
    """
    freq_step = f_psd[1]-f_psd[0]
    NF_idx = []
    NF_idx_global = []
    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []
    for singular_value_mode in range(len(Natural_frequencies)):
        for i in range(len(Natural_frequencies[singular_value_mode])):
            NF_idx.append(int(np.round(Natural_frequencies[singular_value_mode][i] / freq_step)))
            NF_idx_global.append(NF_idx[-1])
            UU_comb = UU[:,singular_value_mode,NF_idx[i]]
            Mode_shapes_phase.append(np.angle(UU_comb))
            Mode_shapes_amp.append(np.abs(np.real(UU_comb)))
        for i in range(len(Natural_frequencies[singular_value_mode])):
            Mode_shapes_sign.append(np.sign(np.cos(Mode_shapes_phase[i]-Mode_shapes_phase[i][0])))
            Mode_shapes.append(Mode_shapes_sign[i]*Mode_shapes_amp[i] / np.max(Mode_shapes_amp[i]))
        Mode_shapes_amp = []
        Mode_shapes_phase = []
        Mode_shapes_sign = []
        NF_idx = []

    # The Mode_shapes is a list of numpy arrays which resemble mode shapes
    return Mode_shapes, NF_idx_global

"""## Complex Mode Shapes"""

def Calculate_Complex_Mode_Shape(f_psd, Natural_frequencies, UU):
    """
    A function to calculate the mode shapes based on singular vectors. (While considering the complex values of the singular value)

    :param f_psd:
    :param Natural_frequencies:
    :param UU:
    :return: Mode shapes
    """
    freq_step = f_psd[1]-f_psd[0]
    NF_idx = []
    cmpx_NF_idx_global = []
    cmpx_Mode_shapes = []
    for singular_value_mode in range(len(Natural_frequencies)):
        for i in range(len(Natural_frequencies[singular_value_mode])):
            NF_idx.append(int(np.round(Natural_frequencies[singular_value_mode][i] / freq_step)))
            cmpx_NF_idx_global.append(NF_idx[-1])
            UU_comb = UU[:,singular_value_mode,NF_idx[i]]
            cmpx_Mode_shapes.append(UU_comb/np.max(UU_comb))
        # for i in range(len(Natural_frequencies[singular_value_mode])):
        #     Mode_shapes_sign.append(np.sign(np.cos(Mode_shapes_phase[i]-Mode_shapes_phase[i][0])))
        #     Mode_shapes.append(Mode_shapes_sign[i]*Mode_shapes_amp[i] / np.max(Mode_shapes_amp[i]))
        NF_idx = []

    NF_idx = []
    NF_idx_global = []
    Mode_shapes = []
    Mode_shapes_amp = []
    Mode_shapes_phase = []
    Mode_shapes_sign = []
    for singular_value_mode in range(len(Natural_frequencies)):
        for i in range(len(Natural_frequencies[singular_value_mode])):
            NF_idx.append(int(np.round(Natural_frequencies[singular_value_mode][i] / freq_step)))
            NF_idx_global.append(NF_idx[-1])
            UU_comb = UU[:,singular_value_mode,NF_idx[i]]
            Mode_shapes_phase.append(np.angle(UU_comb))
            Mode_shapes_amp.append(np.abs(np.real(UU_comb)))
        for i in range(len(Natural_frequencies[singular_value_mode])):
            Mode_shapes_sign.append(np.sign(np.cos(Mode_shapes_phase[i]-Mode_shapes_phase[i][0])))
            Mode_shapes.append(Mode_shapes_sign[i]*Mode_shapes_amp[i] / np.max(Mode_shapes_amp[i]))
        Mode_shapes_amp = []
        Mode_shapes_phase = []
        Mode_shapes_sign = []
        NF_idx = []


    # The Mode_shapes is a list of numpy arrays which resemble mode shapes
    return cmpx_Mode_shapes, Mode_shapes, cmpx_NF_idx_global

"""# Mode Shape Diagram

## Farrar Mode Shape Diagram
"""

def Farrar_Mode_shape_diagram(Mode_shapes):
    number_dof = len(Mode_shapes[0])
    fig, axis = plt.subplots(1, len(Mode_shapes), sharey=True, figsize=(3*len(Mode_shapes), 5))
    ax1 = axis[0]
    plt.subplots_adjust(wspace=0.5, hspace=0.5)
    Points = []
    for i in range(len(Mode_shapes)):
        Points.append({'x':[], 'y':list(range(1,number_dof+1))})

    for j in range(len(Mode_shapes)):
        plt.subplot(1, len(Mode_shapes), j+1)

        for i in range(number_dof):
            Points[j]['x'].append(Mode_shapes[j][i])
            if i == 0:
                continue
            plt.plot([Points[j]['x'][i],Points[j]['x'][i-1]], [Points[j]['y'][i], Points[j]['y'][i-1]],'-bo', markersize = 6 )
            plt.plot([0, 0], [Points[j]['y'][i], Points[j]['y'][i-1]],'-mo', markersize = 6 )
            plt.ylabel('Floors')
            plt.xlabel('Relative Displacement')
            plt.legend([f'mode {j+1}', 'No Displacement'], framealpha=0.9,zorder=5)
            plt.xlim([-1.1,1.1])
            plt.ylim([0.8,4.3])

        plt.grid()
        # Set the y-axis ticks to be at every integer value
    ax1.set_yticks(range(0, number_dof+1, 1))

    # Format the y-axis labels to remove the decimal part
    ax1.set_yticklabels(['{:.0f}'.format(y) for y in range(0, number_dof+1, 1)])
    plt.show()

"""# Finding SDOF Peaks

## MAC function
"""

def MAC_Calculation(Mode_shape1, Mode_shape2):
    """
    First type of MAC calculation.

    :param Mode_shape1: A list of mode shapes
    :param Mode_shape2: A list of mode shapes
    :return: Mac Matrix
    """
    MAC = np.zeros((Mode_shape1.shape[0],Mode_shape2.shape[0]))
    for i in range(Mode_shape1.shape[0]):
        for j in range(Mode_shape2.shape[0]):
            MAC[i,j]=( np.dot(Mode_shape1[i,:],Mode_shape2[j,:])**2 / (np.dot(Mode_shape1[i,:],Mode_shape1[i,:]) * np.dot(Mode_shape2[j,:],Mode_shape2[j,:]) ) )
    return MAC

# def MAC_function(Mode_shape1, Mode_shape2):
#     """
#         Second type of MAC calculation.
#         :param Mode_shape1: A 2D numpy array of mode shapes
#         :param Mode_shape2: A 2D numpy array of mode shapes
#         :return: Mac Matrix
#         """
#     MAC = np.abs(Mode_shape1.conj()@Mode_shape2/(Mode_shape1.conj()@Mode_shape1))
#     return MAC

def MAC_function(phi, psi):
    """
    Compute MAC matrix between two sets of mode shapes.

    Parameters
    ----------
    phi : (m1, ndof) ndarray (real or complex)
        First set of mode shapes; each row is a mode.
    psi : (m2, ndof) ndarray (real or complex)
        Second set of mode shapes; each row is a mode.

    Returns
    -------
    MAC : (m1, m2) ndarray
        Modal Assurance Criterion matrix.
    """
    # Cross inner products between all pairs of modes
    cross = phi @ psi.conj().T          # (m1, m2)

    # Numerator: squared magnitude of cross terms
    num = np.abs(cross) ** 2

    # Squared norms of each mode
    phi_norm2 = np.sum(np.abs(phi)**2, axis=1, keepdims=True)   # (m1, 1)
    psi_norm2 = np.sum(np.abs(psi)**2, axis=1, keepdims=True)   # (m2, 1)

    # Denominator: outer product of norms â†’ (m1, m2)
    den = phi_norm2 @ psi_norm2.T

    # print(num / den)

    return num / den

def MAC_function2(Mode_shape1, Mode_shape2):
    """
        Second type of MAC calculation.
        :param Mode_shape1: A 2D numpy array of mode shapes
        :param Mode_shape2: A 2D numpy array of mode shapes
        :return: Mac Matrix
        """
    MAC = np.abs((Mode_shape1.conj()@Mode_shape2)**2/((Mode_shape1.conj()@Mode_shape1)*(Mode_shape2.conj()@Mode_shape2)))
    return MAC

"""## SDOF Peak Finding

## Real
"""

def SDOF_Peak_Finding(PSD_Mat, Mode_shapes, Freqs, ss1, UU, NF_idx_global, t, MAC_Lim=0.95):
    """
    A function to find the proper vicinity of peaks of singular value's diagram.

    :param PSD_Mat:
    :param Mode_shapes:
    :param Freqs:
    :param ss1:
    :param UU:
    :param NF_idx_global:
    :param t:
    :param MAC_Lim:
    :return:
    """
    which_singular_value = []
    for i in range(len(Freqs)):
        for j in range(len(Freqs[i])):
            which_singular_value.append(i)
    if isinstance(MAC_Lim, (int, float)):
        mac_cri = MAC_Lim
        MAC_Lim = []
        for i in range(len(Mode_shapes)):
            MAC_Lim.append(mac_cri)
    elif isinstance(MAC_Lim, list):
        if len(MAC_Lim) < len(Mode_shapes):
            for i in range(len(Mode_shapes) - len(MAC_Lim)):
                MAC_Lim.append(MAC_Lim[-1])


    Low_freq_idx_sdof = np.zeros(len(Mode_shapes))
    High_freq_idx_sdof = np.zeros(len(Mode_shapes))
    for damp_ratio_dof in range(len(Mode_shapes)):
        temp_NF_idx = NF_idx_global.copy()

        while True:
            temp_Mode_shape = []
            temp_Mode_shapes_amp = []
            temp_Mode_shapes_phase = []
            temp_Mode_shapes_sign = []

            temp_NF_idx[damp_ratio_dof] = temp_NF_idx[damp_ratio_dof] - 1

            for i in range(len(Mode_shapes)):
                temp_Mode_shapes_phase.append(np.angle(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[i]]))
                temp_Mode_shapes_amp.append(np.abs(np.real(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[i]])))
            for i in range(len(Mode_shapes)):
                temp_Mode_shapes_sign.append(np.sign(np.cos(temp_Mode_shapes_phase[i]-temp_Mode_shapes_phase[i][0])))
                temp_Mode_shape.append(temp_Mode_shapes_sign[i]*temp_Mode_shapes_amp[i] / np.max(temp_Mode_shapes_amp[i]))

            MAC = MAC_function(np.asarray(Mode_shapes),np.asarray(temp_Mode_shape))
            if MAC[damp_ratio_dof,damp_ratio_dof] < MAC_Lim[damp_ratio_dof] or np.abs(temp_NF_idx[damp_ratio_dof] - NF_idx_global[damp_ratio_dof]) > 100:
                Low_freq_idx_sdof[damp_ratio_dof] = int(temp_NF_idx[damp_ratio_dof])+1
                break

        temp_NF_idx = NF_idx_global.copy()

        while True:
            temp_Mode_shape = []
            temp_Mode_shapes_amp = []
            temp_Mode_shapes_phase = []
            temp_Mode_shapes_sign = []

            temp_NF_idx[damp_ratio_dof] = temp_NF_idx[damp_ratio_dof] + 1

            for i in range(len(Mode_shapes)):
                temp_Mode_shapes_phase.append(np.angle(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[i]]))
                temp_Mode_shapes_amp.append(np.abs(np.real(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[i]])))
            for i in range(len(Mode_shapes)):
                temp_Mode_shapes_sign.append(np.sign(np.cos(temp_Mode_shapes_phase[i]-temp_Mode_shapes_phase[i][0])))
                temp_Mode_shape.append(temp_Mode_shapes_sign[i]*temp_Mode_shapes_amp[i] / np.max(temp_Mode_shapes_amp[i]))

            MAC = MAC_function(np.asarray(Mode_shapes),np.asarray(temp_Mode_shape))
            if MAC[damp_ratio_dof,damp_ratio_dof] < MAC_Lim[damp_ratio_dof] or np.abs(temp_NF_idx[damp_ratio_dof] - NF_idx_global[damp_ratio_dof]) > 100:
                High_freq_idx_sdof[damp_ratio_dof] = int(temp_NF_idx[damp_ratio_dof])-1
                break

    for i in range(len(Low_freq_idx_sdof)):
        if Low_freq_idx_sdof[i]<0:
              Low_freq_idx_sdof[i] = 0

    fs = 1/(t[1]-t[0])
    N_data = PSD_Mat.shape[0]
    time_sdof = np.linspace(0,2*(N_data-1)/fs,2*len(t))

    # SDOF_chnls = []
    # for i in range(len(Mode_shapes)):
    #
    #     Gyy = np.zeros(PSD_Mat.shape)
    #     # for j in range(int(Low_freq_idx_sdof[i]), int(High_freq_idx_sdof[i])+1):
    #     Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:]
    #         # Gyy[j,:,:] = np.diag(np.diag(PSD_Mat[j,:,:]))
    #     SDOF_chnls.append(np.real(np.fft.ifft(Gyy.copy(), n=2*len(t), axis=0)))


    SDOF_avg = []
    SDOF_svd = []
    for i in range(len(Mode_shapes)):
        Gyy = np.zeros(PSD_Mat.shape[0])
        Gyy_temp = np.zeros(PSD_Mat.shape[0])
        Gyy_each = []

        for j in range(PSD_Mat.shape[1]):
            # Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),j,j]
            Gyy_temp[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),j,j]
            Gyy_each.append(Gyy_temp)

        Gyy = sum(Gyy_each)/len(Gyy_each)
        # plt.plot(Gyy)
        # plt.show()
        # Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = np.diag(np.diag(PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:]))
        SDOF_avg.append(np.real(np.fft.ifft(Gyy, n=2*len(t), axis=0)))

        Gyy = np.zeros(PSD_Mat.shape[0])
        Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = ss1[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),0]
        SDOF_svd.append(np.real(np.fft.ifft(Gyy, n=2*len(t), axis=0)))

    SDOF = {'average':SDOF_avg, 'svd':SDOF_svd}
    return SDOF, time_sdof

"""## Complex"""

def SDOF_Peak_Finding_complex_modeshape(PSD_Mat, Mode_shapes, Freqs, ss1, UU, NF_idx_global, t, MAC_Lim=0.95):
    """
        A function to find the proper vicinity of peaks of singular value's diagram.
        (Taking into account the complex values in the singular vectors)

        :param PSD_Mat:
        :param Mode_shapes:
        :param Freqs:
        :param ss1:
        :param UU:
        :param NF_idx_global:
        :param t:
        :param MAC_Lim:
        :return:
    """
    which_singular_value = []
    for i in range(len(Freqs)):
        for j in range(len(Freqs[i])):
            which_singular_value.append(i)
    if isinstance(MAC_Lim, (int, float)):
        mac_cri = MAC_Lim
        MAC_Lim = []
        for i in range(len(Mode_shapes)):
            MAC_Lim.append(mac_cri)
    elif isinstance(MAC_Lim, list):
        if len(MAC_Lim) < len(Mode_shapes):
            for i in range(len(Mode_shapes) - len(MAC_Lim)):
                MAC_Lim.append(MAC_Lim[-1])


    Low_freq_idx_sdof = np.zeros(len(Mode_shapes))
    High_freq_idx_sdof = np.zeros(len(Mode_shapes))
    for damp_ratio_dof in range(len(Mode_shapes)):
        temp_NF_idx = NF_idx_global.copy()

        while True:
            temp_Mode_shape = []

            temp_NF_idx[damp_ratio_dof] = temp_NF_idx[damp_ratio_dof] - 1

            # for i in range(len(Mode_shapes)):
            temp_Mode_shape.append(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[damp_ratio_dof]] / np.max(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[damp_ratio_dof]]))

            MAC = MAC_function2(np.asarray(Mode_shapes)[damp_ratio_dof,:],np.asarray(temp_Mode_shape[0]))
            if MAC < MAC_Lim[damp_ratio_dof] or np.abs(temp_NF_idx[damp_ratio_dof] - NF_idx_global[damp_ratio_dof]) > 100:
                Low_freq_idx_sdof[damp_ratio_dof] = int(temp_NF_idx[damp_ratio_dof])+1
                break

        temp_NF_idx = NF_idx_global.copy()

        while True:
            temp_Mode_shape = []

            temp_NF_idx[damp_ratio_dof] = temp_NF_idx[damp_ratio_dof] + 1

            # for i in range(len(Mode_shapes)):
            temp_Mode_shape.append(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[damp_ratio_dof]] / np.max(UU[:,which_singular_value[damp_ratio_dof],temp_NF_idx[damp_ratio_dof]]))

            MAC = MAC_function2(np.asarray(Mode_shapes)[damp_ratio_dof,:],np.asarray(temp_Mode_shape[0]))
            if MAC < MAC_Lim[damp_ratio_dof] or np.abs(temp_NF_idx[damp_ratio_dof] - NF_idx_global[damp_ratio_dof]) > 100:
                High_freq_idx_sdof[damp_ratio_dof] = int(temp_NF_idx[damp_ratio_dof])-1
                break

    for i in range(len(Low_freq_idx_sdof)):
        if Low_freq_idx_sdof[i]<0:
              Low_freq_idx_sdof[i] = 0


    fs = 1/(t[1]-t[0])
    N_data = PSD_Mat.shape[0]
    time_sdof = np.linspace(0,2*(N_data-1)/fs,2*len(t))

    # SDOF_chnls = []
    # for i in range(len(Mode_shapes)):
    #
    #     Gyy = np.zeros(PSD_Mat.shape)
    #     # for j in range(int(Low_freq_idx_sdof[i]), int(High_freq_idx_sdof[i])+1):
    #     Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:]
    #         # Gyy[j,:,:] = np.diag(np.diag(PSD_Mat[j,:,:]))
    #     SDOF_chnls.append(np.real(np.fft.ifft(Gyy.copy(), n=2*len(t), axis=0)))

    SDOF_avg = []
    SDOF_svd = []
    for i in range(len(Mode_shapes)):
        Gyy = np.zeros(PSD_Mat.shape[0])
        Gyy_temp = np.zeros(PSD_Mat.shape[0])
        Gyy_each = []

        for j in range(PSD_Mat.shape[1]):
            # Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),j,j]
            Gyy_temp[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i] + 1)] = PSD_Mat[int(Low_freq_idx_sdof[i]):int(
                High_freq_idx_sdof[i] + 1), j, j]
            Gyy_each.append(Gyy_temp)

        Gyy = sum(Gyy_each) / len(Gyy_each)
        # plt.plot(Gyy)
        # plt.show()
        # Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1)] = np.diag(np.diag(PSD_Mat[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i]+1),:,:]))
        SDOF_avg.append(np.real(np.fft.ifft(Gyy, n=2 * len(t), axis=0)))

        Gyy = np.zeros(PSD_Mat.shape[0])
        Gyy[int(Low_freq_idx_sdof[i]):int(High_freq_idx_sdof[i] + 1)] = ss1[int(Low_freq_idx_sdof[i]):int(
            High_freq_idx_sdof[i] + 1), 0]
        SDOF_svd.append(np.real(np.fft.ifft(Gyy, n=2 * len(t), axis=0)))



    SDOF = {'svd':SDOF_svd, 'average':SDOF_avg}
    return SDOF, time_sdof

"""## SDOF Diagram"""

def each_SDOF_digram(SDOF, t, Mode_shapes, plot_type='pyplot', xlim=0,show_mode_shape_number=True):
    """
    A function to draw plots of each SDOF system.

    :param SDOF:
    :param t:
    :param Mode_shapes:
    :param plot_type:
    :param xlim:
    :return:
    """
    # plot_type = 1. pyplot, 2. plotly
    SDOF_avg = SDOF['average']
    SDOF_svd = SDOF['svd']
    # SDOF_chnl = SDOF['channel']
    for i in range(len(Mode_shapes)):
    #     keys1 = []
    #     values1 = []
    #     n_dof = SDOF_chnl[i].shape[1]
    #     for j in range(n_dof):
    #         values1.append(np.asarray(SDOF_chnl[i][:,j,j].real))
    #         keys1.append(f'Acceleration Ch{j+1}')

        df_dict = {'Time':t}
        # df_dict2 = {k:v for (k,v) in zip(keys1,values1)}
        # df_dict.update(df_dict2)
        df_dict3 = {'Average':SDOF_avg[i]}
        df_dict.update(df_dict3)
        df_dict4 = {'SVD':SDOF_svd[i]}
        df_dict.update(df_dict4)
        df_plot = pd.DataFrame(df_dict)


        if plot_type == 'plotly':
            fig = px.line(df_plot, x="Time", y=df_plot.columns[1:], title=f'Mode No.{i+1}')#y=df_plot.columns[1:]) #

            if xlim != 0:
                fig.update_layout(
                    xaxis_range=[xlim[0],xlim[1]],  # Set the desired x-axis range
                    xaxis_title='Time (s)',
                    yaxis_title=r'$Acceleration (m/s^2)$',
                    title_x=0.5
                )
            else:
                fig.update_layout(
                    xaxis_range=[t[0],t[int(t.shape[0]//2)]],  # Set the desired x-axis range
                    xaxis_title='Time (s)',
                    yaxis_title=r'$Acceleration (m/s^2)$',
                    title_x=0.5
                )
            fig.show()
        elif plot_type == 'pyplot':
            fig, ax = plt.subplots(1,1, figsize=(8,5))
            ax.set_xlabel('Time (s)')
            ax.set_ylabel(r'Acceleration $(m/s^2)$')
            ax.plot(np.array(df_plot['Time'][:int(df_plot['Time'].shape[0]//2)]), np.array(df_plot['SVD'][:int(df_plot['SVD'].shape[0]//2)]),label='SVD')
            ax.plot(np.array(df_plot['Time'][:int(df_plot['Time'].shape[0]//2)]), np.array(df_plot['Average'][:int(df_plot['Average'].shape[0]//2)]),label='Average')
            if show_mode_shape_number:
                txt3 = ax.text(x=0.5, y=0.95, s=f"Mode no.{i + 1}", ha='center', va='top',
                               transform=plt.gca().transAxes)
                txt3.set_bbox(dict(facecolor='white', alpha=0.95, edgecolor='black'))
                txt3.set_zorder(5.1)

            # ax.set_title(f'Mode No.{i+1}')
            leg = ax.legend(framealpha=0.9)
            leg.set_zorder(5.1)
            ax.grid()
            if xlim != 0:
                ax.set_xlim([xlim[0],xlim[1]])
            else:
                ax.set_xlim([t[0],t[int(t.shape[0]//2)]])
            plt.show()
        else:
            print('The plot type is not set correctly!')

"""# Damping ratio"""

def calculate_damping_ratio(SDOF, t, time_start, time_stop, show_fits=True,show_mode_shape_number=True, show_full_decay=False):
    """
    A function to calculate the damping ratios using each SDOF system.

    :param SDOF:
    :param t:
    :param time_start:
    :param time_stop:
    :param show_fits:
    :return:
    """
    t = t[:int(len(t) // 2)]
    dt = t[1] - t[0]
    D_R = []
    XI = []
    enhanced_frequencies = []
    for i in range(len(SDOF)):
        N_data = SDOF[i].shape[0]

        if time_start[i] < 0:
            time_start[i] = 0


        time_start_idx = int(np.round(time_start[i]/dt))
        time_stop_idx = int(np.round(time_stop[i]/dt))
        if time_stop_idx > N_data//2:
            time_stop_idx = int(N_data//2)
        if time_start_idx > N_data // 2:
            time_stop_idx = 0
        if time_start_idx >= time_stop_idx:
            time_start_idx = 0
            time_stop_idx = int(N_data//2)

        SDOF_abs = np.abs(SDOF[i])
        SDOF_abs /= np.max(SDOF[i])

        peaks, _ = find_peaks(SDOF_abs[:time_stop_idx])
        peaks = np.insert(peaks, 0, 0, axis=0)
        if time_start_idx in peaks:
            peaks_start_idx = np.where(peaks==time_start_idx)[0][0]
            peaks = peaks[peaks_start_idx:]
        else:
            peaks_start_idx = np.where(np.sign(peaks-time_start_idx)  == 1)[0][0]
            peaks = peaks[peaks_start_idx:]

        k = int(peaks.shape[0])-1
        rk = SDOF_abs[peaks[k]]

        r0 = SDOF_abs[peaks[0]]

        Del = 2/k*np.log(r0/rk)
        d_r = Del/np.sqrt(Del**2+4*np.pi**2) # First and Last Peaks
        D_R.append(d_r)

        z1 = np.log(r0)
        z2 = np.log(rk)
        # exp(a+b*t)
        exp_b = (z2-z1)/(t[peaks[k]]-t[peaks[0]])
        exp_a = z1 - exp_b*t[peaks[0]]
        exp_decay_first_last = np.exp(exp_a + exp_b*t[peaks[0]:peaks[k]])

        omega_d = 2*np.pi/np.mean(t[peaks[1:]] - t[peaks[:-1]])/2
        decay = np.log(SDOF_abs[peaks])
        slope, intercept = np.polyfit(t[peaks], decay, 1)

        yhat = np.poly1d([slope,intercept])(t[peaks])
        ybar = np.sum(decay)/len(decay)
        ssreg = np.sum((yhat-ybar)**2)
        sstot = np.sum((decay - ybar)**2)
        R2_fit = ssreg / sstot

        omega_n = np.sqrt(slope**2 + omega_d**2)
        enhanced_frequencies.append(omega_n/(2*np.pi))
        xi = -slope / omega_n # All peaks
        XI.append(xi)

        fix = plt.figure(figsize=(10,5))
        ax = plt.gca()
        ax.scatter(t[peaks], SDOF_abs[peaks],color='tab:orange', label='Peaks')
        if show_full_decay:
            ax.plot(t, SDOF_abs[:int(N_data//2)],color='tab:blue', label='Main data')
        else:
            ax.plot(t[time_start_idx:time_stop_idx], SDOF_abs[time_start_idx:time_stop_idx], color='tab:blue',
                label='Main data')
        ax.plot(t[peaks], np.exp(intercept+slope*t[peaks]),color='tab:red',label='Exponential fit (First method)')

        ax.scatter(t[peaks][::len(peaks)-1], SDOF_abs[peaks][::len(peaks)-1],color='tab:green', label='First and Last Peaks')
        ax.plot(t[peaks[0]:peaks[k]], exp_decay_first_last,color='tab:green', label='Second method')

        leg = ax.legend(framealpha=0.9)
        leg.set_zorder(5.1)
        if show_mode_shape_number:
            txt3 = ax.text(x=0.4, y=0.95, s=f"Autocorrelation of mode no.{i + 1}", ha='center', va='top',
                           transform=plt.gca().transAxes)
            txt3.set_bbox(dict(facecolor='white', alpha=0.9, edgecolor='black'))
            txt3.set_zorder(5.1)

        if show_fits:
            txt = ax.text(x=0.971,y=0.45,s=f"Frequency: {omega_n/(2*np.pi):.2f}Hz\nDamping: {xi*100:.2f}%\n"+rf"$R^2$: {R2_fit*100:.2f}%", ha='right', va='bottom', transform=plt.gca().transAxes)
            txt2 = ax.text(x=0.971,y=0.4,s=f"Damping: {d_r*100:.2f}%\nBy first and last peaks", ha='right', va='top', transform=plt.gca().transAxes)

            txt.set_bbox(dict(facecolor='red', alpha=0.95, edgecolor='black'))
            txt.set_zorder(5.1)
            txt2.set_bbox(dict(facecolor='lime', alpha=0.95, edgecolor='black'))
            txt2.set_zorder(5.1)

        ax.set_ylim([0,1])
        # ax.set_title(f'Autocorrelation of mode no.{i+1}')
        ax.set_ylabel(f'Normalized autocorrelation')
        ax.set_xlabel(f'Time (s)')
        plt.show()

    damping_output = {'all_peaks':XI, 'first_last':D_R}
    return damping_output, enhanced_frequencies

"""# FDD Alg Function

## Part 1
"""

def FDD_SVD_Diagram(data, dt, nseg=10,pov=0.5,window='hann',show_semilog=False,xlim=0, ylim=0):
    """
    First part of the EFDD method.
    Receives data and returns information about singular values of PSD.
    It also draws plots of SVD of PSD to let the user find the peaks.

    :param data: A 2D matrix of signals (Response of structure) (Numpy array or PyTorch tensor)
    :param dt: Time resolution (Time interval)
    :param nseg: Number of segments in Welch's method
    :param pov: Percent of overlap in Welch's method
    :param window: Window type in Welch's method (e.g. 'hann', 'bohman', 'hamming')
    :param show_semilog: An option indicating whether the result is shown in semi-logarithmic format or not.
    :return:
    - Gyy: A 3D tensor containing PSD values
    - f_psd: A 1D PyTorch tensor corresponding to the Gyy (Frequency domain's array)
    - ss: Singular values array
    - UU: Singular vectors' matrix
    - t: Time array
    """
    Gyy, f_psd, t = psd_func_EFDD(data,dt,show_semilog=show_semilog,nseg=nseg,pov=pov,window=window,xlim=xlim, ylim=ylim)
    ss, UU = svd_psd(Gyy,f_psd,show_semilog=show_semilog,xlim=xlim)
    SVD_PSD_Diagram(f_psd,ss)
    return Gyy, f_psd, ss, UU, t

"""## Part 2"""

def FDD_ModeShape(Freqs, PSD_mat, f_psd, ss, UU, t, MAC_Lim=0.95, plot_type='pyplot', complex_mode_shape=False, xlim=0, show_mode_shape_number=True, show_output=True):
    """
    Second part of the EFDD method.
    Receives the output of the first part and a list indicating the frequencies if the found peaks.
    It also draws plots of extracted SDOF correlation functions.
    This function returns the information of mode shapes.

    :param Freqs: A list of frequencies based on the singular values. (e.g. [[30.2, 45], [32]] It means that there are two peaks in the first singular value plot and one peak in the second singular value.
    :param PSD_mat: A 3D tensor containing PSD values
    :param f_psd: A 1D PyTorch tensor (Frequency domain's array) (Output of psd_func function)
    :param ss: Singular values array
    :param UU: Singular vectors' matrix
    :param t: Time array
    :param MAC_Lim: A limit to indicate to which extent of peaks will be considered as the domain of each peak.
    :param plot_type: One of {'pyplot' or 'plotly'}. It indicates that the diagram will be plotted by which library.
    :param complex_mode_shape: If True, the imaginary part of mode shapes will not be emitted.
    :param xlim: A list of two numbers indicating the xlim of the plots. (e.g. [2,10]) (0 acts as the complete xlim)
    :param show_mode_shape_number: If True, the number of mode is shown on the plot.
    :return:
    - Mode_shapes: A list of arrays containing mode shapes
    - SDOF: Information about single degree of freedom extracted from multi-degree of freedom setup
    - t_sdof: Time array regarding the SDOF system.
    """
    if complex_mode_shape == False:
        Mode_shapes, NF_idx_global = Calculate_Mode_Shape(f_psd, Freqs, UU)
        # Farrar_Mode_shape_diagram(Mode_shapes)
        SDOF, t_sdof = SDOF_Peak_Finding(PSD_mat, Mode_shapes, Freqs, ss, UU, NF_idx_global ,t ,MAC_Lim=MAC_Lim)
        # SDOF = {'average':SDOF_avg, 'svd':SDOF_svd, 'channel':SDOF_chnl}
        if show_output:
            each_SDOF_digram(SDOF, t_sdof, Mode_shapes, plot_type=plot_type, xlim=xlim, show_mode_shape_number=show_mode_shape_number)
        return Mode_shapes, SDOF, t_sdof

    else:
        cmpx_Mode_shapes, Mode_shapes, cmpx_NF_idx_global = Calculate_Complex_Mode_Shape(f_psd, Freqs, UU)
        # Farrar_Mode_shape_diagram(Mode_shapes)
        SDOF, t_sdof = SDOF_Peak_Finding_complex_modeshape(PSD_mat, cmpx_Mode_shapes, Freqs, ss, UU, cmpx_NF_idx_global ,t ,MAC_Lim=MAC_Lim)
        # SDOF = {'average':SDOF_avg, 'svd':SDOF_svd, 'channel':SDOF_chnl}
        if show_output:
            each_SDOF_digram(SDOF, t_sdof, cmpx_Mode_shapes, plot_type=plot_type, xlim=xlim, show_mode_shape_number=show_mode_shape_number)

        return Mode_shapes, SDOF, t_sdof

"""## Part 3"""

def FDD_Damping(SDOF, t_sdof, time_frame=((),()), exponential_fit_method='all_peaks', PSD_method='svd', show_fits=True, show_mode_shape_number=True, show_full_decay=False):
    """
    It is the third and last part of EFDD method.
    This part includes calculating damping ratios.
    Additionally, it plots the exponential fit and the accuracy.

    :param SDOF: Information about single degree of freedom extracted from multi-degree of freedom setup
    :param t_sdof: Time array regarding the SDOF system.
    :param time_frame: A list of two lists, First list must contain the starting time for each mode. The second one is the same, but envlopes the ending time of each mode.
    :param exponential_fit_method: One of {'first-last' or 'all_peaks'}. It indicates which peaks will be used for the exponential fitting.
    :param PSD_method: One of {'svd' or ' avg'}
    :param show_fits: If True, in two boxes, results of damping ratio will be shown on the plots.
    :return:
    - damping_ratios: Extracted damping ratio
    - Enhanced_Frequencies: Extracted natural frequency based on SDOF system
    """

    if PSD_method == 'svd':
        SDOF = SDOF['svd']
    elif PSD_method == 'avg':
        SDOF = SDOF['average']
    else:
        print('The method is not right, SVD will be used.')
        SDOF = SDOF['svd']

    time_start = list(time_frame[0])
    time_stop = list(time_frame[1])

    if len(time_stop) == 0 or len(time_start) == 0:
        time_start = [t_sdof[0]] * len(SDOF)
        time_stop = [t_sdof[-1]] * len(SDOF)
    # elif len(time_stop) == len(SDOF) and len(time_start) == len(SDOF):
    #     flag_time_start_one_each = True
    elif len(time_stop) < len(SDOF) or len(time_start) < len(SDOF):
        min_len = min(len(time_stop), len(time_start))
        time_start = time_start[0:min_len]
        time_start.extend([t_sdof[0]] * (len(SDOF) - min_len))
        time_stop = time_stop[0:min_len]
        time_stop.extend([t_sdof[-1]] * (len(SDOF) - min_len))

    damping_ratios, Enhanced_Frequencies = calculate_damping_ratio(SDOF, t_sdof, time_start=time_start, time_stop=time_stop, show_fits=show_fits,show_mode_shape_number=show_mode_shape_number, show_full_decay=show_full_decay)
    if exponential_fit_method in damping_ratios.keys():
        damping_ratios = damping_ratios[exponential_fit_method]
    else:
        print('The exponential_fit_method is not assigned correctly. The chosen method is all_peaks.')
        damping_ratios = damping_ratios['all_peaks']

    return damping_ratios, Enhanced_Frequencies


####################################################################################################################################
'''# HOW to use this algorithm

## Part 1 (Getting SVD of PSD)
"""

PSD_mat, f_psd, ss1, UU, t = FDD_SVD_Diagram(y_filtered, delta_t, window='hann', nseg=20 ,pov=0.8)

"""## Choosing frequencies"""

## Natural Frequencies = [ [ ], [ ], [ ] ]
## Which n-th list in the main list contains frequencies read from the n-th singular value diagram
Natural_frequencies = [[30.759, 53.632, 70.983],[23.66]] ## Insert the Natural Frequencies Manually

"""## part 2 (Getting mode shapes)"""

Mode_shapes, SDOF, t_sdof = FDD_ModeShape(Natural_frequencies, PSD_mat, f_psd, ss1, UU, t,complex_mode_shape=True, MAC_Lim=[0.92, 0.80, 0.86])

"""## Drawing mode shapes (Please use the special function of your structure)"""

Farrar_Mode_shape_diagram(Mode_shapes)

"""## Part 3 (Calculating damping ratios)"""

# With respect to SDOF autocorrelation diagrams, choose a time frame for modes
time_start = [0.01, 0.02, 0.15, 0]
time_stop = [0.3, 0.3, 0.4, 0]

damping_ratio = []
for i in range(len(SDOF['svd'])):
    # PSD_method:
    # 1. 'svd' for using first singular value of PSD for inverse Fourier transform.
    # 2. 'avg' for using average of all channels PSDs.
    damping_ratio.append(FDD_Damping(i, SDOF, t_sdof, Natural_frequencies, [time_start[i], time_stop[i]], PSD_method='svd'))

pd.DataFrame(damping_ratio)
'''
