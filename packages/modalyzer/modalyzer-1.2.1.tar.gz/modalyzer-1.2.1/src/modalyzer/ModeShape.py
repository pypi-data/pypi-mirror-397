# -*- coding: utf-8 -*-
"""Mode_Shape.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rvCZQ8uo_dlL-H9QvmmQJjJUCsLPVpCv
"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.colors import Normalize
from scipy.interpolate import CubicSpline
from scipy.interpolate import make_interp_spline
import csv
import os
import pickle

def draw_mode_shapes(coord_file_name, list_mode_shapes, list_freqs=0, list_damps=0, base_axis='z', base_axis_align='horizontal', normalization_type='max', ylim=None, write_modal_info=False, no_info_at_all=False, show_values=True):
    """
    This function receives name of a csv file that contains geometry information of the structure.
    It also gets a list of mode shapes.

    :param coord_file_name: A string that contains a csv file.
    :param list_mode_shapes: A list of mode shapes.
    :param list_freqs: An optional parameter, a list of frequencies.
    :param list_damps: An optional parameter, a list of damping ratios.
    :param base_axis: ('x', 'y', or 'z') It indicates the basis axis for the mode shapes.
    :param base_axis_align: ('vertical' or 'horizontal')
    :param normalization_type: ('max', 'norm')
    :param write_modal_info: If True, frequencies and damping ratios will be shown.
    :param no_info_at_all: If True and write_modal_info=False, there will be no titles.
    :return:
    """
    if ylim == []:
        ylim = None
    coords, links = read_coordinate(coord_file_name)

    
    

    if isinstance(list_mode_shapes, list):
        if normalization_type == 'norm':
            list_mode_shapes = convert_to_unit_norm(list_mode_shapes)
        else:
            #Do nothing as the initial form is the 'max' method.
            pass
        still_plot_data, deformed_plot_data, deformed_links = calculate_deformed_shape(coords, list_mode_shapes, links)
        draw_plots(coords, still_plot_data, deformed_plot_data, deformed_links, base_axis=base_axis, base_axis_align=base_axis_align, custom_ylim=ylim, normalization_type=normalization_type,
                   list_freqs=list_freqs, list_damps=list_damps, write_modal_info=write_modal_info, no_info_at_all=no_info_at_all, show_values=show_values)
        
    elif isinstance(list_mode_shapes, dict):
        deformed_plot_data = {}
        deformed_links = {}

        for k in list_mode_shapes.keys():
            if normalization_type == 'norm':
                list_mode_shapes[k] = convert_to_unit_norm(list_mode_shapes[k])
            else:
                #Do nothing as the initial form is the 'max' method.
                pass
            still_plot_data, deformed_plot_data[k], deformed_links[k] = calculate_deformed_shape(coords, list_mode_shapes[k], links)
            
        draw_comparative_plots(coords, still_plot_data, deformed_plot_data, deformed_links, base_axis=base_axis, base_axis_align=base_axis_align, custom_ylim=ylim, normalization_type=normalization_type,
                               list_freqs=list_freqs, list_damps=list_damps, write_modal_info=write_modal_info, no_info_at_all=no_info_at_all, show_values=show_values)
            

def convert_to_unit_norm(list_mode_shapes):
    new_list_mode_shapes = []
    eps = 1e-8
    for v in list_mode_shapes:
        v = np.asarray(v, dtype=float)
        n = np.linalg.norm(v)
        new_list_mode_shapes.append(v if n < eps else v / n)
    return new_list_mode_shapes
        

def draw_comparative_plots(coords, still_plot_data, deformed_plot_data_dict, deformed_links, base_axis='z', base_axis_align='horizontal',normalization_type='max',custom_ylim=None,list_freqs=0, list_damps=0, write_modal_info=False, no_info_at_all=False, show_values=False):

    sensor_axes = []
    for i in coords[:, 5]:
        if int(i) not in sensor_axes and i != 0:
            sensor_axes.append(int(i))
    sensor_axes.sort()
    axes_string = ''
    for i in sensor_axes:
        axes_string += 'xyz'[i-1]
    n_modes = len(deformed_plot_data_dict[list(deformed_plot_data_dict.keys())[0]])

    colors = ['blue', 'red', 'magenta', 'cyan', 'green', 'lime', 'blue', 'red', 'magenta', 'cyan', 'green', 'lime', 'blue', 'red', 'magenta', 'cyan', 'green', 'lime', 'black', 'blue', 'red']
    list_markers = ['*', 'v', '^', 'o', 's', 'd', 'p', 'P', 'h', 'H', '+', 'x', '|', '_', '1', '2', '3', '4', '8', '.', '*']
    list_linestyles = ['-', '--', '-.', ':', '-.', '--', ':','-', '--', '-.', ':', '-.', '--', ':','-', '--', '-.', ':', '-.', '--', ':' ]

    if base_axis_align == 'horizontal':

        axes_string_counter = 0
        for mode_shape_counter in range(n_modes):
            fig, axes = plt.subplots(len(sensor_axes), 1, sharex=True,figsize=(10, 2*len(sensor_axes)))
            plt.subplots_adjust(wspace=0.2, hspace=0.1)
            if list_freqs == 0 or not write_modal_info and not no_info_at_all:
                fig.suptitle(f'mode: {mode_shape_counter+1}')
            elif not no_info_at_all :
                fig.suptitle(f'   ')
            if len(sensor_axes) == 1:
                ax = axes
                ax.grid()
                # ax.set_ylabel(axes_string[axes_string_counter])
                # ax.set_xlabel(base_axis)

                if normalization_type == 'max':
                    ax.set_ylim([-1.05,1.05])
                elif normalization_type == 'norm':
                    if custom_ylim != None:
                        ax.set_ylim(custom_ylim)
                    pass

                ##########################################################
                for plot_data in still_plot_data:
                    ax.plot(plot_data[base_axis], [0, 0], 'r', linewidth=0.5)

                ##########################################################
                if show_values:
                    for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                        for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(still_plot_data[i][base_axis], just_mode_shape, linestyle=list_linestyles[msh_i], marker=list_markers[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                else:
                    for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                        for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(still_plot_data[i][base_axis], just_mode_shape, linestyle=list_linestyles[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                ##########################################################
                # for plot_data in deformed_links[mode_shape_counter]:
                #     just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                #     ax.plot([plot_data[base_axis][0],plot_data[base_axis][0]], just_mode_shape, '--m')

                #     mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                #     if mode_shape_number != 0:
                #         y_text = just_mode_shape[1]/2
                #         x_text = plot_data[base_axis][0]
                #         ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')

                x_min, x_max = ax.get_xlim()
                x_middle = (x_max + x_min) / 2

                axis_x = x_middle
                axis_y = 0.75
                if write_modal_info:
                    axis_x = 0.5
                    axis_y = 1.0
                    txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                    txt_axis.set_horizontalalignment('center')
                    txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_damps != 0 and write_modal_info:
                    if isinstance(list_damps, dict) and len(list_damps) == len(deformed_plot_data_dict):
                        damp_comparative_list = []
                        for d_i in list_damps.keys():
                            damp_comparative_list.append(float('{:.2f}'.format(list_damps[d_i][mode_shape_counter]*100)))
                        # damp_x = x_middle
                        damp_x = 0.5
                        # damp_y = 1.2
                        damp_y = 1.25
                        txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {damp_comparative_list}%", ha='center', va='bottom', transform=ax.transAxes)
                        txt_damp.set_horizontalalignment('center')
                        txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_freqs != 0 and write_modal_info:
                    if isinstance(list_freqs, dict) and len(list_freqs) == len(deformed_plot_data_dict):
                        freq_comparative_list = []
                        for d_i in list_freqs.keys():
                            freq_comparative_list.append(float('{:.2f}'.format(list_freqs[d_i][mode_shape_counter])))
                        # freq_x = x_middle
                        freq_x = 0.5
                        # freq_y = 1.6
                        freq_y = 1.45
                        txt_freq = ax.text(freq_x, freq_y, f"frequency = {freq_comparative_list} Hz", ha='center', va='bottom', transform=ax.transAxes)
                        txt_freq.set_horizontalalignment('center')
                        txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                handles, labels = ax.get_legend_handles_labels()
                unique_labels = dict(zip(labels, handles))

                ax.legend(unique_labels.values(), unique_labels.keys(), loc='upper left', bbox_to_anchor=(1, 1))

                axes_string_counter += 1
                if axes_string_counter >= len(sensor_axes):
                    axes_string_counter = 0
                
            else:
                for ax in axes:
                    ax.grid()
                    # ax.set_ylabel(axes_string[axes_string_counter])
                    # ax.set_xlabel(base_axis)
                    if normalization_type == 'max':
                        ax.set_ylim([-1.05,1.05])
                    elif normalization_type == 'norm':
                        if custom_ylim != None:
                            ax.set_ylim(custom_ylim)
                        pass
                    ##########################################################
                    for plot_data in still_plot_data:
                        ax.plot(plot_data[base_axis], [0, 0], 'r', linewidth=0.5)
                    ##########################################################
                    if show_values:
                        for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                            for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                                just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                                ax.plot(still_plot_data[i][base_axis], just_mode_shape, linestyle=list_linestyles[msh_i], marker=list_markers[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                    else:
                        for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                            for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                                just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                                ax.plot(still_plot_data[i][base_axis], just_mode_shape, linestyle=list_linestyles[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                    ##########################################################
                    # for plot_data in deformed_links[mode_shape_counter]:
                    #     just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                    #     ax.plot([plot_data[base_axis][0],plot_data[base_axis][0]], just_mode_shape, '--m')

                    #     mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                    #     if mode_shape_number != 0:
                    #         y_text = just_mode_shape[1]/2
                    #         x_text = plot_data[base_axis][0]
                    #         ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')

                    x_min, x_max = ax.get_xlim()
                    x_middle = (x_max + x_min) / 2

                    axis_x = x_middle
                    axis_y = 0.75
                    if write_modal_info:
                        axis_x = 0.5
                        axis_y = 1.0
                        txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                        txt_axis.set_horizontalalignment('center')
                        txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))


                    if ax == axes[0]:
                        # if list_damps != 0 and write_modal_info:
                        #     # damp_x = x_middle
                        #     damp_x = 0.5
                        #     # damp_y = 1.2
                        #     damp_y = 1.25
                        #     txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                        #     txt_damp.set_horizontalalignment('center')
                        #     txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        # if list_freqs != 0 and write_modal_info:
                        #     # freq_x = x_middle
                        #     freq_x = 0.5
                        #     # freq_y = 1.6
                        #     freq_y = 1.45
                        #     txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                        #     txt_freq.set_horizontalalignment('center')
                        #     txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))


                        if list_damps != 0 and write_modal_info:
                            if isinstance(list_damps, dict) and len(list_damps) == len(deformed_plot_data_dict):
                                damp_comparative_list = []
                                for d_i in list_damps.keys():
                                    damp_comparative_list.append(float('{:.2f}'.format(list_damps[d_i][mode_shape_counter]*100)))
                                # damp_x = x_middle
                                damp_x = 0.5
                                # damp_y = 1.2
                                damp_y = 1.25
                                txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {damp_comparative_list}%", ha='center', va='bottom', transform=ax.transAxes)
                                txt_damp.set_horizontalalignment('center')
                                txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        if list_freqs != 0 and write_modal_info:
                            if isinstance(list_freqs, dict) and len(list_freqs) == len(deformed_plot_data_dict):
                                freq_comparative_list = []
                                for d_i in list_freqs.keys():
                                    freq_comparative_list.append(float('{:.2f}'.format(list_freqs[d_i][mode_shape_counter])))
                                # freq_x = x_middle
                                freq_x = 0.5
                                # freq_y = 1.6
                                freq_y = 1.45
                                txt_freq = ax.text(freq_x, freq_y, f"frequency = {freq_comparative_list} Hz", ha='center', va='bottom', transform=ax.transAxes)
                                txt_freq.set_horizontalalignment('center')
                                txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                    
                        handles, labels = ax.get_legend_handles_labels()
                        unique_labels = dict(zip(labels, handles))

                        ax.legend(unique_labels.values(), unique_labels.keys(), loc='upper left', bbox_to_anchor=(1, 1))

                    axes_string_counter += 1
                    if axes_string_counter >= len(sensor_axes):
                        axes_string_counter = 0

###############################################################################
###############################################################################
###############################################################################
###############################################################################

    elif base_axis_align == 'vertical':
        for mode_shape_counter in range(n_modes):
            fig, axes = plt.subplots(1, len(sensor_axes), sharey=True, figsize=(2*len(sensor_axes),5))
            plt.subplots_adjust(wspace=0.2, hspace=0.1)
            if list_freqs == 0 or not write_modal_info and not no_info_at_all:
                fig.suptitle(f'mode: {mode_shape_counter+1}')
            elif not no_info_at_all:
                fig.suptitle(f'   ')
            axes_string_counter = 0
            if len(sensor_axes) == 1:
                ax = axes
                ax.grid()
                # ax.set_xlabel(axes_string[axes_string_counter])
                # ax.set_ylabel(base_axis)
                ax.set_xlim([-1,1])
                ##########################################################
                for plot_data in still_plot_data:
                    ax.plot([0, 0], plot_data[base_axis], 'r', linewidth=0.5)

                ##########################################################
                if show_values:
                    for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                        for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(just_mode_shape, still_plot_data[i][base_axis], linestyle=list_linestyles[msh_i], marker=list_markers[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                else:
                    for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                        for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(just_mode_shape, still_plot_data[i][base_axis], linestyle=list_linestyles[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                ##########################################################
                # for plot_data in deformed_links[mode_shape_counter]:
                #     just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                #     ax.plot(just_mode_shape, [plot_data[base_axis][0],plot_data[base_axis][0]], '--m')

                #     mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                #     if mode_shape_number != 0:
                #         x_text = just_mode_shape[1]/2
                #         y_text = plot_data[base_axis][0]
                #         ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')


                y_min, y_max = ax.get_ylim()
                y_scope = (y_max - y_min) / 5

                axis_x = 0
                axis_y = 6*y_scope
                if write_modal_info:
                    axis_x = 0.5
                    axis_y = 1.0
                    txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                    txt_axis.set_horizontalalignment('center')
                    txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                # if list_freqs != 0 and write_modal_info:
                #     # freq_x = 0
                #     # freq_y = 6.7*y_scope
                #     freq_x = 0.5
                #     freq_y = 1.25
                #     txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                #     txt_freq.set_horizontalalignment('center')
                #     txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                # if list_damps != 0 and write_modal_info:
                #     # damp_x = 0
                #     # damp_y = 6.35*y_scope
                #     damp_x = 0.5
                #     damp_y = 1.15
                #     txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                #     txt_damp.set_horizontalalignment('center')
                #     txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_damps != 0 and write_modal_info:
                    if isinstance(list_damps, dict) and len(list_damps) == len(deformed_plot_data_dict):
                        damp_comparative_list = []
                        for d_i in list_damps.keys():
                            damp_comparative_list.append(float('{:.2f}'.format(list_damps[d_i][mode_shape_counter]*100)))
                        # damp_x = x_middle
                        damp_x = 0.5
                        # damp_y = 1.2
                        damp_y = 1.15
                        txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {damp_comparative_list}%", ha='center', va='bottom', transform=ax.transAxes)
                        txt_damp.set_horizontalalignment('center')
                        txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_freqs != 0 and write_modal_info:
                    if isinstance(list_freqs, dict) and len(list_freqs) == len(deformed_plot_data_dict):
                        freq_comparative_list = []
                        for d_i in list_freqs.keys():
                            freq_comparative_list.append(float('{:.2f}'.format(list_freqs[d_i][mode_shape_counter])))
                        # freq_x = x_middle
                        freq_x = 0.5
                        # freq_y = 1.6
                        freq_y = 1.25
                        txt_freq = ax.text(freq_x, freq_y, f"frequency = {freq_comparative_list} Hz", ha='center', va='bottom', transform=ax.transAxes)
                        txt_freq.set_horizontalalignment('center')
                        txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                handles, labels = ax.get_legend_handles_labels()
                unique_labels = dict(zip(labels, handles))

                ax.legend(unique_labels.values(), unique_labels.keys(), loc='upper left', bbox_to_anchor=(1, 1))

                axes_string_counter += 1
                if axes_string_counter >= len(sensor_axes):
                    axes_string_counter = 0
            else:
                for ax in axes:
                    ax.grid()
                    # ax.set_xlabel(axes_string[axes_string_counter])
                    # ax.set_ylabel(base_axis)
                    ax.set_xlim([-1,1])
                    ##########################################################
                    for plot_data in still_plot_data:
                        ax.plot([0, 0], plot_data[base_axis], 'r', linewidth=0.5)

                    ##########################################################
                    if show_values:
                        for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                            for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                                just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                                ax.plot(just_mode_shape, still_plot_data[i][base_axis], linestyle=list_linestyles[msh_i], marker=list_markers[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                    else:
                        for msh_i, deformed_plot_data_name in enumerate(deformed_plot_data_dict.keys()):
                            for i, plot_data in enumerate(deformed_plot_data_dict[deformed_plot_data_name][mode_shape_counter]):
                                just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                                ax.plot(just_mode_shape, still_plot_data[i][base_axis], linestyle=list_linestyles[msh_i], color=colors[msh_i], label=deformed_plot_data_name)
                    ##########################################################
                    # for plot_data in deformed_links[mode_shape_counter]:
                    #     just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                    #     ax.plot(just_mode_shape, [plot_data[base_axis][0],plot_data[base_axis][0]], '--m')

                    #     mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                    #     if mode_shape_number != 0:
                    #         x_text = just_mode_shape[1]/2
                    #         y_text = plot_data[base_axis][0]
                    #         ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')


                    y_min, y_max = ax.get_ylim()
                    y_scope = (y_max - y_min) / 5

                    axis_x = 0
                    axis_y = 6*y_scope

                    if write_modal_info:
                        axis_x = 0.5
                        axis_y = 1.0
                        txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                        txt_axis.set_horizontalalignment('center')
                        txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))


                    if ax == axes[1] and write_modal_info:
                        # if list_freqs != 0 and write_modal_info:
                        #     # freq_x = 0
                        #     # freq_y = 6.7*y_scope
                        #     freq_x = 0.5
                        #     freq_y = 1.25
                        #     txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                        #     txt_freq.set_horizontalalignment('center')
                        #     txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        # if list_damps != 0 and write_modal_info:
                        #     # damp_x = 0
                        #     # damp_y = 6.35*y_scope
                        #     damp_x = 0.5
                        #     damp_y = 1.15
                        #     txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                        #     txt_damp.set_horizontalalignment('center')
                        #     txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        if list_damps != 0 and write_modal_info:
                            if isinstance(list_damps, dict) and len(list_damps) == len(deformed_plot_data_dict):
                                damp_comparative_list = []
                                for d_i in list_damps.keys():
                                    damp_comparative_list.append(float('{:.2f}'.format(list_damps[d_i][mode_shape_counter]*100)))
                                # damp_x = x_middle
                                damp_x = 0.5
                                # damp_y = 1.2
                                damp_y = 1.15
                                txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {damp_comparative_list}%", ha='center', va='bottom', transform=ax.transAxes)
                                txt_damp.set_horizontalalignment('center')
                                txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        if list_freqs != 0 and write_modal_info:
                            if isinstance(list_freqs, dict) and len(list_freqs) == len(deformed_plot_data_dict):
                                freq_comparative_list = []
                                for d_i in list_freqs.keys():
                                    freq_comparative_list.append(float('{:.2f}'.format(list_freqs[d_i][mode_shape_counter])))
                                # freq_x = x_middle
                                freq_x = 0.5
                                # freq_y = 1.6
                                freq_y = 1.25
                                txt_freq = ax.text(freq_x, freq_y, f"frequency = {freq_comparative_list} Hz", ha='center', va='bottom', transform=ax.transAxes)
                                txt_freq.set_horizontalalignment('center')
                                txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))
                    
                    if ax == axes[0]:
                        handles, labels = ax.get_legend_handles_labels()
                        unique_labels = dict(zip(labels, handles))

                        ax.legend(unique_labels.values(), unique_labels.keys(), loc='upper left', bbox_to_anchor=(1, 1))

                    axes_string_counter += 1
                    if axes_string_counter >= len(sensor_axes):
                        axes_string_counter = 0
    else:
        print('base_axis_align is not correctly assigned!')
    plt.show()






##################################################################################################################################################


def read_coordinate(file_name):
    df = pd.read_csv(file_name, header=None)
    for i in df.iloc[0]:
        if isinstance(i,str):
            df = pd.read_csv(file_name)
            break
    coords = np.array(df.iloc[:,:6].dropna(), dtype=float)
    links = np.array(df.iloc[:,6:].dropna(), dtype=int)

    return coords, links

def calculate_deformed_shape(coords, list_mode_shape, links):
    deformed_coords = []
    deformed_plot_data = []
    deformed_links = []
    for mode_shape in list_mode_shape:

        diff_coord = coords.copy()
        for i in range(len(mode_shape)):
            # print(diff_coord[diff_coord[:,1] == i+1][0])
            # print(diff_coord[diff_coord[:,1] == i+1, diff_coord[diff_coord[:,1] == i+1][0][-1]+1][0])
            row_coord = int(np.argwhere(diff_coord[:,1] == i+1)[0][0])
            col_coord = int(diff_coord[row_coord,-1] + 1)

            diff_coord[row_coord, col_coord] = diff_coord[row_coord, col_coord] + mode_shape[i]
        coords_consolidated, deformed_coords_consolidated = consolidate_coords(coords, diff_coord)
        if (mode_shape == list_mode_shape[0]).all():
            still_plot_data = plot_data_preparation(coords_consolidated, links)
        deformed_plot_data.append(plot_data_preparation(deformed_coords_consolidated, links))

        deformed_links.append(deformation_links_preparation(coords_consolidated, deformed_coords_consolidated))

        deformed_coords.append(deformed_coords_consolidated)

    return still_plot_data, deformed_plot_data, deformed_links

def plot_data_preparation(coords, links):
    plot_data = []
    for i in range(links.shape[0]):
        end1 = links[i,0]
        end2 = links[i,1]
        row1 = int(np.argwhere(coords[:,0] == end1)[0][0])
        row2 = int(np.argwhere(coords[:,0] == end2)[0][0])
        temp_x = (coords[row1,2], coords[row2,2])
        temp_y = (coords[row1,3], coords[row2,3])
        temp_z = (coords[row1,4], coords[row2,4])
        temp_data = {'x':temp_x, 'y':temp_y, 'z':temp_z}
        plot_data.append(temp_data)
    # print(plot_data)
    return plot_data

def deformation_links_preparation(coords, deformed_coords):
    plot_links_data = []
    for i in range(coords.shape[0]):
        if coords[i,5] != 0:
            diff_x = (coords[i,2],  deformed_coords[i,2])
            diff_y = (coords[i,3],  deformed_coords[i,3])
            diff_z = (coords[i,4],  deformed_coords[i,4])
            deform_diff = {'x':diff_x, 'y':diff_y, 'z':diff_z}
            plot_links_data.append(deform_diff)
    return plot_links_data

def consolidate_coords(coords, deformed_coords):
    coords_consolidated = coords[0,:].copy().reshape(1,-1)
    deformed_coords_consolidated = deformed_coords[0,:].copy().reshape(1,-1)
    nodes_checked = [coords[0,0]]
    for i in range(1,coords.shape[0]):
        if coords[i,0] not in nodes_checked:
            nodes_checked.append(coords[i,0])
            coords_consolidated = np.concatenate((coords_consolidated, coords[i,:].reshape(1,-1)), axis=0)
            deformed_coords_consolidated = np.concatenate((deformed_coords_consolidated, deformed_coords[i,:].reshape(1,-1)), axis=0)

        else:
            row_old = int(np.argwhere(coords_consolidated[:,0] == coords[i,0])[0][0])
            if coords[i,2] != deformed_coords[i,2]:
                deformed_coords_consolidated[row_old,2] = deformed_coords[i,2]
            if coords[i,3] != deformed_coords[i,3]:
                deformed_coords_consolidated[row_old,3] = deformed_coords[i,3]
            if coords[i,4] != deformed_coords[i,4]:
                deformed_coords_consolidated[row_old,4] = deformed_coords[i,4]
    return coords_consolidated, deformed_coords_consolidated

def draw_plots(coords, still_plot_data, deformed_plot_data, deformed_links, base_axis='z', base_axis_align='horizontal',list_freqs=0, list_damps=0, normalization_type='max', custom_ylim=None,write_modal_info=False, no_info_at_all=False, show_values=True):
    sensor_axes = []
    for i in coords[:, 5]:
        if int(i) not in sensor_axes and i != 0:
            sensor_axes.append(int(i))
    sensor_axes.sort()
    axes_string = ''
    for i in sensor_axes:
        axes_string += 'xyz'[i-1]
    n_modes = len(deformed_plot_data)


    if base_axis_align == 'horizontal':

        axes_string_counter = 0
        for mode_shape_counter in range(n_modes):
            fig, axes = plt.subplots(len(sensor_axes), 1, sharex=True,figsize=(10, 2*len(sensor_axes)))
            plt.subplots_adjust(wspace=0.2, hspace=0.1)
            if list_freqs == 0 or not write_modal_info and not no_info_at_all:
                fig.suptitle(f'mode: {mode_shape_counter+1}')
            elif not no_info_at_all :
                fig.suptitle(f'   ')
            if len(sensor_axes) == 1:
                ax = axes
                ax.grid()
                # ax.set_ylabel(axes_string[axes_string_counter])
                # ax.set_xlabel(base_axis)
                if normalization_type == 'max':
                    ax.set_ylim([-1.05,1.05])
                elif normalization_type == 'norm':
                    if custom_ylim != None:
                        ax.set_ylim(custom_ylim)
                    pass
                ##########################################################
                for plot_data in still_plot_data:
                    ax.plot(plot_data[base_axis], [0, 0], 'r', linewidth=0.5)

                ##########################################################
                if not show_values:
                    for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                        ax.plot(still_plot_data[i][base_axis], just_mode_shape, '-b')
                else:
                    for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                        ax.plot(still_plot_data[i][base_axis], just_mode_shape, '-bo')
                ##########################################################
                if show_values:
                    for plot_data in deformed_links[mode_shape_counter]:
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                        ax.plot([plot_data[base_axis][0],plot_data[base_axis][0]], just_mode_shape, '--m')

                        mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                        if mode_shape_number != 0:
                            y_text = just_mode_shape[1]/2
                            x_text = plot_data[base_axis][0]
                            ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')

                x_min, x_max = ax.get_xlim()
                x_middle = (x_max + x_min) / 2

                axis_x = x_middle
                axis_y = 0.75
                if write_modal_info:
                    axis_x = 0.5
                    axis_y = 1.0
                    txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                    txt_axis.set_horizontalalignment('center')
                    txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_damps != 0 and write_modal_info:
                    # damp_x = x_middle
                    damp_x = 0.5
                    # damp_y = 1.2
                    damp_y = 1.25
                    txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                    txt_damp.set_horizontalalignment('center')
                    txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_freqs != 0 and write_modal_info:
                    # freq_x = x_middle
                    freq_x = 0.5
                    # freq_y = 1.6
                    freq_y = 1.45
                    txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                    txt_freq.set_horizontalalignment('center')
                    txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                axes_string_counter += 1
                if axes_string_counter >= len(sensor_axes):
                    axes_string_counter = 0
            else:
                for ax in axes:
                    ax.grid()
                    # ax.set_ylabel(axes_string[axes_string_counter])
                    # ax.set_xlabel(base_axis)
                    if normalization_type == 'max':
                        ax.set_ylim([-1.05,1.05])
                    elif normalization_type == 'norm':
                        if custom_ylim != None:
                            ax.set_ylim(custom_ylim)
                        pass
                    ##########################################################
                    for plot_data in still_plot_data:
                        ax.plot(plot_data[base_axis], [0, 0], 'r', linewidth=0.5)
                    ##########################################################
                    if not show_values:
                        for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(still_plot_data[i][base_axis], just_mode_shape, '-b')
                    else:
                        for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(still_plot_data[i][base_axis], just_mode_shape, '-bo')
                    ##########################################################
                    if show_values:
                        for plot_data in deformed_links[mode_shape_counter]:
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                            ax.plot([plot_data[base_axis][0],plot_data[base_axis][0]], just_mode_shape, '--m')

                            mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                            if mode_shape_number != 0:
                                y_text = just_mode_shape[1]/2
                                x_text = plot_data[base_axis][0]
                                ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')

                    x_min, x_max = ax.get_xlim()
                    x_middle = (x_max + x_min) / 2

                    axis_x = x_middle
                    axis_y = 0.75
                    if write_modal_info:
                        axis_x = 0.5
                        axis_y = 1.0
                        txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                        txt_axis.set_horizontalalignment('center')
                        txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))


                    if ax == axes[0]:
                        if list_damps != 0 and write_modal_info:
                            # damp_x = x_middle
                            damp_x = 0.5
                            # damp_y = 1.2
                            damp_y = 1.25
                            txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                            txt_damp.set_horizontalalignment('center')
                            txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        if list_freqs != 0 and write_modal_info:
                            # freq_x = x_middle
                            freq_x = 0.5
                            # freq_y = 1.6
                            freq_y = 1.45
                            txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                            txt_freq.set_horizontalalignment('center')
                            txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                    axes_string_counter += 1
                    if axes_string_counter >= len(sensor_axes):
                        axes_string_counter = 0

###############################################################################
###############################################################################
###############################################################################
###############################################################################

    elif base_axis_align == 'vertical':
        for mode_shape_counter in range(n_modes):
            fig, axes = plt.subplots(1, len(sensor_axes), sharey=True, figsize=(2*len(sensor_axes),5))
            plt.subplots_adjust(wspace=0.2, hspace=0.1)
            if list_freqs == 0 or not write_modal_info and not no_info_at_all:
                fig.suptitle(f'mode: {mode_shape_counter+1}')
            elif not no_info_at_all:
                fig.suptitle(f'   ')
            axes_string_counter = 0
            if len(sensor_axes) == 1:
                ax = axes
                ax.grid()
                # ax.set_xlabel(axes_string[axes_string_counter])
                # ax.set_ylabel(base_axis)
                ax.set_xlim([-1,1])
                ##########################################################
                for plot_data in still_plot_data:
                    ax.plot([0, 0], plot_data[base_axis], 'r', linewidth=0.5)

                ##########################################################
                if not show_values:
                    for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                        ax.plot(just_mode_shape, still_plot_data[i][base_axis], '-b')
                else:
                    for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                        ax.plot(just_mode_shape, still_plot_data[i][base_axis], '-bo')

                ##########################################################
                if show_values:
                    for plot_data in deformed_links[mode_shape_counter]:
                        just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                        ax.plot(just_mode_shape, [plot_data[base_axis][0],plot_data[base_axis][0]], '--m')

                        mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                        if mode_shape_number != 0:
                            x_text = just_mode_shape[1]/2
                            y_text = plot_data[base_axis][0]
                            ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')


                y_min, y_max = ax.get_ylim()
                y_scope = (y_max - y_min) / 5

                axis_x = 0
                axis_y = 6*y_scope
                if write_modal_info:
                    axis_x = 0.5
                    axis_y = 1.0
                    txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                    txt_axis.set_horizontalalignment('center')
                    txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_freqs != 0 and write_modal_info:
                    # freq_x = 0
                    # freq_y = 6.7*y_scope
                    freq_x = 0.5
                    freq_y = 1.25
                    txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                    txt_freq.set_horizontalalignment('center')
                    txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                if list_damps != 0 and write_modal_info:
                    # damp_x = 0
                    # damp_y = 6.35*y_scope
                    damp_x = 0.5
                    damp_y = 1.15
                    txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                    txt_damp.set_horizontalalignment('center')
                    txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                axes_string_counter += 1
                if axes_string_counter >= len(sensor_axes):
                    axes_string_counter = 0
            else:
                for ax in axes:
                    ax.grid()
                    # ax.set_xlabel(axes_string[axes_string_counter])
                    # ax.set_ylabel(base_axis)
                    ax.set_xlim([-1,1])
                    ##########################################################
                    for plot_data in still_plot_data:
                        ax.plot([0, 0], plot_data[base_axis], 'r', linewidth=0.5)

                    ##########################################################
                    if not show_values:
                        for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(just_mode_shape, still_plot_data[i][base_axis], '-b')
                    else:
                        for i, plot_data in enumerate(deformed_plot_data[mode_shape_counter]):
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(still_plot_data[i][axes_string[axes_string_counter]])
                            ax.plot(just_mode_shape, still_plot_data[i][base_axis], '-bo')

                    ##########################################################
                    if show_values:
                        for plot_data in deformed_links[mode_shape_counter]:
                            just_mode_shape = np.array(plot_data[axes_string[axes_string_counter]]) - np.array(plot_data[axes_string[axes_string_counter]][0])
                            ax.plot(just_mode_shape, [plot_data[base_axis][0],plot_data[base_axis][0]], '--m')

                            mode_shape_number = plot_data[axes_string[axes_string_counter]][1]-plot_data[axes_string[axes_string_counter]][0]
                            if mode_shape_number != 0:
                                x_text = just_mode_shape[1]/2
                                y_text = plot_data[base_axis][0]
                                ax.text(x_text, y_text, f"{axes_string[axes_string_counter]}: {'{:.2f}'.format(mode_shape_number)}", fontsize = 'small')


                    y_min, y_max = ax.get_ylim()
                    y_scope = (y_max - y_min) / 5

                    axis_x = 0
                    axis_y = 6*y_scope

                    if write_modal_info:
                        axis_x = 0.5
                        axis_y = 1.0
                        txt_axis = ax.text(axis_x, axis_y, f"axis = {axes_string[axes_string_counter]}", ha='center', va='top', transform=ax.transAxes)
                        txt_axis.set_horizontalalignment('center')
                        txt_axis.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))


                    if ax == axes[1] and write_modal_info:
                        if list_freqs != 0:
                            # freq_x = 0
                            # freq_y = 6.7*y_scope
                            freq_x = 0.5
                            freq_y = 1.25
                            txt_freq = ax.text(freq_x, freq_y, f"frequency = {'{:.2f}'.format(list_freqs[mode_shape_counter])} Hz", ha='center', va='bottom', transform=ax.transAxes)
                            txt_freq.set_horizontalalignment('center')
                            txt_freq.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                        if list_damps != 0 and write_modal_info:
                            # damp_x = 0
                            # damp_y = 6.35*y_scope
                            damp_x = 0.5
                            damp_y = 1.15
                            txt_damp = ax.text(damp_x, damp_y, f"damping ratio = {'{:.2f}'.format(list_damps[mode_shape_counter]*100)}%", ha='center', va='bottom', transform=ax.transAxes)
                            txt_damp.set_horizontalalignment('center')
                            txt_damp.set_bbox(dict(facecolor='red', alpha=0.2, edgecolor='red'))

                    axes_string_counter += 1
                    if axes_string_counter >= len(sensor_axes):
                        axes_string_counter = 0
    else:
        print('base_axis_align is not correctly assigned!')
    plt.show()

def COMAC(modeshape1, modeshape2):
    """
    This function calculates COMAC or Coordinate Modal Similarity vector considering all modes.

    :param modeshape1: A list of mode shapes.
    :param modeshape2: A list of mode shapes.
    :return:
        - COMAC: a vector containing COMAC values for each coordinate.
    """

    l = modeshape1[0].shape[0]
    N_modes = len(modeshape1)
    comac = np.zeros_like(modeshape1[0])

    for j in range(l):
        sum_1 = 0.
        sum_2 = 0.
        sum_3 = 0.
        for i in range(N_modes):
            sum_1 += modeshape1[i][j]*modeshape2[i][j]
            sum_2 += modeshape1[i][j]*modeshape1[i][j].conj()
            sum_3 += modeshape2[i][j]*modeshape2[i][j].conj()
        comac[j] = sum_1**2/(sum_2*sum_3)
    return comac

def draw_MAC_diagram(modeshape1, modeshape2, frequency1=(), frequency2=(), damping1=(), damping2=(),  labels=(), diagram_type='2D', modal_similarity_criterion=False, modal_similarity_function_type=1,frequency_var='auto'):
    """
    This function draws MAC or Modal Similarity Diagram between two set of modal properties.

    :param modeshape1: A list of mode shapes.
    :param modeshape2: A list of mode shapes.
    :param frequency1: frequency1 can be provided to get shown in the MAC diagram. (If provided, its size must match that of modeshape1)
    :param frequency2: frequency2 can be provided to get shown in the MAC diagram. If provided, its size must match that of modeshape2)
    :param labels: A list of two strings to add label to each axis of MAX diagram.
    :param diagram_type: ('2D' or '3D') indicates the visual type of the MAC diagram.
    :param modal_similarity_criterion: If False, the conventional MAC matrix is shown. If True and frequency1 and frequency1 are provided a modal similarity criterion is calculated and will be shown.
    :param modal_similarity_function_type: (1 or 2) There is two different way to calculate mean of the similarity of frequencies and mode shapes.
    :param frequency_var: This parameter is better to be set to 'auto'. It is the standard deviation of the frequency similarity's Gaussian function.
    """
    def min_freq_distance_calc(freq1, freq2):
        freq1 = np.array(freq1)
        freq2 = np.array(freq2)
        d_f1 = freq1[1:] - freq1[:-1]
        d_f2 = freq2[1:] - freq2[:-1]

        min_freq_dis = np.min((np.min(d_f1), np.min(d_f2))) / 2
        a = min_freq_dis/1.268 # 80% error for half band distance
        # a = min_freq_dis/1.517 # 90% error for half band distance

        return a
    mac = MAC(modeshape1, modeshape2)
    if modal_similarity_criterion and len(frequency1) == len(modeshape1) and len(frequency2) == len(modeshape2):
        Delta_M = 1 - mac

        if modal_similarity_function_type == 1:
            Delta_F = np.zeros(Delta_M.shape)
            if frequency_var=='auto':
                frequency_var = min_freq_distance_calc(frequency1, frequency2)
            for i in range(len(frequency1)):
                for j in range(len(frequency2)):
                    del_f = frequency1[i]-frequency2[j]
                    Delta_F[i,j] = 1 - np.exp(-del_f**2/frequency_var**2)
            # The name of the variable will still be mac, but it is in fact the modal similarity
            mac = 1 - np.sqrt((Delta_M**2 + Delta_F**2)/2)

        elif modal_similarity_function_type == 2:
            Delta_F = np.zeros(Delta_M.shape)
            if len(damping1) == len(modeshape1) and len(damping2) == len(modeshape2):

                lambda_1 = np.zeros(len(frequency1), dtype=complex)
                lambda_2 = np.zeros(len(frequency2), dtype=complex)
                
                for i in range(len(frequency1)):
                    lambda_1[i] = - np.abs(2 * np.pi * frequency1[i]) * damping1[i] + 2j * np.pi * frequency1[i] * (np.sqrt(1-damping1[i]**2))

                for i in range(len(frequency2)):
                    lambda_2[i] = - np.abs(2 * np.pi * frequency2[i]) * damping2[i] + 2j * np.pi * frequency2[i] * (np.sqrt(1-damping2[i]**2))

                for i in range(len(frequency1)):
                    for j in range(len(frequency2)):
                        del_lambda = np.abs(lambda_1[i]-lambda_2[j])
                        # print('np.max([np.abs(lambda_1[i]), np.abs(lambda_2[i])])', np.max([np.abs(lambda_1[i]), np.abs(lambda_2[i])]))
                        Delta_F[i,j] = np.abs(del_lambda)/np.max([np.abs(lambda_1[i]), np.abs(lambda_2[j])])
            else:

                for i in range(len(frequency1)):
                    for j in range(len(frequency2)):
                        del_f = frequency1[i]-frequency2[j]
                        Delta_F[i,j] = np.abs(del_f)/np.max([frequency1[i], frequency2[j]])
            # The name of the variable will still be mac, but it is in fact the modal similarity
            mac = 1- Delta_M + Delta_F

    elif modal_similarity_criterion:
        print('The frequencies are not provided!')
        print('The conventional MAC matrix will be shown!')
        modal_similarity_criterion = False


    if diagram_type == '2D':
        fig, ax = plt.subplots(1, 1, figsize=(7, 7))
        ax.tick_params(axis='x', which='both', top=True, bottom=False)
        ax.xaxis.set_label_position('top')
        ax.xaxis.tick_top()
        if len(frequency1) == len(modeshape1) and len(frequency2) == len(modeshape2):
            ax.set_yticks(range(len(frequency1)), [f'f={i:.2f} Hz' for i in frequency1], rotation=45)
            ax.set_xticks(range(len(frequency2)), [f'f={i:.2f} Hz' for i in frequency2], rotation=45)
        elif len(frequency1) == len(modeshape1):
            ax.set_yticks(range(len(modeshape1)), [f'f={i:.2f} Hz' for i in frequency1], rotation=45)
            ax.set_xticks(range(len(modeshape2)), [f'mode no.{i}' for i in range(1, len(modeshape2) + 1)], rotation=45)
        elif len(frequency2) == len(modeshape2):
            ax.set_yticks(range(len(modeshape1)), [f'mode no.{i}' for i in range(1, len(modeshape1) + 1)], rotation=45)
            ax.set_xticks(range(len(frequency2)), [f'f={i:.2f} Hz' for i in frequency2], rotation=45)
        else:
            ax.set_yticks(range(len(modeshape1)), [f'mode no.{i}' for i in range(1, len(modeshape1) + 1)], rotation=45)
            ax.set_xticks(range(len(modeshape2)), [f'mode no.{i}' for i in range(1, len(modeshape2) + 1)], rotation=45)

        for i in range(mac.shape[0]):
            for j in range(mac.shape[1]):
                ax.text(j, i, f'{mac[i, j]:.2f}', ha='center', va='center',
                        color='white' if mac[i, j] < 0.5 else 'black')
        ax.imshow(mac, data=mac, cmap='bone', vmin=0, vmax=1)
        if modal_similarity_criterion:
            ax.set_title('Modal Similarity Matrix')
        else:
            ax.set_title('MAC Matrix')

        if len(labels) == 2:
            ax.set_xlabel(f'Mode Shapes of {labels[1]}')
            ax.set_ylabel(f'Mode Shapes of {labels[0]}')
        else:
            ax.set_xlabel('Second Mode Shape Group')
            ax.set_ylabel('First Mode Shape Group')
        plt.show()

    elif diagram_type == '3D':
        x = np.arange(mac.shape[0])
        y = np.arange(mac.shape[1])
        x, y = np.meshgrid(x, y)

        dx = 0.7
        dy = 0.7
        dz = mac.flatten()

        x = x.flatten() - dx / 2
        y = y.flatten() - dy / 2
        z = np.zeros_like(x)

        fig = plt.figure(figsize=(10, 15))
        ax = fig.add_subplot(1, 1, 1, projection='3d')

        norm = Normalize(vmin=0, vmax=1)
        colors = cm.bone(norm(dz))
        ax.bar3d(x, y, z, dx, dy, dz, color=colors, shade=True)

        if len(labels) == 2:
            ax.set_xlabel(f'Mode Shapes of {labels[0]}', labelpad=40, rotation=70)
            ax.set_ylabel(f'Mode Shapes of {labels[1]}', labelpad=40, rotation=42)
        else:
            ax.set_xlabel('First Mode Shape Group', labelpad=40, rotation=70)
            ax.set_ylabel('Second Mode Shape Group', labelpad=40, rotation=42)
        # ax.set_zlabel('MAC')

        ax.set_zlim(0, 1)

        if len(frequency1) == len(modeshape1) and len(frequency2) == len(modeshape2):
            ax.set_xticks(range(len(frequency1)), [f'f={i:.2f} Hz' for i in frequency1], rotation=48, ha='right')
            ax.set_yticks(range(len(frequency2)), [f'f={i:.2f} Hz' for i in frequency2], rotation=-20, ha='center',
                          va='bottom')
        elif len(frequency1) == len(modeshape1):
            ax.set_xticks(range(len(modeshape1)), [f'f={i:.2f} Hz' for i in frequency1], rotation=48, ha='right')
            ax.set_yticks(range(len(modeshape2)), [f'mode no.{i}' for i in range(1, len(modeshape2) + 1)], rotation=-20,
                          ha='center', va='bottom')
        elif len(frequency2) == len(modeshape2):
            ax.set_xticks(range(len(modeshape1)), [f'mode no.{i}' for i in range(1, len(modeshape1) + 1)], rotation=48,
                          ha='right')
            ax.set_yticks(range(len(frequency2)), [f'f={i:.2f} Hz' for i in frequency2], rotation=-20, ha='center',
                          va='bottom')
        else:
            ax.set_xticks(range(len(modeshape1)), [f'mode no.{i}' for i in range(1, len(modeshape1) + 1)], rotation=48,
                          ha='right')
            ax.set_yticks(range(len(modeshape2)), [f'mode no.{i}' for i in range(1, len(modeshape2) + 1)], rotation=-20,
                          ha='center', va='bottom')
        ax.xaxis.set_tick_params(pad=-5)
        ax.yaxis.set_tick_params(pad=25)
        if modal_similarity_criterion:
            ax.set_title('Modal Similarity Matrix')
        else:
            ax.set_title('MAC Matrix')

        for i in range(len(dz)):
            if dz[i] >= 0.8:
                ax.text(x[i] + dx / 2, y[i] + dy / 2, dz[i], f'{dz[i]:.2f}', rotation=-80, ha='center', va='bottom',
                        color='k')
            # else:
            #     ax.text(x[i]+dx/2, y[i]+dy/2, dz[i], f'{dz[i]:.2f}', rotation=-80, ha='center', va='bottom', color='w')

        # plt.subplots_adjust(left=0.15, right=0.85, top=0.85, bottom=0.15)
        # plt.tight_layout(pad=2.0)
        plt.show()


def MAC(msh1, msh2):
    len_msh1 = len(msh1)
    len_msh2 = len(msh2)
    mac = np.zeros((len_msh1, len_msh2))
    for i in range(len_msh1):
        for j in range(len_msh2):
            mac[i, j] = np.dot(msh1[i], msh2[j]) ** 2 / (np.dot(msh1[i], msh1[i]) * np.dot(msh2[j], msh2[j]))
    return mac



def split_and_pad_arrays(mode_shapes):
    result = []

    for arr in mode_shapes:
        if len(arr) != 24:
            raise ValueError("Each array must be of length 24")

        group0 = arr[0::3]  # i % 3 == 0
        group1 = arr[1::3]  # i % 3 == 1
        group2 = arr[2::3]  # i % 3 == 2

        # Pad each with 0 at both ends
        padded0 = np.pad(group0, (1, 1), constant_values=0)
        padded1 = np.pad(group1, (1, 1), constant_values=0)
        padded2 = np.pad(group2, (1, 1), constant_values=0)

        result.append([padded0, padded1, padded2])

    return result

def spline_interpolate_split_arrays(x, data_split, n=100, order=3):
    """
    Interpolate each set of split-and-padded arrays using spline interpolation.

    Parameters:
    - x: np.ndarray, original x positions (length 10)
    - data_split: list of lists, where each element is [array_x, array_y, array_z] of len 10
    - n: int, number of interpolation points
    - order: int, spline order (3 for cubic)

    Returns:
    - x_interp: np.ndarray, interpolated x positions (length n)
    - result: list of n elements, each a list of 3 interpolated arrays of length n
    """
    if len(x) != 10:
        raise ValueError("x must be of length 10 (matching padded array length)")

    x_interp = np.linspace(x.min(), x.max(), n)
    result = []

    for triple in data_split:
        interpolated = []
        for u in triple:
            if len(u) != len(x):
                raise ValueError("Each array in triple must be length 10")

            spline = make_interp_spline(x, u, k=order)
            u_interp = spline(x_interp)
            interpolated.append(u_interp)
        result.append(interpolated)

    return x_interp, result

def generate_node_csv(x, filename='output.csv', print_state=True):
    n = len(x)

    header = ['node number', 'sensor number', 'x', 'y', 'z', 'direction', 'node link 1', 'node link 2']
    rows = []

    # First node (only one row)
    # rows.append([1, 1, x[0], 0, 0, 1, 1, 2])  # direction=1
    sensor_counter = 1  # already used 1
    node_link_counter = 1
    

    # Middle nodes (3 rows per node)
    for i in range(0, n):
        for d in range(1, 4):  # directions 1, 2, 3
            if sensor_counter > n-1:
                row = [
                i + 1,                # node number
                sensor_counter,       # sensor number
                x[i],                 # x
                0,                    # y
                0,                    # z
                d,                    # direction
                # node_link_counter,    # node link 1
                # node_link_counter + 1 # node link 2
                # '', '',
                ]
            else:
                row = [
                    i + 1,                # node number
                    sensor_counter,       # sensor number
                    x[i],                 # x
                    0,                    # y
                    0,                    # z
                    d,                    # direction
                    sensor_counter,    # node link 1
                    sensor_counter + 1 # node link 2
                    # '', '',
                ]
            rows.append(row)
            sensor_counter += 1
            node_link_counter += 1

    # for i in range(n - 1):
    #     row = ['', '', '', '', '', '', i + 1, i + 2]
    #     rows.append(row)

    # Last node (only one row)
    # rows.append([n, sensor_counter, x[-1], 0, 0, 1, n - 1, n])  # direction=1

    # Write to CSV
    with open(filename, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(header)
        writer.writerows(rows)
    if print_state:
        print(f"CSV saved to {filename}")

def merge_split_arrays(interp_result):
    """
    Inverts the split_and_pad_arrays effect by interleaving the 3 interpolated arrays.

    Parameters:
    - interp_result: list of n elements, each a list of 3 arrays of length m

    Returns:
    - merged: list of n arrays, each of length 3 * m
    """
    merged = []

    for triple in interp_result:
        if len(triple) != 3:
            raise ValueError("Each item must contain exactly 3 arrays.")

        a, b, c = triple
        if not (len(a) == len(b) == len(c)):
            raise ValueError("All three arrays must be the same length.")

        # Interleave the three arrays
        interleaved = np.empty((3 * len(a),), dtype=a.dtype)
        interleaved[0::3] = a
        interleaved[1::3] = b
        interleaved[2::3] = c

        merged.append(interleaved)

    return merged

def SPLine_comparative_mode_shape(x, mode_shape_list, n=100, order=3, csv_name=None):
    import os
    if csv_name == None:
        delete_csv = True
        csv_name = 'SPLine_interpolated.csv'
        print_state = False
    else:
        delete_csv = False
        print_state = True

    if isinstance(mode_shape_list, list):
        mode_shape_list_split = split_and_pad_arrays(mode_shape_list)
        x_interp, mode_shape_interp = spline_interpolate_split_arrays(x, 
                                            mode_shape_list_split, n=n, order=order)
        mode_shape_interp_merged = merge_split_arrays(mode_shape_interp)

        generate_node_csv(x_interp, filename=csv_name, print_state=print_state)
        draw_mode_shapes(coord_file_name=csv_name, list_mode_shapes=mode_shape_interp_merged, base_axis='x', base_axis_align='horizontal', show_values=False)
        if delete_csv:
            if os.path.exists(csv_name):
                os.remove(csv_name)

    elif isinstance(mode_shape_list, dict):
        interpolated_mode_shape_dict = {}
        for case_name, each_mode_shape in mode_shape_list.items():
            
            mode_shape_list_split = split_and_pad_arrays(each_mode_shape)
            x_interp, mode_shape_interp = spline_interpolate_split_arrays(x, 
                                                mode_shape_list_split, n=n, order=order)
            mode_shape_interp_merged = merge_split_arrays(mode_shape_interp)

            if case_name == list(mode_shape_list.keys())[0]:
                generate_node_csv(x_interp, filename=csv_name, print_state=print_state)

            interpolated_mode_shape_dict.update({case_name:mode_shape_interp_merged})
            
        draw_mode_shapes(coord_file_name=csv_name, list_mode_shapes=interpolated_mode_shape_dict, base_axis='x', base_axis_align='horizontal', show_values=False)
        if delete_csv:
            if os.path.exists(csv_name):
                os.remove(csv_name)


    elif isinstance(mode_shape_list, str):
        mode_shape_list = extract_pkl_files(mode_shape_list)
        try:
            interpolated_mode_shape_dict = {}
            for case_name, each_mode_shape in mode_shape_list.items():
                
                mode_shape_list_split = split_and_pad_arrays(each_mode_shape)
                x_interp, mode_shape_interp = spline_interpolate_split_arrays(x, 
                                                    mode_shape_list_split, n=n, order=order)
                mode_shape_interp_merged = merge_split_arrays(mode_shape_interp)

                if case_name == list(mode_shape_list.keys())[0]:
                    generate_node_csv(x_interp, filename=csv_name, print_state=print_state)

                interpolated_mode_shape_dict.update({case_name:mode_shape_interp_merged})
                
            draw_mode_shapes(coord_file_name=csv_name, list_mode_shapes=interpolated_mode_shape_dict, base_axis='x', base_axis_align='horizontal', show_values=False)
            if delete_csv:
                if os.path.exists(csv_name):
                    os.remove(csv_name)
        except:
            print('The address is not right, or there is no pickle files in the folder!')


def extract_pkl_files(folder_path):
    extracted_objects = {}

    # Loop through all files in the specified folder
    for filename in os.listdir(folder_path):
        if filename.endswith('.pkl'):
            file_path = os.path.join(folder_path, filename)
            with open(file_path, 'rb') as file:
                # Load the pickle file
                obj = pickle.load(file)
                key = os.path.splitext(filename)[0]
                extracted_objects[key] = obj['msh']

    return extracted_objects