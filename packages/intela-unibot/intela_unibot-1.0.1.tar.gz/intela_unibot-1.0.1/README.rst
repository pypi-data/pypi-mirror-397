==============
Uni Bot Plugin
==============

Features
########

The plugin has the next features:

- the Uni Bot instructor widget rendering
- edX data collection: course structure, the user location in the course
- Uni Bot-related API endpoints
- Uni Bot notification about a course creation
- authentication bridge between Uni Bot, Uni Bot widgets and edX

Uni Bot instructor widget modes
*******************************
The Uni Bot instructor widget has the next modes:

- `custom_widget_in_separate_tab` - embeds the custom React application for the
  widget rendering into a separate course tab
- `embedded_widget_in_separate_tab` - embeds the external widget into a separate
  course tab
- `embedded_widget_in_instructor_tab` - embeds the external widget into the
default instructor course tab

Embedding external Uni Bot instructor widget
********************************************

Usage
============================

To display the Uni Bot widget content if the mode allows for external widget
embedding, it is needed to specify ``UNIBOT_INSTRUCTOR_WIDGET_SCRIPT`` setting
value. It should be the ``<script>`` tag.

Script embedding limitations
============================

If your external script embeds iframe-based widget, you should consider the
next limitations:

1. To avoid CORS-related problems, it is needed to specify your iframe host in
   ``CORS_ORIGIN_WHITELIST`` settings. For example:

.. code-block:: python

   CORS_ORIGIN_WHITELIST = ['trusted.domain.com']

2. If you need to share session between the iframe and edX, you have several options:
  1. Set Edx cookies ``SAMESITE`` attribute to ``'None'`` that can cause CSRF vulnerabilities.
      To do it, you need to set the next settings:

      .. code-block:: python

          CSRF_COOKIE_SECURE = True
          SESSION_COOKIE_SECURE = True
          CSRF_COOKIE_SAMESITE = 'None'
          SESSION_COOKIE_SAMESITE = 'None'

      Also, you may need to set ``secure`` to ``True`` and ``samesite`` to ``'None'`` for all other
      cookies that are not controlled by settings. To do it, you need to somehow override
      ``standard_cookie_settings`` from `edx-platform/openedx/core/djangoapps/user_authn/cookies.py`
      or do it using a custom middleware.

  2. Using PostMessage API for the cookies passing from parent window to iframe.
  3. Oauth2 tokens usage.

API requests headers embedding
*****************
When the plugin makes requests to Uni Bot API, it embeds headers to them:
- `X-Api-Key` is added to all requests for authentication purpose
- `X-User-Username` and `X-User-Email` are added for the mutation (POST/PUT/
DELETE) requests related to widget instructor-made actions

Dynamic configuration
#####################
The plugin supports changing some settings dynamically from the Django Admin panel.
The configuration in available from `<LMS_URL>/admin/uni_bot/unibotsettingsconfiguration/` endpoint.
Settings from the Admin panel have a higher priority than Django settings with the same name.

The possible options are described in the table below.

.. list-table::
   :header-rows: 1

   * - Setting name
     - Default value
     - Description
   * - INCLUDE_FILE_CONTENT_DURING_DATA_COLLECTION
     - `True`
     - whether to include base64-encoded course data file content (video
       transcripts, SCORM files etc.) into the result during course data
       collection
   * - UNIBOT_API_KEY
     - `'extremely_strong_key'`
     - the API key used to authenticate the request to the UniBot backend
   * - UNIBOT_BASE_URL
     - `'https://example.com'`
     - the bot base URL (schema with domain)
   * - UNIBOT_INSTRUCTOR_WIDGET_DISPLAYING_MODE
     - `'custom_widget_in_separate_tab'`
     - the mode in which to display Uni Bot instructor widget
   * - UNIBOT_INSTRUCTOR_WIDGET_SCRIPT
     - `'<script>console.log("Unibot script example");</script>'`
     - the script tag to insert into the page to load the Uni Bot instructor
       widget if the mode allows for external widget embedding
   * - UNIBOT_JWT_SECRET_KEY
     - `'strong_secret_key'`
     - the secret key used for signing or verifying the integrity and
       authenticity of generated by the plugin JWT token for the user
       authenticated by session

Installation
############

Open edX devstack
*****************

- Clone this repo in the src folder of your devstack.
- Open a new Lms/Devstack shell.
- Install the plugin as follows: pip install -e /path/to/your/src/folder
- Restart Lms/Studio services.

Usage
#####

Frontend Application
####################

The frontend of our application is built using React and is located in the ``/uni_bot/frontend-app`` directory. Below, you'll find instructions for setting up and running the frontend application both for local development and for building the production version.

Local Development
*****************

To start developing locally, you'll need to run the local development server. This provides a live-reloading environment, making it easier to see your changes in real-time.

**Install dependencies:**
.. code-block::
  npm install

This command install all necessary dependencies for future work.

**Start the local server:**
.. code-block::
  npm run dev

This command starts the local server, allowing you to preview your changes instantly.

**Watch for changes and build:**
.. code-block::
  npm run build:watch

This command watches for any changes in the source files and automatically rebuilds the application. This is useful for continuous development without having to manually rebuild after every change.

Building for Production
***********************

When you are ready to build the frontend application for production, you can use the following command:

**Build the application:**
.. code-block::
  npm run build

This command creates an optimized production build of the application, which is ready to be deployed.

Testing and code quality
#####

For running tests locally use the following command:
.. code-block::
    make python-test

For running python style checkers use the following command:
.. code-block::
    make quality

Pre-commit hooks
#####

Run :code:`pre-commit install` to install pre-commit into your git hooks. pre-commit will now run on every commit. Every time you clone a project using pre-commit running :code:`pre-commit install` should always be the first thing you do.

If you want to manually run all pre-commit hooks on a repository, run :code:`pre-commit run --all-files`. To run individual hooks use :code:`pre-commit run <hook_id>`.


Contributing
############

Add your contribution policy. (If required)
