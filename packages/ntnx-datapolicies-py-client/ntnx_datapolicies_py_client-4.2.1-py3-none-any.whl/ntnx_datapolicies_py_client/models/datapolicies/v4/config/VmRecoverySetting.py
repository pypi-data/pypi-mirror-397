# coding: utf-8


"""
IGNORE:
    Nutanix Data Policies APIs

    Manage Policies for Disaster Recovery and Storage.  # noqa: E501

    OpenAPI spec version: 4.2.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.EntityReference import EntityReference  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.FloatingIpAssociation import FloatingIpAssociation  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.InGuestScriptExecutionConfig import InGuestScriptExecutionConfig  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.IpMapping import IpMapping  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.PowerState import PowerState  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.VolumeGroupAttachment import VolumeGroupAttachment  # noqa: F401,E501

class VmRecoverySetting(object):

    """Recovery configuration for VMs.

    :param vm: (:attr:`vm`) 
    :type vm: required
    
    
    :param power_state: (:attr:`power_state`) 
    :type power_state: 
    
    
    :param in_guest_script_execution_config: (:attr:`in_guest_script_execution_config`) 
    :type in_guest_script_execution_config: 
    
    
    :param volume_group_attachments: (:attr:`volume_group_attachments`) List of Volume Groups to be attached to the Virtual Machine (VM). <br><b>attachmentType</b>(s) supported are `EXTERNAL`. <br><b>protocol</b>(s) supported are `ISCSI` and `None`. <br><b>clientFeatures</b> must be specified for mutual CHAP based iSCSI authentications.
    :type volume_group_attachments: 
    
    
    :param ip_mappings: (:attr:`ip_mappings`) List of static IP address mappings for the VM. In IP mappings, the prefixLength for an exact IP address should always be 32. IPv6 IP mapping and floating IP mapping is not supported.
    :type ip_mappings: 
    
    
    :param floating_ip_associations: (:attr:`floating_ip_associations`) List of floating IP address associations. <b>primaryFloatingIp</b> and <b>recoveryFloatingIp</b> are the configurations for assigning floating IP to a VM after a failover or failback action on recovery plan. <b>primaryTestFloatingIp</b> and <b>recoveryTestFloatingIp</b> are the configurations for assigning floating IP to a VM after a failover or failback action on test network on recovery plan.
    :type floating_ip_associations: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'vm': 'datapolicies.v4.config.EntityReference',
        'power_state': 'datapolicies.v4.config.PowerState',
        'in_guest_script_execution_config': 'datapolicies.v4.config.InGuestScriptExecutionConfig',
        'volume_group_attachments': 'list[datapolicies.v4.config.VolumeGroupAttachment]',
        'ip_mappings': 'list[datapolicies.v4.config.IpMapping]',
        'floating_ip_associations': 'list[datapolicies.v4.config.FloatingIpAssociation]',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'vm': 'vm',
        'power_state': 'powerState',
        'in_guest_script_execution_config': 'inGuestScriptExecutionConfig',
        'volume_group_attachments': 'volumeGroupAttachments',
        'ip_mappings': 'ipMappings',
        'floating_ip_associations': 'floatingIpAssociations',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, vm=None, power_state=None, in_guest_script_execution_config=None, volume_group_attachments=None, ip_mappings=None, floating_ip_associations=None, *args, **kwargs):  # noqa: E501
        self.__vm = None
        self.__power_state = None
        self.__in_guest_script_execution_config = None
        self.__volume_group_attachments = None
        self.__ip_mappings = None
        self.__floating_ip_associations = None
        self.discriminator = None
        self.__vm = vm
        if power_state is not None:
            self.__power_state = power_state
        if in_guest_script_execution_config is not None:
            self.__in_guest_script_execution_config = in_guest_script_execution_config
        if volume_group_attachments is not None:
            self.__volume_group_attachments = volume_group_attachments
        if ip_mappings is not None:
            self.__ip_mappings = ip_mappings
        if floating_ip_associations is not None:
            self.__floating_ip_associations = floating_ip_associations
        # populate hidden vars if not empty
        self._populate_hidden_vars(kwargs)

    def _initialize_object_type(self):
        return 'datapolicies.v4.config.VmRecoverySetting'

    def _initialize_object_version(self):
        return 'v4.r2'

    def _populate_hidden_vars(self, kwargs):
        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
            self.__dollar_reserved = kwargs["_reserved"]
        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
        else :
            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
        else :
            self.__dollar_unknown_fields = {}
        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
            self.__dollar_object_type = kwargs["_object_type"]
        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
        else:
            self.__dollar_object_type = self._initialize_object_type()

    def get_object_type(self):
        return self.__dollar_object_type

    def get_reserved(self):
        return self.__dollar_reserved

    def get_unknown_fields(self):
        return self.__dollar_unknown_fields

    @property
    def vm(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.EntityReference`
        """  # noqa: E501
        return self.__vm

    @vm.setter
    def vm(self, vm):
        if vm is None:
            raise ValueError("Invalid value for `vm`, must not be `None`")  # noqa: E501

        self.__vm = vm

    @property
    def power_state(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.PowerState`
        """  # noqa: E501
        return self.__power_state

    @power_state.setter
    def power_state(self, power_state):

        self.__power_state = power_state

    @property
    def in_guest_script_execution_config(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.InGuestScriptExecutionConfig`
        """  # noqa: E501
        return self.__in_guest_script_execution_config

    @in_guest_script_execution_config.setter
    def in_guest_script_execution_config(self, in_guest_script_execution_config):

        self.__in_guest_script_execution_config = in_guest_script_execution_config

    @property
    def volume_group_attachments(self):
        """
        List of Volume Groups to be attached to the Virtual Machine (VM). <br><b>attachmentType</b>(s) supported are `EXTERNAL`. <br><b>protocol</b>(s) supported are `ISCSI` and `None`. <br><b>clientFeatures</b> must be specified for mutual CHAP based iSCSI authentications.

        :type:
             list[ :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.VolumeGroupAttachment` ]
        """  # noqa: E501
        return self.__volume_group_attachments

    @volume_group_attachments.setter
    def volume_group_attachments(self, volume_group_attachments):

        self.__volume_group_attachments = volume_group_attachments

    @property
    def ip_mappings(self):
        """
        List of static IP address mappings for the VM. In IP mappings, the prefixLength for an exact IP address should always be 32. IPv6 IP mapping and floating IP mapping is not supported.

        :type:
             list[ :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.IpMapping` ]
        """  # noqa: E501
        return self.__ip_mappings

    @ip_mappings.setter
    def ip_mappings(self, ip_mappings):

        self.__ip_mappings = ip_mappings

    @property
    def floating_ip_associations(self):
        """
        List of floating IP address associations. <b>primaryFloatingIp</b> and <b>recoveryFloatingIp</b> are the configurations for assigning floating IP to a VM after a failover or failback action on recovery plan. <b>primaryTestFloatingIp</b> and <b>recoveryTestFloatingIp</b> are the configurations for assigning floating IP to a VM after a failover or failback action on test network on recovery plan.

        :type:
             list[ :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.FloatingIpAssociation` ]
        """  # noqa: E501
        return self.__floating_ip_associations

    @floating_ip_associations.setter
    def floating_ip_associations(self, floating_ip_associations):

        self.__floating_ip_associations = floating_ip_associations

    @property
    def _reserved(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_reserved

    @property
    def _object_type(self):
        """
        

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__dollar_object_type

    @property
    def _unknown_fields(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_unknown_fields

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(VmRecoverySetting, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        # handle unknown fields
        result['_unknown_fields'] = {}
        unknown = self.get_unknown_fields()
        if sanitize:
            unknown = self._sanitize_for_serialization(unknown)

        return {**result, **unknown}

    def _sanitize_for_serialization(self, value):
        """Recursively sanitize the value for serialization.

        :param value: The value to sanitize
        :type value: any
        :return: Sanitized value
        :rtype: any
        """
        if isinstance(value, (list, tuple)):
            return list(map(self._sanitize_for_serialization, [v for v in value if v is not None]))
        elif isinstance(value, dict):
            return {k: self._sanitize_for_serialization(v) for k, v in six.iteritems(value) if v is not None}
        elif isinstance(value, (str, int, float, bool)):
            return value
        elif isinstance(value, Path):
            return str(value)
        else:
            return value.to_dict() if hasattr(value, 'to_dict') else str(value)

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, VmRecoverySetting):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

