# coding: utf-8


"""
IGNORE:
    Nutanix Data Policies APIs

    Manage Policies for Disaster Recovery and Storage.  # noqa: E501

    OpenAPI spec version: 4.2.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_datapolicies_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
from ntnx_datapolicies_py_client.models.datapolicies.v4.config.NetworkConfig import NetworkConfig  # noqa: F401,E501

class NetworkMapping(ExternalizableAbstractModel):

    """Mapping between networks on primary and recovery locations. This mapping will be used to create virtual NICs on failover or failback.<br> During a failover from primary location to recovery location, virtual NICs on the `primaryNetwork` will be recreated on the `recoveryNetwork` if failover action is `PLANNED_FAILOVER`, `UNPLANNED_FAILOVER` or the `recoveryTestNetwork` if failover action is `TEST_FAILOVER`.<br> During failback, virtual NICs on the `recoveryNetwork` will be recreated on the `primaryNetwork` if the failover action is `PLANNED_FAILOVER`, `UNPLANNED_FAILOVER` or `primaryTestNetwork` if the failover action is `TEST_FAILOVER`.<br>.

    :param primary_network: (:attr:`primary_network`) 
    :type primary_network: required
    
    
    :param recovery_network: (:attr:`recovery_network`) 
    :type recovery_network: required
    
    
    :param primary_test_network: (:attr:`primary_test_network`) 
    :type primary_test_network: 
    
    
    :param recovery_test_network: (:attr:`recovery_test_network`) 
    :type recovery_test_network: 
    
    
    :param is_ip_mapping_enabled: (:attr:`is_ip_mapping_enabled`) Indicates whether the static IPs of recovered VMs should be mapped according to the target network and configured inside the guest VMs. When specified as false, VMs may recover with any IP address allocated by the DHCP server corresponding to the target network. (**Default** False)
    :type is_ip_mapping_enabled: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'primary_network': 'datapolicies.v4.config.NetworkConfig',
        'recovery_network': 'datapolicies.v4.config.NetworkConfig',
        'primary_test_network': 'datapolicies.v4.config.NetworkConfig',
        'recovery_test_network': 'datapolicies.v4.config.NetworkConfig',
        'is_ip_mapping_enabled': 'bool',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'primary_network': 'primaryNetwork',
        'recovery_network': 'recoveryNetwork',
        'primary_test_network': 'primaryTestNetwork',
        'recovery_test_network': 'recoveryTestNetwork',
        'is_ip_mapping_enabled': 'isIpMappingEnabled',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, primary_network=None, recovery_network=None, primary_test_network=None, recovery_test_network=None, is_ip_mapping_enabled=False, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__primary_network = None
        self.__recovery_network = None
        self.__primary_test_network = None
        self.__recovery_test_network = None
        self.__is_ip_mapping_enabled = None
        self.discriminator = None
        self.__primary_network = primary_network
        self.__recovery_network = recovery_network
        if primary_test_network is not None:
            self.__primary_test_network = primary_test_network
        if recovery_test_network is not None:
            self.__recovery_test_network = recovery_test_network
        if is_ip_mapping_enabled is not None:
            self.__is_ip_mapping_enabled = is_ip_mapping_enabled

    def _initialize_object_type(self):
        return 'datapolicies.v4.config.NetworkMapping'

    def _initialize_object_version(self):
        return 'v4.r2'


    @property
    def primary_network(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.NetworkConfig`
        """  # noqa: E501
        return self.__primary_network

    @primary_network.setter
    def primary_network(self, primary_network):
        if primary_network is None:
            raise ValueError("Invalid value for `primary_network`, must not be `None`")  # noqa: E501

        self.__primary_network = primary_network

    @property
    def recovery_network(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.NetworkConfig`
        """  # noqa: E501
        return self.__recovery_network

    @recovery_network.setter
    def recovery_network(self, recovery_network):
        if recovery_network is None:
            raise ValueError("Invalid value for `recovery_network`, must not be `None`")  # noqa: E501

        self.__recovery_network = recovery_network

    @property
    def primary_test_network(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.NetworkConfig`
        """  # noqa: E501
        return self.__primary_test_network

    @primary_test_network.setter
    def primary_test_network(self, primary_test_network):

        self.__primary_test_network = primary_test_network

    @property
    def recovery_test_network(self):
        """
        

        :type:
            :class:`~ntnx_datapolicies_py_client.models.datapolicies.v4.config.NetworkConfig`
        """  # noqa: E501
        return self.__recovery_test_network

    @recovery_test_network.setter
    def recovery_test_network(self, recovery_test_network):

        self.__recovery_test_network = recovery_test_network

    @property
    def is_ip_mapping_enabled(self):
        """
        Indicates whether the static IPs of recovered VMs should be mapped according to the target network and configured inside the guest VMs. When specified as false, VMs may recover with any IP address allocated by the DHCP server corresponding to the target network.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_ip_mapping_enabled

    @is_ip_mapping_enabled.setter
    def is_ip_mapping_enabled(self, is_ip_mapping_enabled):

        self.__is_ip_mapping_enabled = is_ip_mapping_enabled

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(NetworkMapping, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        # handle unknown fields
        result['_unknown_fields'] = {}
        unknown = self.get_unknown_fields()
        if sanitize:
            unknown = self._sanitize_for_serialization(unknown)

        return {**result, **unknown}


    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NetworkMapping):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

