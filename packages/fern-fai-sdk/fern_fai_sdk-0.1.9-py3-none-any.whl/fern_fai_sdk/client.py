# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import httpx
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .environment import FernAIEnvironment

if typing.TYPE_CHECKING:
    from .analytics.client import AnalyticsClient, AsyncAnalyticsClient
    from .chat.client import AsyncChatClient, ChatClient
    from .code.client import AsyncCodeClient, CodeClient
    from .content_hash.client import AsyncContentHashClient, ContentHashClient
    from .conversation.client import AsyncConversationClient, ConversationClient
    from .discord.client import AsyncDiscordClient, DiscordClient
    from .document.client import AsyncDocumentClient, DocumentClient
    from .feedback.client import AsyncFeedbackClient, FeedbackClient
    from .guidance.client import AsyncGuidanceClient, GuidanceClient
    from .health.client import AsyncHealthClient, HealthClient
    from .index.client import AsyncIndexClient, IndexClient
    from .mcp.client import AsyncMcpClient, McpClient
    from .query.client import AsyncQueryClient, QueryClient
    from .reindexing.client import AsyncReindexingClient, ReindexingClient
    from .sdks.client import AsyncSdksClient, SdksClient
    from .settings.client import AsyncSettingsClient, SettingsClient
    from .slack_ask_fern.client import AsyncSlackAskFernClient, SlackAskFernClient
    from .slack_scribe.client import AsyncSlackScribeClient, SlackScribeClient
    from .sources.client import AsyncSourcesClient, SourcesClient
    from .website.client import AsyncWebsiteClient, WebsiteClient


class FernAI:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : FernAIEnvironment
        The environment to use for requests from the client. from .environment import FernAIEnvironment



        Defaults to FernAIEnvironment.PRODUCTION



    token : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fern_fai_sdk import FernAI

    client = FernAI(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: FernAIEnvironment = FernAIEnvironment.PRODUCTION,
        token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._analytics: typing.Optional[AnalyticsClient] = None
        self._chat: typing.Optional[ChatClient] = None
        self._code: typing.Optional[CodeClient] = None
        self._content_hash: typing.Optional[ContentHashClient] = None
        self._conversation: typing.Optional[ConversationClient] = None
        self._discord: typing.Optional[DiscordClient] = None
        self._document: typing.Optional[DocumentClient] = None
        self._feedback: typing.Optional[FeedbackClient] = None
        self._guidance: typing.Optional[GuidanceClient] = None
        self._health: typing.Optional[HealthClient] = None
        self._index: typing.Optional[IndexClient] = None
        self._mcp: typing.Optional[McpClient] = None
        self._query: typing.Optional[QueryClient] = None
        self._reindexing: typing.Optional[ReindexingClient] = None
        self._sdks: typing.Optional[SdksClient] = None
        self._settings: typing.Optional[SettingsClient] = None
        self._slack_ask_fern: typing.Optional[SlackAskFernClient] = None
        self._slack_scribe: typing.Optional[SlackScribeClient] = None
        self._sources: typing.Optional[SourcesClient] = None
        self._website: typing.Optional[WebsiteClient] = None

    @property
    def analytics(self):
        if self._analytics is None:
            from .analytics.client import AnalyticsClient  # noqa: E402

            self._analytics = AnalyticsClient(client_wrapper=self._client_wrapper)
        return self._analytics

    @property
    def chat(self):
        if self._chat is None:
            from .chat.client import ChatClient  # noqa: E402

            self._chat = ChatClient(client_wrapper=self._client_wrapper)
        return self._chat

    @property
    def code(self):
        if self._code is None:
            from .code.client import CodeClient  # noqa: E402

            self._code = CodeClient(client_wrapper=self._client_wrapper)
        return self._code

    @property
    def content_hash(self):
        if self._content_hash is None:
            from .content_hash.client import ContentHashClient  # noqa: E402

            self._content_hash = ContentHashClient(client_wrapper=self._client_wrapper)
        return self._content_hash

    @property
    def conversation(self):
        if self._conversation is None:
            from .conversation.client import ConversationClient  # noqa: E402

            self._conversation = ConversationClient(client_wrapper=self._client_wrapper)
        return self._conversation

    @property
    def discord(self):
        if self._discord is None:
            from .discord.client import DiscordClient  # noqa: E402

            self._discord = DiscordClient(client_wrapper=self._client_wrapper)
        return self._discord

    @property
    def document(self):
        if self._document is None:
            from .document.client import DocumentClient  # noqa: E402

            self._document = DocumentClient(client_wrapper=self._client_wrapper)
        return self._document

    @property
    def feedback(self):
        if self._feedback is None:
            from .feedback.client import FeedbackClient  # noqa: E402

            self._feedback = FeedbackClient(client_wrapper=self._client_wrapper)
        return self._feedback

    @property
    def guidance(self):
        if self._guidance is None:
            from .guidance.client import GuidanceClient  # noqa: E402

            self._guidance = GuidanceClient(client_wrapper=self._client_wrapper)
        return self._guidance

    @property
    def health(self):
        if self._health is None:
            from .health.client import HealthClient  # noqa: E402

            self._health = HealthClient(client_wrapper=self._client_wrapper)
        return self._health

    @property
    def index(self):
        if self._index is None:
            from .index.client import IndexClient  # noqa: E402

            self._index = IndexClient(client_wrapper=self._client_wrapper)
        return self._index

    @property
    def mcp(self):
        if self._mcp is None:
            from .mcp.client import McpClient  # noqa: E402

            self._mcp = McpClient(client_wrapper=self._client_wrapper)
        return self._mcp

    @property
    def query(self):
        if self._query is None:
            from .query.client import QueryClient  # noqa: E402

            self._query = QueryClient(client_wrapper=self._client_wrapper)
        return self._query

    @property
    def reindexing(self):
        if self._reindexing is None:
            from .reindexing.client import ReindexingClient  # noqa: E402

            self._reindexing = ReindexingClient(client_wrapper=self._client_wrapper)
        return self._reindexing

    @property
    def sdks(self):
        if self._sdks is None:
            from .sdks.client import SdksClient  # noqa: E402

            self._sdks = SdksClient(client_wrapper=self._client_wrapper)
        return self._sdks

    @property
    def settings(self):
        if self._settings is None:
            from .settings.client import SettingsClient  # noqa: E402

            self._settings = SettingsClient(client_wrapper=self._client_wrapper)
        return self._settings

    @property
    def slack_ask_fern(self):
        if self._slack_ask_fern is None:
            from .slack_ask_fern.client import SlackAskFernClient  # noqa: E402

            self._slack_ask_fern = SlackAskFernClient(client_wrapper=self._client_wrapper)
        return self._slack_ask_fern

    @property
    def slack_scribe(self):
        if self._slack_scribe is None:
            from .slack_scribe.client import SlackScribeClient  # noqa: E402

            self._slack_scribe = SlackScribeClient(client_wrapper=self._client_wrapper)
        return self._slack_scribe

    @property
    def sources(self):
        if self._sources is None:
            from .sources.client import SourcesClient  # noqa: E402

            self._sources = SourcesClient(client_wrapper=self._client_wrapper)
        return self._sources

    @property
    def website(self):
        if self._website is None:
            from .website.client import WebsiteClient  # noqa: E402

            self._website = WebsiteClient(client_wrapper=self._client_wrapper)
        return self._website


class AsyncFernAI:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : FernAIEnvironment
        The environment to use for requests from the client. from .environment import FernAIEnvironment



        Defaults to FernAIEnvironment.PRODUCTION



    token : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fern_fai_sdk import AsyncFernAI

    client = AsyncFernAI(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: FernAIEnvironment = FernAIEnvironment.PRODUCTION,
        token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._analytics: typing.Optional[AsyncAnalyticsClient] = None
        self._chat: typing.Optional[AsyncChatClient] = None
        self._code: typing.Optional[AsyncCodeClient] = None
        self._content_hash: typing.Optional[AsyncContentHashClient] = None
        self._conversation: typing.Optional[AsyncConversationClient] = None
        self._discord: typing.Optional[AsyncDiscordClient] = None
        self._document: typing.Optional[AsyncDocumentClient] = None
        self._feedback: typing.Optional[AsyncFeedbackClient] = None
        self._guidance: typing.Optional[AsyncGuidanceClient] = None
        self._health: typing.Optional[AsyncHealthClient] = None
        self._index: typing.Optional[AsyncIndexClient] = None
        self._mcp: typing.Optional[AsyncMcpClient] = None
        self._query: typing.Optional[AsyncQueryClient] = None
        self._reindexing: typing.Optional[AsyncReindexingClient] = None
        self._sdks: typing.Optional[AsyncSdksClient] = None
        self._settings: typing.Optional[AsyncSettingsClient] = None
        self._slack_ask_fern: typing.Optional[AsyncSlackAskFernClient] = None
        self._slack_scribe: typing.Optional[AsyncSlackScribeClient] = None
        self._sources: typing.Optional[AsyncSourcesClient] = None
        self._website: typing.Optional[AsyncWebsiteClient] = None

    @property
    def analytics(self):
        if self._analytics is None:
            from .analytics.client import AsyncAnalyticsClient  # noqa: E402

            self._analytics = AsyncAnalyticsClient(client_wrapper=self._client_wrapper)
        return self._analytics

    @property
    def chat(self):
        if self._chat is None:
            from .chat.client import AsyncChatClient  # noqa: E402

            self._chat = AsyncChatClient(client_wrapper=self._client_wrapper)
        return self._chat

    @property
    def code(self):
        if self._code is None:
            from .code.client import AsyncCodeClient  # noqa: E402

            self._code = AsyncCodeClient(client_wrapper=self._client_wrapper)
        return self._code

    @property
    def content_hash(self):
        if self._content_hash is None:
            from .content_hash.client import AsyncContentHashClient  # noqa: E402

            self._content_hash = AsyncContentHashClient(client_wrapper=self._client_wrapper)
        return self._content_hash

    @property
    def conversation(self):
        if self._conversation is None:
            from .conversation.client import AsyncConversationClient  # noqa: E402

            self._conversation = AsyncConversationClient(client_wrapper=self._client_wrapper)
        return self._conversation

    @property
    def discord(self):
        if self._discord is None:
            from .discord.client import AsyncDiscordClient  # noqa: E402

            self._discord = AsyncDiscordClient(client_wrapper=self._client_wrapper)
        return self._discord

    @property
    def document(self):
        if self._document is None:
            from .document.client import AsyncDocumentClient  # noqa: E402

            self._document = AsyncDocumentClient(client_wrapper=self._client_wrapper)
        return self._document

    @property
    def feedback(self):
        if self._feedback is None:
            from .feedback.client import AsyncFeedbackClient  # noqa: E402

            self._feedback = AsyncFeedbackClient(client_wrapper=self._client_wrapper)
        return self._feedback

    @property
    def guidance(self):
        if self._guidance is None:
            from .guidance.client import AsyncGuidanceClient  # noqa: E402

            self._guidance = AsyncGuidanceClient(client_wrapper=self._client_wrapper)
        return self._guidance

    @property
    def health(self):
        if self._health is None:
            from .health.client import AsyncHealthClient  # noqa: E402

            self._health = AsyncHealthClient(client_wrapper=self._client_wrapper)
        return self._health

    @property
    def index(self):
        if self._index is None:
            from .index.client import AsyncIndexClient  # noqa: E402

            self._index = AsyncIndexClient(client_wrapper=self._client_wrapper)
        return self._index

    @property
    def mcp(self):
        if self._mcp is None:
            from .mcp.client import AsyncMcpClient  # noqa: E402

            self._mcp = AsyncMcpClient(client_wrapper=self._client_wrapper)
        return self._mcp

    @property
    def query(self):
        if self._query is None:
            from .query.client import AsyncQueryClient  # noqa: E402

            self._query = AsyncQueryClient(client_wrapper=self._client_wrapper)
        return self._query

    @property
    def reindexing(self):
        if self._reindexing is None:
            from .reindexing.client import AsyncReindexingClient  # noqa: E402

            self._reindexing = AsyncReindexingClient(client_wrapper=self._client_wrapper)
        return self._reindexing

    @property
    def sdks(self):
        if self._sdks is None:
            from .sdks.client import AsyncSdksClient  # noqa: E402

            self._sdks = AsyncSdksClient(client_wrapper=self._client_wrapper)
        return self._sdks

    @property
    def settings(self):
        if self._settings is None:
            from .settings.client import AsyncSettingsClient  # noqa: E402

            self._settings = AsyncSettingsClient(client_wrapper=self._client_wrapper)
        return self._settings

    @property
    def slack_ask_fern(self):
        if self._slack_ask_fern is None:
            from .slack_ask_fern.client import AsyncSlackAskFernClient  # noqa: E402

            self._slack_ask_fern = AsyncSlackAskFernClient(client_wrapper=self._client_wrapper)
        return self._slack_ask_fern

    @property
    def slack_scribe(self):
        if self._slack_scribe is None:
            from .slack_scribe.client import AsyncSlackScribeClient  # noqa: E402

            self._slack_scribe = AsyncSlackScribeClient(client_wrapper=self._client_wrapper)
        return self._slack_scribe

    @property
    def sources(self):
        if self._sources is None:
            from .sources.client import AsyncSourcesClient  # noqa: E402

            self._sources = AsyncSourcesClient(client_wrapper=self._client_wrapper)
        return self._sources

    @property
    def website(self):
        if self._website is None:
            from .website.client import AsyncWebsiteClient  # noqa: E402

            self._website = AsyncWebsiteClient(client_wrapper=self._client_wrapper)
        return self._website


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: FernAIEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
