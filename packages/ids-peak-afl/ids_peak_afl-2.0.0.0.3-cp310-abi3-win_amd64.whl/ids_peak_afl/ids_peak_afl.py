# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""peak_afl (Auto Feature Library) is an object-oriented library that provides functionality for auto features."""


from typing import Any, Sequence
from ids_peak_ipl.ids_peak_ipl import Image, Gain
import ids_peak_common.exceptions
from .exceptions import *



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ids_peak_afl_python_interface
else:
    import _ids_peak_afl_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_SwigPyIterator

    def value(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "int":
        return _ids_peak_afl_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "int":
        return _ids_peak_afl_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _ids_peak_afl_python_interface.SHARED_PTR_DISOWN
class AutoAverages(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "int", arg3: "int", v1: "int"):
        _ids_peak_afl_python_interface.AutoAverages_swiginit(self, _ids_peak_afl_python_interface.new_AutoAverages(arg2, arg3, v1))

    def get0(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get0(self)

    def get1(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get1(self)

    def get2(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get2(self)

    def set0(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set0(self, val)

    def set1(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set1(self, val)

    def set2(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set2(self, val)

    def __len__(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages___len__(self)

    def __getitem__(self, n):
        if n >= len(self):
            raise IndexError()
        return getattr(self, 'get%d' % n)()
    def __setitem__(self, n, val):
        if n >= len(self):
            raise IndexError()
        getattr(self, 'set%d' % n)(val)

    __swig_destroy__ = _ids_peak_afl_python_interface.delete_AutoAverages

# Register AutoAverages in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.AutoAverages_swigregister(AutoAverages)
class Library(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Init() -> "None":
        return _ids_peak_afl_python_interface.Library_Init()

    @staticmethod
    def Exit() -> "None":
        return _ids_peak_afl_python_interface.Library_Exit()

    @staticmethod
    def GetLastError() -> "str":
        return _ids_peak_afl_python_interface.Library_GetLastError()

    @staticmethod
    def Version() -> "Version_t":
        return _ids_peak_afl_python_interface.Library_Version()

    def __init__(self):
        _ids_peak_afl_python_interface.Library_swiginit(self, _ids_peak_afl_python_interface.new_Library())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Library

# Register Library in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Library_swigregister(Library)
class FinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == FinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.FinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_FinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_FinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.FinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_FinishedCallback(self)
        return weakref.proxy(self)

# Register FinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.FinishedCallback_swigregister(FinishedCallback)
class ProcessDataCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ProcessDataCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ProcessDataCallback_swiginit(self, _ids_peak_afl_python_interface.new_ProcessDataCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ProcessDataCallback

    def callback(self, arg0: "int", arg1: "int") -> "None":
        return _ids_peak_afl_python_interface.ProcessDataCallback_callback(self, arg0, arg1)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ProcessDataCallback(self)
        return weakref.proxy(self)

# Register ProcessDataCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ProcessDataCallback_swigregister(ProcessDataCallback)
class ProcessingCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ProcessingCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ProcessingCallback_swiginit(self, _ids_peak_afl_python_interface.new_ProcessingCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ProcessingCallback

    def callback(self, data: "peak_afl_process_data") -> "None":
        return _ids_peak_afl_python_interface.ProcessingCallback_callback(self, data)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ProcessingCallback(self)
        return weakref.proxy(self)

# Register ProcessingCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ProcessingCallback_swigregister(ProcessingCallback)
class ComponentExposureFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentExposureFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentExposureFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentExposureFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentExposureFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentExposureFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentExposureFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentExposureFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentExposureFinishedCallback_swigregister(ComponentExposureFinishedCallback)
class ComponentGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentGainFinishedCallback_swigregister(ComponentGainFinishedCallback)
class ComponentAnalogGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentAnalogGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentAnalogGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentAnalogGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentAnalogGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentAnalogGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentAnalogGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentAnalogGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentAnalogGainFinishedCallback_swigregister(ComponentAnalogGainFinishedCallback)
class ComponentDigitalGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentDigitalGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentDigitalGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentDigitalGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentDigitalGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentDigitalGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentDigitalGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentDigitalGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentDigitalGainFinishedCallback_swigregister(ComponentDigitalGainFinishedCallback)
class ComponentCombinedGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentCombinedGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentCombinedGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentCombinedGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentCombinedGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentCombinedGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentCombinedGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentCombinedGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentCombinedGainFinishedCallback_swigregister(ComponentCombinedGainFinishedCallback)
class ComponentHostGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentHostGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentHostGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentHostGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentHostGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentHostGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentHostGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentHostGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentHostGainFinishedCallback_swigregister(ComponentHostGainFinishedCallback)
class Version_t(object):
    r"""Version information for ids_peak_afl"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    major: "int" = property(_ids_peak_afl_python_interface.Version_t_major_get, _ids_peak_afl_python_interface.Version_t_major_set)
    minor: "int" = property(_ids_peak_afl_python_interface.Version_t_minor_get, _ids_peak_afl_python_interface.Version_t_minor_set, doc=r"""Major""")
    subminor: "int" = property(_ids_peak_afl_python_interface.Version_t_subminor_get, _ids_peak_afl_python_interface.Version_t_subminor_set, doc=r"""Minor""")
    patch: "int" = property(_ids_peak_afl_python_interface.Version_t_patch_get, _ids_peak_afl_python_interface.Version_t_patch_set, doc=r"""Subminor""")

    def ToString(self) -> "str":
        r"""
         Patch
        The String representation for the ids_peak_afl version
        :rtype: str
        :return: the str representation
        """
        return _ids_peak_afl_python_interface.Version_t_ToString(self)

    def Major(self) -> "int":
        r"""
        Returns the major part of the version which is the first part of the version scheme separated by dots.

        :rtype: int
        :return: **a**.b.c.d
        """
        return _ids_peak_afl_python_interface.Version_t_Major(self)

    def Minor(self) -> "int":
        r"""
        Returns the minor part of the version which is the second part of the version scheme separated by dots.

        :rtype: int
        :return: a.**b**.c.d
        """
        return _ids_peak_afl_python_interface.Version_t_Minor(self)

    def Subminor(self) -> "int":
        r"""
        Returns the subminor part of the version which is the third part of the version scheme separated by dots.

        :rtype: int
        :return: a.b.**c**.d
        """
        return _ids_peak_afl_python_interface.Version_t_Subminor(self)

    def Patch(self) -> "int":
        r"""
        Returns the patch part of the version which is the fourth part of the version scheme separated by dots.

        :rtype: int
        :return: a.b.c.**d**
        """
        return _ids_peak_afl_python_interface.Version_t_Patch(self)

    def __str__(self):
        return self.ToString()


    def __init__(self):
        _ids_peak_afl_python_interface.Version_t_swiginit(self, _ids_peak_afl_python_interface.new_Version_t())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Version_t

# Register Version_t in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Version_t_swigregister(Version_t)
class InternalErrorException(object):
    r"""
    The exception thrown for signaling an unspecified error.

    Since: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.InternalErrorException_swiginit(self, _ids_peak_afl_python_interface.new_InternalErrorException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_InternalErrorException

# Register InternalErrorException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.InternalErrorException_swigregister(InternalErrorException)
class NotInitializedException(object):
    r"""
    The exception thrown for signaling that the library was not initialized.

    Notes: Remember to call Init() / PEAK_AFL_Library_Init() before anything else.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.NotInitializedException_swiginit(self, _ids_peak_afl_python_interface.new_NotInitializedException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_NotInitializedException

# Register NotInitializedException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.NotInitializedException_swigregister(NotInitializedException)
class InvalidParameterException(object):
    r"""
    The exception thrown for passing an invalid parameter to a function.

    One or more function parameters are invalid (e.g., nullptr where valid
    pointers are required, out-of-range values, invalid handles).

    Notes: Check parameter documentation for valid ranges and requirements
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.InvalidParameterException_swiginit(self, _ids_peak_afl_python_interface.new_InvalidParameterException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_InvalidParameterException

# Register InvalidParameterException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.InvalidParameterException_swigregister(InvalidParameterException)
class NotSupportedException(object):
    r"""
    The exception thrown when a functionality is not supported.

    The requested feature or operation is not supported by the current device
    or configuration. Check feature availability before use.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.NotSupportedException_swiginit(self, _ids_peak_afl_python_interface.new_NotSupportedException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_NotSupportedException

# Register NotSupportedException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.NotSupportedException_swigregister(NotSupportedException)
class BusyException(object):
    r"""
    The exception thrown for signaling a busy operation.

    Notes: Try checking the status. If thrown by Manager, call 'Status()' first.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.BusyException_swiginit(self, _ids_peak_afl_python_interface.new_BusyException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_BusyException

# Register BusyException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.BusyException_swigregister(BusyException)
class InvalidImageFormatException(object):
    r"""
    The exception thrown for signaling an invalid image format.

    The provided image format is not supported by the auto feature algorithms
    or the format parameters are invalid.

    Notes: Check supported pixel formats in the documentation
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.InvalidImageFormatException_swiginit(self, _ids_peak_afl_python_interface.new_InvalidImageFormatException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_InvalidImageFormatException

# Register InvalidImageFormatException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.InvalidImageFormatException_swigregister(InvalidImageFormatException)
class BadAccessException(object):
    r"""
    The exception thrown for signaling an access error.

    The requested operation could not be performed due to insufficient permissions
    or the resource being locked by another process.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.BadAccessException_swiginit(self, _ids_peak_afl_python_interface.new_BadAccessException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_BadAccessException

# Register BadAccessException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.BadAccessException_swigregister(BadAccessException)
class BufferTooSmallException(object):
    r"""
    The exception thrown when the supplied buffer is too small.

    The buffer provided for output data is smaller than required.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.BufferTooSmallException_swiginit(self, _ids_peak_afl_python_interface.new_BufferTooSmallException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_BufferTooSmallException

# Register BufferTooSmallException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.BufferTooSmallException_swigregister(BufferTooSmallException)
class CorruptedDataException(object):
    r"""
    Thrown when input data or a file is malformed, unreadable, or otherwise corrupted.

    This exception occurs, when reading from a file or stream that is incomplete, damaged, or in an unexpected format.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.CorruptedDataException_swiginit(self, _ids_peak_afl_python_interface.new_CorruptedDataException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_CorruptedDataException

# Register CorruptedDataException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.CorruptedDataException_swigregister(CorruptedDataException)
class InvalidCastException(object):
    r"""The exception thrown when a cast to the required type failed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_afl_python_interface.InvalidCastException_swiginit(self, _ids_peak_afl_python_interface.new_InvalidCastException(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_InvalidCastException

# Register InvalidCastException in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.InvalidCastException_swigregister(InvalidCastException)

def ThrowException(code: "peak_afl_status", get_text: "bool"=True) -> "None":
    return _ids_peak_afl_python_interface.ThrowException(code, get_text)
class Manager(object):
    r"""
    Central coordination object for automatic camera feature control.


    The Manager class links the device’s `NodeMap` with one or more automatic
    feature controllers and orchestrates their operation during image
    processing. It is responsible for creating, owning, and managing controllers
    of various types (see ::peak_afl_controllerType), forwarding image data
    to them, and maintaining shared configuration resources such as gain and
    color correction matrices.

    ## Purpose
    A Manager forms the root object of the auto-feature subsystem.
    It manages the lifecycle of controllers, ensures that each controller type
    is only instantiated once, and provides the infrastructure required by
    controllers to execute their algorithms. Image frames passed to `Process()`
    are distributed to all active controllers so they can update their internal
    state accordingly.

    ## Controller Management
    Controllers must be added to the Manager before they can be used.
    Each controller type can appear only once, and a controller may beint to
    only one Manager at a time.
    The Manager provides functions to:

    - add or remove individual controllers,
    - enumerate existing controllers,
    - query support for specific controller types,
    - create and immediately register new controllers via `CreateController()`,
    - destroy one or all controllers.

    ## Image Processing
    The `Process()` function forwards image data to the auto-feature system,
    allowing all attached controllers to evaluate the frame and apply their
    algorithmic updates. The current processing state can be queried via
    `Status()`. The manager’s status **should always be checked before calling**
    `Process()`, as invoking it while a previous frame is still being processed
    may result in a 'BusyException'.

    ## Shared Configuration
    The Manager also maintains selected shared parameters, such as IPL gain
    and the 3×3 Color Correction Matrix (CCM). These settings are applied as
    part of the internal auto-feature processing pipeline and may affect the
    behavior or results of individual controllers.

    ## Lifetime and Ownership
    A Manager instance owns all controllers registered with it. Destroying a
    controller via Manager APIs invalidates the associated Controller object.

    ## Exceptions
    Most operations may throw ::Exception if the
    underlying API call fails. Callers should handle errors accordingly and
    refer to `code()` and `what()` for diagnostic details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Manager

    def __init__(self, *args):
        r"""
        Create an automanager instance

        Creates an automanager instance.

        :type node_map: NodeMap, in
        :param node_map: the shared pointer to the device nodemap

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        _ids_peak_afl_python_interface.Manager_swiginit(self, _ids_peak_afl_python_interface.new_Manager(*args))

    def AddController(self, controller: "Controller") -> "None":
        r"""
        Add a controller to an automanager

        An autocontroller instance can only be added to one autofeature manager at the same time.
        The same type can only be added one time.

        :type controller: :py:class:`Controller`, in
        :param controller: shared_ptr to a controller

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_AddController(self, controller)

    def RemoveController(self, controller: "Controller") -> "None":
        r"""
        Remove a controller from an automanager

        Remove a controller from a manager.
        For a function which destroys the object in one call, see #peak_afl_AutoFeatureManager_DestroyController.

        :type controller: :py:class:`Controller`, in
        :param controller: shared_ptr to a controller

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_RemoveController(self, controller)

    def Process(self, image: "Image") -> "None":
        r"""
        Process an image

        Processes an image.

        :type image: Image, in
        :param image: an Image image

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_Process(self, image)

    def CreateController(self, type: "peak_afl_controllerType") -> "Controller":
        r"""
        Create a controller and append it to Manager

        Convenience function to create an autofeature controller and add it to the manager.
        The same type can only be added one time.

        :type type: int, in
        :param type: controller type, see #peak_afl_controllerType

        :rtype: :py:class:`Controller`
        :return: the shared ptr to the created controller

        :raises: Exception if deinitialization fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_CreateController(self, type)

    def DestroyAllController(self) -> "None":
        r"""
        Destroy all controllers for a manager.

        After this operation all controllers associated with the given manager will be invalid.

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_DestroyAllController(self)

    def DestroyController(self, controller: "Controller") -> "None":
        r"""
        Destroy a controller.

        After this operation the controller will be invalid.

        :type controller: :py:class:`Controller`, in
        :param controller: shared ptr to a controller

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Manager_DestroyController(self, controller)

    def SetGainIPL(self, gain: "Gain") -> "None":
        r"""
        Sets the ipl gain.

        :type gain: Gain, in
        :param gain: an Gain gain

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Manager_SetGainIPL(self, gain)

    def SetCCM(self, ccm: "Any") -> "None":
        r"""
        Set the Color Correction Matrix (CCM)

        Sets a 3x3 color correction matrix for the auto feature manager. The CCM is used to correct
        color values during image processing. The matrix should be provided as a array of 9 float values
        in row-major order: [R->R, R->G, R->B, G->R, G->G, G->B, B->R, B->G, B->B].

        :type ccm: array< float,9 >, in
        :param ccm: array of 9 float values representing the 3x3 CCM in row-major order

        :raises: Exception if function fails

        Since: 1.8
        """
        return _ids_peak_afl_python_interface.Manager_SetCCM(self, ccm)

    def Status(self) -> "bool":
        r"""
        Get the status of a manager.

        The returned value will contain whether the manager currently processes an image (true) or is idle (false).

        :rtype: boolean
        :return: manager status

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_Status(self)

    def ControllerList(self) -> "Sequence[Controller]":
        r"""
        Get the list of the controller associated with the manager

        :rtype: Sequence[Controller]
        :return: controller list

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_ControllerList(self)

    def ControllerCount(self) -> "int":
        r"""
        Get the list count of the controller associated with the manager

        :rtype: int
        :return: number of controllers in list

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_ControllerCount(self)

    def GetController(self, type: "peak_afl_controllerType") -> "Controller":
        r"""
        Get the controller for a type

        :type type: int, in
        :param type: controller type.

        :rtype: :py:class:`Controller`
        :return: controller

        :raises: Exception if no controller is found

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_GetController(self, type)

    def IsControllerSupported(self, type: "peak_afl_controllerType") -> "bool":
        r"""
        Get if the given controller type is supported

        :type type: int, in
        :param type: controller type.

        :rtype: boolean
        :return: True if controller is supported

        Since: 1.11
        """
        return _ids_peak_afl_python_interface.Manager_IsControllerSupported(self, type)

# Register Manager in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Manager_swigregister(Manager)
class Controller(object):
    r"""
    High-level interface for automatic camera feature control, providing
    access to algorithms such as auto-brightness, auto-exposure, auto-gain,
    white balance, and autofocus. The available functionality depends on the
    selected controller type (see ::peak_afl_controllerType).


    The Controller class represents a managed interface to one of the available
    automatic camera feature controllers provided by the auto-feature system.
    A controller encapsulates all logic necessary to tune a specific set of
    camera parameters — such as exposure time, gain, brightness, white balance,
    or focus — depending on the selected controller type
    (see ::peak_afl_controllerType).

    ## Controller Types
    A Controller instance is created using `Create()` and initialized with a
    specific controller type. Each type specializes in a particular automatic
    feature:

    - ::PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS
      Controls automatic brightness by adjusting exposure, gain (analog, digital,
      combined, host), and related limits or algorithms.

    - ::PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE
      Controls automatic white-balance algorithms and channel gain adjustments.

    - ::PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS
      Controls focus algorithms, sharpness evaluation, and focus search modes.

    The chosen type determines which features, ranges, and algorithms are
    available.

    ## Feature Management
    A controller provides a broad set of functions for querying capabilities,
    configuring parameters, and selecting algorithms.
    Before using optional features—such as ROI handling, limits, or specific
    algorithms—you must first check whether the controller supports them.
    Parameter getters typically return 'Range' values with inclusive endpoints
    and a defined step size, and component-specific controls are available where
    applicable.

    ## Regions of Interest
    Controllers may support simple ROIs, weighted ROIs, or predefined ROI
    presets, each of which restricts the image region used by the auto-feature
    algorithm.
    Support for these features must be checked beforehand using
    `IsROISupported()`, `IsWeightedROISupported()`, and
    `IsROIPresetSupported()`.

    ## Callback Management
    Controllers allow registration of several callback types:

    - **Finished callbacks** (when an algorithm iteration completes),
    - **Component callbacks** (per exposure/gain component),
    - **Processing callbacks** (image data or metadata processing),

    All callbacks are RAII-managed via an internal template mechanism that
    ensures correct registration and safe automatic unregistration.

    ## Lifetime and Ownership
    Controller instances are always created as `Controller` via
    `Create()`.

    ## Exceptions
    Almost all operations may throw ::Exception if the
    underlying API call fails. Capability checks should be performed before
    attempting unsupported operations.

    ---

    In summary, the Controller class acts as the central C++ abstraction for
    interacting with the automatic camera feature system, providing complete
    management of parameters, algorithms, ROI behavior, limits, and callbacks
    for all supported controller types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Controller

    @staticmethod
    def Create(type: "peak_afl_controllerType") -> "Controller":
        r"""
        Create a new controller

        :type type: int, in
        :param type: controller type

        :rtype: :py:class:`Controller`
        :return: the shared ptr to the created controller

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Create(type)

    def IsSkipFramesSupported(self) -> "bool":
        r"""
        Check if skip frames is supported for a controller.

        :rtype: boolean
        :return: boolean if controller supports skipping frames

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsSkipFramesSupported(self)

    def SetSkipFrames(self, count: "int") -> "None":
        r"""
        Set number of frames skipped for a controller.

        Sets the skipped frames for the controller. Only every N-th image will be processed.

        :type count: int, in
        :param count:      number of frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetSkipFrames(self, count)

    def GetSkipFrames(self) -> "int":
        r"""
        Get number of frames skipped for a controller.

        Gets the skipped frames for the controller. Only every N-th image will be processed.

        :rtype: int
        :return: number of frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSkipFrames(self)

    def GetSkipFramesRange(self) -> "IntRange":
        r"""
        Get range for frames skipped for a controller.

        :rtype: Range< int >
        :return: valid Range for frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSkipFramesRange(self)

    def IsROISupported(self) -> "bool":
        r"""
        Check if setting a region of interest is supported for a controller.

        If true region of interest is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports setting a region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsROISupported(self)

    def SetROI(self, rect: "peak_afl_rectangle") -> "None":
        r"""
        Set the autofeature region of interest for a controller.

        Set the region of interest for a controller. The processed image will be cropped to the region of interest set.

        :type rect: :py:class:`peak_afl_rectangle`, in
        :param rect:        region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetROI(self, rect)

    def GetROI(self) -> "peak_afl_rectangle":
        r"""
        Get the autofeature region of interest for a controller.

        Get the region of interest for a controller. The processed image will be cropped to the region of interest set.

        :rtype: :py:class:`peak_afl_rectangle`
        :return: region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetROI(self)

    def IsROIPresetSupported(self) -> "bool":
        r"""
        Check if ROI preset is supported for a controller.

        true if ROI preset is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports ROI preset

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsROIPresetSupported(self)

    def SetROIPreset(self, preset: "peak_afl_roi_preset") -> "None":
        r"""
        Set the autofeature region of interest preset for a controller.

        Will set the supplied preset as region of interest. See also #SetROI.

        :type preset: int, in
        :param preset:  region of interest preset

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetROIPreset(self, preset)

    def IsModeSupported(self) -> "bool":
        r"""
        Check if auto mode is supported for a controller.

        true if auto mode is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsModeSupported(self)

    def SetMode(self, mode: "peak_afl_controller_automode") -> "None":
        r"""
        Set the autofeature mode for a controller.

        Will set the controller mode to mode. See #peak_afl_controller_automode for a list of valid values.

        :type mode: int, in
        :param mode:       autofeature mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetMode(self, mode)

    def GetMode(self) -> "peak_afl_controller_automode":
        r"""
        Get the current autofeature mode for a controller.

        :rtype: int
        :return: autofeature mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetMode(self)

    def IsBrightnessAlgorithmSupported(self) -> "bool":
        r"""
        Check if auto brightness algorithm is supported for a controller.

        true if auto brightness algorithm is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto brightness algorithm

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessAlgorithmSupported(self)

    def SetBrightnessAlgorithm(self, algorithm: "peak_afl_controller_brightness_algorithm") -> "None":
        r"""
        Set the autofeature brightness algorithm for a controller.

        Will set the controller brightness algorithm to algorithm. See #peak_afl_controller_brightness_algorithm for a list of valid
        values.

        :type algorithm: int, in
        :param algorithm: autofeature brightness algorithm

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetBrightnessAlgorithm(self, algorithm)

    def GetBrightnessAlgorithm(self) -> "peak_afl_controller_brightness_algorithm":
        r"""
        Get the current autofeature brightness algorithm for a controller.

        :rtype: int
        :return: autofeature brightness algorithm

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Controller_GetBrightnessAlgorithm(self)

    def Status(self) -> "peak_afl_controller_status":
        r"""
        Get the status for a controller.

        See #peak_afl_controller_status for a list of values.

        :rtype: int
        :return: controller status

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Status(self)

    def GetLastAutoAverage(self) -> "int":
        r"""
        Get the last auto average for a controller.

        Used by Controllers processing a mono image.

        :rtype: int
        :return: autofeature average

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLastAutoAverage(self)

    def GetLastAutoAverages(self) -> "Any":
        r"""
        Get the last auto average for a controller.

        Used by Controllers processing a color image.

        :rtype: tuple< int,int,int >
        :return: tuple<red, green, blue> in that order

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLastAutoAverages(self)

    def IsAutoTargetSupported(self) -> "bool":
        r"""
        check if auto target is supported for a controller.

        True if auto target is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto target

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoTargetSupported(self)

    def SetAutoTarget(self, target: "int") -> "None":
        r"""
        Set the auto target for a controller.

        Set an auto target. Call #peak_afl_AutoController_AutoTarget_GetRange to get the valid range.
        End value which will be targeted by the controller.

        :type target: int, in
        :param target:     auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoTarget(self, target)

    def GetAutoTarget(self) -> "int":
        r"""
        Get the currently set auto target for a controller.

        :rtype: int
        :return: auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTarget(self)

    def GetAutoTargetRange(self) -> "IntRange":
        r"""
        Get the auto target range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoTarget.

        :rtype: Range< int >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTargetRange(self)

    def IsAutoToleranceSupported(self) -> "bool":
        r"""
        check if auto tolerance is supported for a controller.

        True if auto tolerance is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto tolerance

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoToleranceSupported(self)

    def SetAutoTolerance(self, tolerance: "int") -> "None":
        r"""
        Set the auto tolerance for a controller.

        Sets the +/- tolerance for the auto target value.

        :type tolerance: int, in
        :param tolerance:  auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoTolerance(self, tolerance)

    def GetAutoTolerance(self) -> "int":
        r"""
        Get the current auto tolerance for a controller.

        :rtype: int
        :return: auto tolerance value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTolerance(self)

    def GetAutoToleranceRange(self) -> "IntRange":
        r"""
        Get the auto tolerance range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoTolerance.

        :rtype: Range< int >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoToleranceRange(self)

    def IsAutoPercentileSupported(self) -> "bool":
        r"""
        check if auto percentile is supported for a controller.

        True if auto percentile is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto percentile

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoPercentileSupported(self)

    def SetAutoPercentile(self, percentile: "float") -> "None":
        r"""
        Set the auto percentile for a controller.

        This is the used percentile value for a controller.
        To get the valid range, call #peak_afl_AutoController_AutoPercentile_GetRange.

        :type percentile: float, in
        :param percentile: auto percentile value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoPercentile(self, percentile)

    def GetAutoPercentile(self) -> "float":
        r"""
        Get the auto percentile for a controller.

        :rtype: float
        :return: auto percentile value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoPercentile(self)

    def GetAutoPercentileRange(self) -> "DoubleRange":
        r"""
        Get the auto percentile range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoPercentile.

        :rtype: Range< double >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoPercentileRange(self)

    def Type(self) -> "peak_afl_controllerType":
        r"""
        Get the controller type.

        See #peak_afl_controllerType for a list of values.

        :rtype: int
        :return: auto controller type

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Type(self)

    def IsAlgorithmSupported(self) -> "bool":
        r"""
        check if setting an algorithm is supported for a controller.

        True if algorithm is supported, otherwise it is unsupported.

        Call #GetAlgorithmList to get a list of supported algorithms.

        :rtype: boolean
        :return: boolean if controller supports setting an algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAlgorithmSupported(self)

    def SetAlgorithm(self, algorithm: "peak_afl_controller_algorithm") -> "None":
        r"""
        Set the used algorithm for a controller.

        To get a list of supported algorithms see #peak_afl_AutoController_Algorithm_GetList.

        :type algorithm: int, in
        :param algorithm: auto controller algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAlgorithm(self, algorithm)

    def GetAlgorithm(self) -> "peak_afl_controller_algorithm":
        r"""
        Get the used algorithm for a controller.

        :rtype: int
        :return: auto controller algorithm

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAlgorithm(self)

    def GetAlgorithmList(self) -> "Sequence[peak_afl_controller_algorithm]":
        r"""
        Get the list of supported algorithms for a controller.

        To set a value, see #SetAlgorithm.

        :rtype: Sequence[peak_afl_controller_algorithm]
        :return: vector of supported algorithms

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAlgorithmList(self)

    def IsSharpnessAlgorithmSupported(self) -> "bool":
        r"""
        check setting a sharpness algorithm is supported by a controller.

        True if sharpness algorithm is supported, otherwise it is unsupported.

        Call #GetSharpnessAlgorithmList to get a list of supported sharpness algorithms.

        :rtype: boolean
        :return: boolean if controller supports setting a sharpness algorithm

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Controller_IsSharpnessAlgorithmSupported(self)

    def SetSharpnessAlgorithm(self, algorithm: "peak_afl_controller_sharpness_algorithm") -> "None":
        r"""
        Set the used sharpness algorithm for a controller.

        To get a list of supported algorithms see #peak_afl_AutoController_SharpnessAlgorithm_GetList.

        :type algorithm: int, in
        :param algorithm:  auto controller sharpness algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetSharpnessAlgorithm(self, algorithm)

    def GetSharpnessAlgorithm(self) -> "peak_afl_controller_sharpness_algorithm":
        r"""
        Get the used sharpness algorithm for a controller.

        :rtype: int
        :return: auto controller sharpness algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSharpnessAlgorithm(self)

    def GetSharpnessAlgorithmList(self) -> "Sequence[peak_afl_controller_sharpness_algorithm]":
        r"""
        Get the list of supported sharpness algorithms for a controller.

        To set a value, see #SetSharpnessAlgorithm.

        :rtype: Sequence[peak_afl_controller_sharpness_algorithm]
        :return: vector of supported algorithms

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSharpnessAlgorithmList(self)

    def IsWeightedROISupported(self) -> "bool":
        r"""
        Check if weighted region of interest is supported for a controller.

        True if weighted region of interest is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports weighted roi

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsWeightedROISupported(self)

    def SetWeightedROIs(self, list: "WeightedRectangleList") -> "None":
        r"""
        Set the autofeature weighted region of interest for a controller.

        Already set weighted regions of interest will be overwritten

        :type list: Sequence[peak_afl_weighted_rectangle]
        :param list: vector of weighted region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetWeightedROIs(self, list)

    def SetWeightedROI(self, rect: "peak_afl_weighted_rectangle") -> "None":
        r"""
        Set single autofeature weighted region of interest for a controller.

        Already set weighted regions of interest will be overwritten

        :type rect: :py:class:`peak_afl_weighted_rectangle`, in
        :param rect: weighted region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetWeightedROI(self, rect)

    def GetWeightedROIMinSize(self) -> "peak_afl_size":
        r"""
        Get the autofeature minimum size of weighted region of interest for a controller.

        :rtype: :py:class:`peak_afl_size`
        :return: the minimum size

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetWeightedROIMinSize(self)

    def GetWeightedROIs(self) -> "Sequence[peak_afl_weighted_rectangle]":
        r"""
        Get the autofeature weighted region of interest for a controller.

        :rtype: Sequence[peak_afl_weighted_rectangle]
        :return: vector with set #peak_afl_weighted_rectangle

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetWeightedROIs(self)

    def IsLimitSupported(self) -> "bool":
        r"""
        Check if limit is supported for a controller.

        True if limit is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports limit

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsLimitSupported(self)

    def SetLimit(self, limit: "peak_afl_controller_limit") -> "None":
        r"""
        Set the autofeature limit for a controller.

        Sets the minimum and maximum limit for the algorithm set by #peak_afl_AutoController_Algorithm_Set

        :type limit: :py:class:`peak_afl_controller_limit`, in
        :param limit:      the limit to set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetLimit(self, limit)

    def GetLimit(self) -> "peak_afl_controller_limit":
        r"""
        Get the autofeature limit for a controller.

        :rtype: :py:class:`peak_afl_controller_limit`
        :return: the limit set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLimit(self)

    def GetDefaultLimit(self) -> "peak_afl_controller_limit":
        r"""
        Get the autofeature default limit.

        :rtype: :py:class:`peak_afl_controller_limit`
        :return: the default limit set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetDefaultLimit(self)

    def IsHysteresisSupported(self) -> "bool":
        r"""
        Check if hysteresis is supported for a controller.

        True if hysteresis is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsHysteresisSupported(self)

    def SetHysteresis(self, hysteresis: "int") -> "None":
        r"""
        Set the autofeature hysteresis for a controller.

        Set the hysteresis for the algorithm set by #SetAlgorithm

        :type hysteresis: int, in
        :param hysteresis: the hysteresis to set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetHysteresis(self, hysteresis)

    def GetHysteresis(self) -> "int":
        r"""
        Get the autofeature hysteresis for a controller.

        :rtype: int
        :return: the hysteresis set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetHysteresis(self)

    def GetDefaultHysteresis(self) -> "int":
        r"""
        Get the autofeature hysteresis default.

        :rtype: int
        :return: the default hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetDefaultHysteresis(self)

    def GetHysteresisRange(self) -> "IntRange":
        r"""
        Get autofeature hysteresis range for a controller.

        :rtype: Range< int >
        :return: the Range of the hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetHysteresisRange(self)

    def IsBrightnessComponentModeSupported(self) -> "bool":
        r"""
        Check if auto mode is supported for a brightness controller component.

        true if auto mode is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessComponentModeSupported(self)

    def IsBrightnessComponentUnitSupported(self, component: "peak_afl_controller_brightness_component") -> "bool":
        r"""
        Check if a specific unit is supported for a brightness controller component.

        true if auto unit is supported, otherwise it is unsupported.

        :type component: int, in
        :param component:  autofeature brightness unit
        :rtype: boolean
        :return: boolean if controller supports auto unit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessComponentUnitSupported(self, component)

    def BrightnessComponentSetMode(self, component: "peak_afl_controller_brightness_component", mode: "peak_afl_controller_automode") -> "None":
        r"""
        Set the autofeature mode for a brightness controller component.

        Will set the controller mode to mode. See #peak_afl_controller_automode for a list of valid values.

        :type component: int, in
        :param component:  autofeature brightness component
        :type mode: int, in
        :param mode:       autofeature mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentSetMode(self, component, mode)

    def BrightnessComponentGetMode(self, component: "peak_afl_controller_brightness_component") -> "peak_afl_controller_automode":
        r"""
        Get the current autofeature mode for a brightness controller component.

        :type component: int, in
        :param component: autofeature brightness component
        :rtype: int
        :return: autofeature mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentGetMode(self, component)

    def BrightnessComponentStatus(self, component: "peak_afl_controller_brightness_component") -> "peak_afl_controller_status":
        r"""
        Get the status for a brightness controller component.

        See #peak_afl_controller_status for a list of values.

        :type component: int, in
        :param component: autofeature brightness component
        :rtype: int
        :return: controller status

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentStatus(self, component)

    def IsGainLimitSupported(self) -> "bool":
        r"""
        Check if auto gain limit is supported for a controller.

        :rtype: boolean
        :return: true if auto gain limit is supported, otherwise returns false.

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_IsGainLimitSupported(self)

    def SetGainLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.
        The used priority list is: Analog -> Digital -> Any -> IPL (if supplied).

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_SetGainLimit(self, limit)

    def GetGainLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current gain limit

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_GetGainLimit(self)

    def GetGainLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for gain limit

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_GetGainLimitRange(self)

    def SetGainAnalogLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the analog gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #SetGainAnalogLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the analog gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainAnalogLimit(self, limit)

    def GetGainAnalogLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature analog gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current analog gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainAnalogLimit(self)

    def GetGainAnalogLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature analog gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for analog gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainAnalogLimitRange(self)

    def SetGainDigitalLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the digital gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainDigitalLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the digital gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainDigitalLimit(self, limit)

    def GetGainDigitalLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature digital gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current digital gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainDigitalLimit(self)

    def GetGainDigitalLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature digital gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for digital gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainDigitalLimitRange(self)

    def SetGainCombinedLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the combined gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainCombinedLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the combined gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainCombinedLimit(self, limit)

    def GetGainCombinedLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature combined gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current combined gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainCombinedLimit(self)

    def GetGainCombinedLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature combined gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for combined gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainCombinedLimitRange(self)

    def SetGainHostLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the host gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainHostLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the host gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainHostLimit(self, limit)

    def GetGainHostLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature host gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current host gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainHostLimit(self)

    def GetGainHostLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature host gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for host gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainHostLimitRange(self)

    def SetExposureLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the exposure limit for a controller

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the exposure to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.4
        """
        return _ids_peak_afl_python_interface.Controller_SetExposureLimit(self, limit)

    def GetExposureLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature exposure limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current exposure limit

        :raises: Exception if function fails

        Since: 1.4
        """
        return _ids_peak_afl_python_interface.Controller_GetExposureLimit(self)

    def GetExposureLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature exposure limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current exposure limit range

        :raises: Exception if function fails

        Since: 1.4
        """
        return _ids_peak_afl_python_interface.Controller_GetExposureLimitRange(self)

# Register Controller in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Controller_swigregister(Controller)
PEAK_AFL_STATUS_SUCCESS = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_SUCCESS
r"""
    Operation completed successfully

    The function executed without any errors and completed the requested operation.
    """
PEAK_AFL_STATUS_ERROR = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_ERROR
r"""
    General error occurred

    An unspecified error occurred during function execution. Use peak_afl_GetLastError()
    to get detailed information about the specific error.

    See also: peak_afl_GetLastError()
    """
PEAK_AFL_STATUS_NOT_INITIALIZED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_NOT_INITIALIZED
r"""
    Library not initialized

    The auto feature library has not been initialized. Call peak_afl_Init()
    before using any other library functions.

    See also: peak_afl_Init()
    """
PEAK_AFL_STATUS_INVALID_PARAMETER = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_INVALID_PARAMETER
r"""
    Invalid parameter provided

    One or more function parameters are invalid (e.g., NULL pointers where valid
    pointers are required, out-of-range values, invalid handles).

    Notes: Check parameter documentation for valid ranges and requirements
    """
PEAK_AFL_STATUS_ACCESS_DENIED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_ACCESS_DENIED
r"""
    Access denied to resource

    The requested operation could not be performed due to insufficient permissions
    or the resource being locked by another process.
    """
PEAK_AFL_STATUS_BUSY = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_BUSY
r"""
    Resource is busy

    The requested resource (manager, controller, or device) is currently busy
    processing another operation. Try again later or check the status.

    See also: peak_afl_AutoFeatureManager_Status()
    """
PEAK_AFL_STATUS_BUFFER_TOO_SMALL = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_BUFFER_TOO_SMALL
r"""
    Provided buffer is too small

    The buffer provided for output data is smaller than required. Use the
    two-stage query pattern to determine the required buffer size.

    See also: 'principle_two_stage_query'
    """
PEAK_AFL_STATUS_INVALID_IMAGE_FORMAT = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_INVALID_IMAGE_FORMAT
r"""
    Invalid or unsupported image format

    The provided image format is not supported by the auto feature algorithms
    or the format parameters are invalid.

    Notes: Check supported pixel formats in the documentation
    """
PEAK_AFL_STATUS_NOT_SUPPORTED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_NOT_SUPPORTED
r"""
    Feature or operation not supported

    The requested feature or operation is not supported by the current device
    or configuration. Check feature availability before use.
    """
PEAK_AFL_STATUS_VALUE_ADJUSTED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_VALUE_ADJUSTED
r"""
    Parameter value was adjusted

    The operation succeeded, but one or more parameter values were automatically
    adjusted to fit within valid ranges. Check current values after the operation.

    Notes: This is not an error condition
    """
PEAK_AFL_CONTROLLER_TYPE_INVALID = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_INVALID
r"""
    Invalid or uninitialized controller type

    This value indicates an invalid controller type and should not be used
    for controller creation.
    """
PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS
r"""
    Automatic brightness exposure/gain controller

    Controls camera exposure time, gain settings, and other parameters to
    maintain optimal image brightness. Can work with multiple gain types
    (analog, digital, combined, host) and exposure settings.

    See also: 'ids_peak_afl_c_brightness'
    """
PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE
r"""
    Automatic white balance controller

    Adjusts color channel gains to correct for different lighting conditions
    and maintain accurate color reproduction. Supports various white balance
    algorithms and manual/automatic operation modes.

    See also: 'ids_peak_afl_c_whitebalance'
    """
PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS
r"""
    Automatic focus controller

    Automatically adjusts camera focus to achieve maximum image sharpness
    using various focus algorithms and search strategies. Supports both
    continuous and single-shot focus operations.

    See also: 'ids_peak_afl_c_focus'
    """
PEAK_AFL_CONTROLLER_AUTOMODE_OFF = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_OFF
r"""
    Auto feature disabled

    The controller is disabled and will not process images or adjust camera
    parameters. Use this mode to temporarily disable auto features without
    destroying the controller.
    """
PEAK_AFL_CONTROLLER_AUTOMODE_CONTINUOUS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_CONTINUOUS
r"""
    Continuous automatic adjustment

    The controller continuously processes incoming images and adjusts camera
    parameters as needed. This mode provides real-time adaptation to changing
    conditions but may cause visible parameter changes during operation.

    Notes: Best for applications where conditions change frequently
    """
PEAK_AFL_CONTROLLER_AUTOMODE_ONCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_ONCE
r"""
    Single adjustment operation

    The controller processes images and adjusts parameters once, then automatically
    switches to OFF mode. Use this for one-time calibration or when you want
    manual control over when adjustments occur.

    Notes: Controller will automatically switch to OFF after completion
    """
PEAK_AFL_CONTROLLER_STATUS_UNDEFINED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_UNDEFINED
r"""Controller status undefined"""
PEAK_AFL_CONTROLLER_STATUS_OFF = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_OFF
r"""
    Controller is disabled or inactive

    The controller is in OFF mode and not processing images.
    No automatic adjustments will be made until the controller
    is set to CONTINUOUS or ONCE mode.

    Notes: This is the initial state after controller creation
    See also: PEAK_AFL_CONTROLLER_AUTOMODE_OFF
    """
PEAK_AFL_CONTROLLER_STATUS_IN_PROGRESS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_IN_PROGRESS
r"""
    Controller is actively processing

    The controller is currently in the middle of processing an image
    or executing an algorithm. This indicates ongoing work that has
    not yet completed.

    Notes: Different from BUSY - indicates active algorithm execution
    Processing time varies by algorithm complexity
    """
PEAK_AFL_CONTROLLER_STATUS_FINISHED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_FINISHED
r"""
    Controller completed its operation successfully

    The controller has finished processing and reached its target
    or completed the requested operation. In ONCE mode, the controller
    automatically transitions to OFF after reaching this state.

    Notes: In CONTINUOUS mode, this state is brief before next processing
    In ONCE mode, controller switches to OFF after finishing
    """
PEAK_AFL_CONTROLLER_STATUS_BUSY = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_BUSY
r"""
    Controller is busy and cannot accept new requests

    The controller is currently occupied and cannot process new images
    or requests. This typically occurs when the controller is already
    processing an image or waiting for camera parameter adjustments.

    Notes: Check this status before submitting new images
    Different from IN_PROGRESS - indicates resource unavailability
    """
PEAK_AFL_CONTROLLER_STATUS_CANCELED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_CANCELED
r"""
    Controller operation was canceled

    The current operation was canceled before completion, either by
    user request or due to changing conditions. The controller is
    available for new operations.

    Notes: Controller can accept new operations after cancellation
    May occur when switching modes or stopping operations
    """
PEAK_AFL_CONTROLLER_STATUS_ERROR = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_ERROR
r"""
    Controller encountered an error

    An error occurred during processing or parameter adjustment.
    The controller may need to be reset or reconfigured.
    Use peak_afl_GetLastError() for detailed error information.

    Notes: Controller may remain in this state until error is resolved
    Check error details with peak_afl_GetLastError()
    See also: peak_afl_GetLastError()
    """
PEAK_AFL_CONTROLLER_STATUS_SKIPPED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_SKIPPED
r"""
    Controller skipped processing this frame

    The controller deliberately skipped processing the current frame,
    typically due to skip frames configuration or because the frame
    did not meet processing criteria.

    Notes: This is normal behavior when skip frames is configured
    Not an error condition - controller remains operational
    See also: peak_afl_AutoController_SkipFrames_Set()
    """
PEAK_AFL_CONTROLLER_ALGORITHM_AUTO = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_AUTO
r"""
    Automatic algorithm selection

    Deprecated: This value is deprecated. The automatic selection always defaults to
                the Golden Ratio algorithm. Use
                'PEAK_AFL_CONTROLLER_ALGORITHM_GOLDEN_RATIO_SEARCH' instead.
    """
PEAK_AFL_CONTROLLER_ALGORITHM_GOLDEN_RATIO_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_GOLDEN_RATIO_SEARCH
r"""
    Golden ratio search algorithm

    Uses golden section search to efficiently find the focus peak.
    Provides fast convergence with good accuracy for most scenes.
    Requires fewer focus steps than full scan methods.

    Notes: Fast convergence (typically 8-12 steps)
    Good for real-time applications
    May struggle with multiple focus peaks or low contrast scenes
    """
PEAK_AFL_CONTROLLER_ALGORITHM_HILL_CLIMBING_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_HILL_CLIMBING_SEARCH
r"""
    Hill climbing search algorithm

    Iteratively moves focus position toward increasing sharpness values.
    Good for fine-tuning focus around the optimal position.
    May get trapped in local maxima with complex scenes.

    Notes: Good for fine focus adjustments
    Fast for small focus corrections
    May fail with multiple focus peaks or noisy sharpness curves
    """
PEAK_AFL_CONTROLLER_ALGORITHM_GLOBAL_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_GLOBAL_SEARCH
r"""
    Global search algorithm

    Performs a comprehensive search across the focus range to find
    the global optimum. More robust against local maxima but slower
    than other methods. Best accuracy for complex scenes.

    Notes: Highest accuracy and reliability
    Handles multiple focus peaks well
    Slower than other algorithms (moderate speed)
    Best for critical applications where accuracy is paramount
    """
PEAK_AFL_CONTROLLER_ALGORITHM_FULL_SCAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_FULL_SCAN
r"""
    Full range scan algorithm

    Scans the entire focus range systematically to build a complete
    focus curve. Provides maximum accuracy but requires the most time.
    Ideal for laboratory, calibration, or non-real-time applications.

    Notes: Maximum accuracy possible
    Complete focus characterization across full range
    Slowest algorithm (full range scan)
    Best for laboratory, calibration, or quality control applications
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEDIAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEDIAN
r"""
    Median-based brightness calculation

    Uses the median value of pixel intensities in the analysis region.
    More robust against outliers and extreme values, providing stable
    brightness measurements in scenes with high contrast or noise.

    Notes: Recommended for scenes with varying lighting or high contrast
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEAN
r"""
    Mean-based brightness calculation

    Uses the arithmetic mean (average) of pixel intensities in the analysis
    region. Provides faster computation and smooth brightness transitions
    but may be affected by extreme pixel values.

    Notes: Recommended for evenly lit scenes with consistent lighting
    """
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_AUTO = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_AUTO
r"""
    Automatic algorithm selection

    Default sharpness algorithm.

    Deprecated: This value is deprecated. The automatic selection always defaults to
                the Tenengrad algorithm. Use
                'PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_TENENGRAD' instead.
    """
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_TENENGRAD = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_TENENGRAD
r"""
    Tenengrad gradient-based algorithm

    Uses gradient magnitude calculations to measure image sharpness.
    Effective for images with clear edges and high contrast features.
    Computationally efficient and works well in most lighting conditions.

    Notes: Good for high-contrast scenes with clear edges
    """
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_SOBEL = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_SOBEL
r"""
    Sobel edge detection algorithm

    Uses Sobel edge detection operators to measure sharpness based on
    edge strength. Particularly effective for images with fine details
    and textures. More sensitive to noise than Tenengrad.

    Notes: Best for detailed textures and fine patterns
    """
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_MEAN_SCORE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_MEAN_SCORE
r"""
    Mean score algorithm

    Calculates sharpness based on statistical measures of image content.
    Provides stable measurements but may be less sensitive to fine details.
    Good for consistent performance across varying image content.

    Notes: Stable performance, less sensitive to noise
    """
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_HISTOGRAM_VARIANCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_HISTOGRAM_VARIANCE
r"""
    Histogram variance algorithm

    Uses histogram analysis to measure image sharpness based on intensity
    distribution variance. Effective for images with good contrast but
    may be affected by lighting variations.

    Notes: Good for well-lit scenes with good contrast
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_INVALID = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_INVALID
r"""
    Invalid or uninitialized component

    This value indicates an invalid component type and should not be used
    for component operations.
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_EXPOSURE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_EXPOSURE
r"""
    Camera exposure time control

    Adjusts the camera's exposure time (shutter speed) to control brightness.
    Longer exposures increase brightness but may introduce motion blur.
    Generally the preferred method for brightness control when motion is not critical.

    Notes: May affect motion blur and frame rate
    See also: 'ids_peak_afl_c_exposure_limit'
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_GAIN
r"""
    Generic gain control

    Adjusts the camera's gain setting using the default gain control.
    The specific type of gain (analog/digital/combined/host) depends on camera implementation
    or support.

    Deprecated: Use specific gain types for better control
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_ANALOG_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_ANALOG_GAIN
r"""
    Analog gain control

    Adjusts the sensor's analog gain before digitization. Provides good
    signal-to-noise ratio but may be limited in range. Preferred over
    digital gain when available.

    Notes: Better noise characteristics than digital gain
    See also: 'ids_peak_afl_c_gain_analog_limit'
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_DIGITAL_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_DIGITAL_GAIN
r"""
    Digital gain control

    Adjusts gain in the digital domain after sensor readout. Wider range
    than analog gain but may amplify noise. Use when analog gain is
    insufficient or unavailable.

    Notes: May amplify sensor noise
    See also: 'ids_peak_afl_c_gain_digital_limit'
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_COMBINED_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_COMBINED_GAIN
r"""
    Combined analog and digital gain

    Automatically manages both analog and digital gain (combined) for optimal
    signal-to-noise ratio. Typically uses analog gain first, then
    digital gain for extended range.

    Notes: Recommended for best overall performance
    See also: 'ids_peak_afl_c_gain_combined_limit'
    """
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_HOST_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_HOST_GAIN
r"""
    Host-based software gain

    Applies gain in software on the host computer after image acquisition.
    Provides unlimited range but processes images after capture, potentially
    affecting real-time performance.

    Notes: Applied in software, may affect performance
    See also: 'ids_peak_afl_c_gain_host_limit'
    """
PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_INVALID = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_INVALID
r"""
    Invalid or uninitialized component

    This value indicates an invalid component type and should not be used
    for component operations.
    """
PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_ANALOG_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_ANALOG_GAIN
r"""
    Analog gain white balance control

    Adjusts individual color channel analog gains before digitization.
    Provides the best signal-to-noise ratio for white balance correction
    but may have limited adjustment range.

    Notes: Best noise performance, preferred when available
    """
PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_DIGITAL_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_DIGITAL_GAIN
r"""
    Digital gain white balance control

    Adjusts individual color channel gains in the digital domain after
    sensor readout. Wider adjustment range than analog gain but may
    amplify noise, especially in darker regions.

    Notes: Wider range but may amplify noise
    """
PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_COMBINED_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_COMBINED_GAIN
r"""
    Combined analog and digital gain control (combined)

    Automatically manages both analog and digital gains for each color
    channel to achieve optimal white balance with best signal-to-noise
    ratio. Uses analog gain first, then digital gain for extended range.

    Notes: Recommended for best overall performance
    """
PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_HOST_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_WHITEBALANCE_COMPONENT_HOST_GAIN
r"""
    Host-based software white balance

    Applies white balance correction in software on the host computer
    after image acquisition. Provides unlimited adjustment range but
    processes images after capture.

    Notes: Applied in software, may affect performance
    """
PEAK_AFL_CONTROLLER_ROI_WEIGHT_WEAK = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_WEAK
r"""
    Low importance weight

    This region has minimal influence on focus calculations.
    Use for background areas or regions of lesser importance.
    """
PEAK_AFL_CONTROLLER_ROI_WEIGHT_MEDIUM = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_MEDIUM
r"""
    Medium importance weight

    This region has moderate influence on focus calculations.
    Use for areas of average importance in the scene.
    """
PEAK_AFL_CONTROLLER_ROI_WEIGHT_STRONG = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_STRONG
r"""
    High importance weight

    This region has strong influence on focus calculations.
    Use for critical areas that must be in sharp focus.
    """
PEAK_AFL_CONTROLLER_CALLBACK_FINISHED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_FINISHED
r"""
    Controller operation finished callback

    Called when the controller completes an operation and reaches
    its target or finishes processing. Particularly useful in ONCE mode
    to detect when the controller has finished its adjustment.

    See also: PEAK_AFL_CALLBACK_FINISHED_FUNC
    """
PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING_DATA = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING_DATA
r"""
    Legacy processing data callback

    Deprecated: Use PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING instead

    Legacy callback type for processing data. Provides limited information
    compared to the newer processing callback.

    Notes: only available for 'ids_peak_afl_c_focus'

    See also: PEAK_AFL_CALLBACK_PROCESSING_DATA_FUNC
    """
PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING
r"""
    Enhanced processing callback

    Called during image processing to provide real-time access to
    processing data and intermediate results. Provides comprehensive
    information about the current processing state.

    See also: PEAK_AFL_CALLBACK_PROCESSING_FUNC
    """
class peak_afl_process_data(object):
    r"""
    Generic process data structure

    Base structure for all processing callback data. This structure contains
    common information available for all controller types during processing.
    Specific controller types provide extended structures with additional data.

    Notes: This is the base structure - cast to specific types for detailed data
    See also: peak_afl_process_data_brightness
    See also: peak_afl_process_data_focus
    See also: peak_afl_process_data_whitebalance
    See also: PEAK_AFL_CALLBACK_PROCESSING_FUNC
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_controller_status_set, doc=r"""
    Current controller status

    The operational status of the controller at the time of processing.
    Indicates whether the controller is actively processing, finished,
    or encountered an error.

    See also: peak_afl_controller_status
    """)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_controller_type_set, doc=r"""
    Type of controller generating this data

    Identifies which type of controller (brightness, focus, white balance)
    is providing this processing data. Use this to determine the appropriate
    cast for accessing extended data.

    See also: peak_afl_controllerType
    """)
    reserved: "char [32]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_reserved_set, doc=r"""
    Reserved space for future extensions

    Reserved bytes for future API extensions. Do not access or modify.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data

# Register peak_afl_process_data in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_swigregister(peak_afl_process_data)
class peak_afl_process_data_brightness(object):
    r"""
    Brightness controller process data

    Extended process data structure for brightness controllers. Contains
    brightness-specific information including the current brightness component
    being processed and the calculated mean brightness value from the image
    analysis.

    Notes: Cast from peak_afl_process_data when controller_type is BRIGHTNESS
    See also: peak_afl_process_data
    See also: PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_status_set, doc=r"""
    Current controller status

    The operational status of the brightness controller at the time of processing.

    See also: peak_afl_controller_status
    """)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_type_set, doc=r"""
    Controller type (always BRIGHTNESS)

    Will always be PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS for this structure.

    See also: peak_afl_controllerType
    """)
    controller_component: "peak_afl_controller_brightness_component" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_component_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_component_set, doc=r"""
    Current brightness component being processed

    Indicates which brightness adjustment mechanism (exposure, analog gain,
    digital gain, etc.) is currently being processed by the controller.

    See also: peak_afl_controller_brightness_component
    """)
    mean: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_mean_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_mean_set, doc=r"""
    Calculated mean brightness value

    The mean brightness value calculated from the current image analysis.
    This value is used by the controller to determine appropriate brightness
    adjustments. The scale and interpretation depend on the image format
    and controller configuration.
    """)
    reserved: "char [64]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_reserved_set, doc=r"""
    Reserved space for future extensions

    Reserved bytes for future API extensions. Do not access or modify.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_brightness_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_brightness())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_brightness

# Register peak_afl_process_data_brightness in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_brightness_swigregister(peak_afl_process_data_brightness)
class peak_afl_process_data_whitebalance(object):
    r"""
    White balance controller process data

    Extended process data structure for white balance controllers. Contains
    white balance-specific information including the calculated mean values
    for each color channel (RGB) and the current white balance component
    being processed.

    Notes: Cast from peak_afl_process_data when controller_type is WHITE_BALANCE
    See also: peak_afl_process_data
    See also: PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_status_set, doc=r"""
    Current controller status

    The operational status of the white balance controller at the time of processing.

    See also: peak_afl_controller_status
    """)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_type_set, doc=r"""
    Controller type (always WHITE_BALANCE)

    Will always be PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE for this structure.

    See also: peak_afl_controllerType
    """)
    mean_r: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_r_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_r_set, doc=r"""
    Calculated mean red channel value

    The mean brightness value for the red color channel calculated from
    the current image analysis. Used for white balance calculations.
    """)
    mean_g: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_g_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_g_set, doc=r"""
    Calculated mean green channel value

    The mean brightness value for the green color channel calculated from
    the current image analysis. Used for white balance calculations.
    """)
    mean_b: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_b_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_b_set, doc=r"""
    Calculated mean blue channel value

    The mean brightness value for the blue color channel calculated from
    the current image analysis. Used for white balance calculations.
    """)
    controller_component: "peak_afl_controller_whitebalance_component" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_component_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_component_set, doc=r"""
    Current white balance component being processed

    Indicates which white balance adjustment mechanism (analog gain,
    digital gain, combined gain, etc.) is currently being processed.

    See also: peak_afl_controller_whitebalance_component
    """)
    reserved: "char [64-sizeof(peak_afl_controller_whitebalance_component)]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_reserved_set, doc=r"""
    Reserved space for future extensions

    Reserved bytes for future API extensions. Do not access or modify.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_whitebalance())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_whitebalance

# Register peak_afl_process_data_whitebalance in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_swigregister(peak_afl_process_data_whitebalance)
class peak_afl_process_data_focus(object):
    r"""
    Focus controller process data

    Extended process data structure for focus controllers. Contains
    focus-specific information including current focus position and
    sharpness measurements from the focus algorithm.

    Notes: Cast from peak_afl_process_data when controller_type is AUTOFOCUS
    See also: peak_afl_process_data
    See also: PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_status_set, doc=r"""
    Current controller status

    The operational status of the focus controller at the time of processing.

    See also: peak_afl_controller_status
    """)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_type_set, doc=r"""
    Controller type (always AUTOFOCUS)

    Will always be PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS for this structure.

    See also: peak_afl_controllerType
    """)
    focus_value: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_focus_value_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_focus_value_set, doc=r"""
    Current focus position

    The current focus position of the camera lens. Units and range
    depend on the camera/lens system. This value represents the
    physical position being evaluated by the focus algorithm.
    """)
    sharpness_value: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_sharpness_value_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_sharpness_value_set, doc=r"""
    Current sharpness measurement

    The sharpness value calculated from the current image using the
    configured sharpness algorithm. Higher values typically indicate
    sharper images. The scale and range depend on the algorithm used.

    See also: peak_afl_controller_sharpness_algorithm
    """)
    reserved: "char [64]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_reserved_set, doc=r"""
    Reserved space for future extensions

    Reserved bytes for future API extensions. Do not access or modify.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_focus_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_focus())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_focus

# Register peak_afl_process_data_focus in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_focus_swigregister(peak_afl_process_data_focus)
PEAK_AFL_CONTROLLER_ROI_PRESET_CENTER = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_PRESET_CENTER
r"""
    Center region preset

    Sets the ROI to a centered region within the image.
    The exact size depends on the implementation but typically
    covers the center 25-50% of the image area.

    Notes: Automatically adapts to current image dimensions
    """
class peak_afl_size(object):
    r"""
    2D size structure

    Defines dimensions in a 2-dimensional coordinate space. Used throughout
    the API to specify image dimensions, region sizes, and other 2D measurements.
    All values are in pixels unless otherwise specified.

    Notes: Both width and height must be greater than 0 for valid sizes
    See also: peak_afl_rectangle, peak_afl_position
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width: "int" = property(_ids_peak_afl_python_interface.peak_afl_size_width_get, _ids_peak_afl_python_interface.peak_afl_size_width_set, doc=r"""
    Width dimension in pixels

    The horizontal extent of the size. Must be greater than 0 for valid sizes.

    Notes: Maximum value depends on camera and system capabilities
    """)
    height: "int" = property(_ids_peak_afl_python_interface.peak_afl_size_height_get, _ids_peak_afl_python_interface.peak_afl_size_height_set, doc=r"""
    Height dimension in pixels

    The vertical extent of the size. Must be greater than 0 for valid sizes.

    Notes: Maximum value depends on camera and system capabilities
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_size_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_size())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_size

# Register peak_afl_size in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_size_swigregister(peak_afl_size)
class peak_afl_position(object):
    r"""
    2D position structure

    Defines a position in a 2-dimensional coordinate space. Used to specify
    coordinates within images or other 2D coordinate systems.

    Notes: Coordinates are zero-based with origin at top-left corner
    See also: peak_afl_rectangle, peak_afl_size
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "int" = property(_ids_peak_afl_python_interface.peak_afl_position_x_get, _ids_peak_afl_python_interface.peak_afl_position_x_set, doc=r"""
    X-coordinate (horizontal position)

    The horizontal position in pixels from the left edge.
    Zero represents the leftmost position.
    """)
    y: "int" = property(_ids_peak_afl_python_interface.peak_afl_position_y_get, _ids_peak_afl_python_interface.peak_afl_position_y_set, doc=r"""
    Y-coordinate (vertical position)

    The vertical position in pixels from the top edge.
    Zero represents the topmost position.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_position_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_position())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_position

# Register peak_afl_position in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_position_swigregister(peak_afl_position)
class peak_afl_rectangle(object):
    r"""
    2D rectangle structure

    Defines a rectangular region in a 2-dimensional coordinate space.
    Used throughout the API to specify regions of interest, image areas,
    and other rectangular regions.

    Notes: Coordinates are zero-based with origin at top-left corner
    Width and height must be greater than 0 for valid rectangles
    See also: peak_afl_position, peak_afl_size
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_x_get, _ids_peak_afl_python_interface.peak_afl_rectangle_x_set, doc=r"""
    X-coordinate of top-left corner

    The horizontal position of the rectangle's left edge in pixels.
    """)
    y: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_y_get, _ids_peak_afl_python_interface.peak_afl_rectangle_y_set, doc=r"""
    Y-coordinate of top-left corner

    The vertical position of the rectangle's top edge in pixels.
    """)
    width: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_width_get, _ids_peak_afl_python_interface.peak_afl_rectangle_width_set, doc=r"""
    Width of rectangle in pixels

    The horizontal extent of the rectangle. Must be greater than 0.
    """)
    height: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_height_get, _ids_peak_afl_python_interface.peak_afl_rectangle_height_set, doc=r"""
    Height of rectangle in pixels

    The vertical extent of the rectangle. Must be greater than 0.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_rectangle_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_rectangle())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_rectangle

# Register peak_afl_rectangle in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_rectangle_swigregister(peak_afl_rectangle)
class peak_afl_weighted_rectangle(object):
    r"""
    Weighted region of interest for focus control

    Defines a rectangular region with an associated weight for focus analysis.
    The weight determines the relative importance of this region compared to
    other regions when calculating focus metrics.

    See also: peak_afl_roi_weight
    See also: peak_afl_rectangle
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    roi: "peak_afl_rectangle" = property(_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_roi_get, _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_roi_set, doc=r"""
    Rectangular region definition

    The rectangular area within the image where focus analysis will be performed.
    Must be within the image boundaries.
    """)
    weight: "peak_afl_roi_weight" = property(_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_weight_get, _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_weight_set, doc=r"""
    Weight of this region

    The relative importance of this region for focus calculations.
    Higher weights give more influence to this region's focus metrics.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_weighted_rectangle())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_weighted_rectangle

# Register peak_afl_weighted_rectangle in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_swigregister(peak_afl_weighted_rectangle)
class peak_afl_controller_limit(object):
    r"""
    Controller parameter limit range

    Defines the minimum and maximum limits for controller parameters such as
    focus position, exposure time, or gain values. Used to constrain automatic
    adjustments within acceptable ranges.

    Notes: Minimum value must be less than or equal to maximum value
    See also: peak_afl_double_limit for floating-point limits
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.peak_afl_controller_limit_min_get, _ids_peak_afl_python_interface.peak_afl_controller_limit_min_set, doc=r"""
    Minimum allowed value

    The lower bound for the parameter. The controller will not set
    values below this limit.
    """)
    max: "int" = property(_ids_peak_afl_python_interface.peak_afl_controller_limit_max_get, _ids_peak_afl_python_interface.peak_afl_controller_limit_max_set, doc=r"""
    Maximum allowed value

    The upper bound for the parameter. The controller will not set
    values above this limit.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_controller_limit_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_controller_limit())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_controller_limit

# Register peak_afl_controller_limit in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_controller_limit_swigregister(peak_afl_controller_limit)
class peak_afl_double_limit(object):
    r"""
    Floating-point parameter limit range

    Defines the minimum and maximum limits for floating-point controller parameters
    such as percentile values, tolerance settings, or other continuous parameters.
    Used to constrain automatic adjustments within acceptable ranges.

    Notes: Minimum value must be less than or equal to maximum value
    See also: peak_afl_controller_limit for integer limits
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "float" = property(_ids_peak_afl_python_interface.peak_afl_double_limit_min_get, _ids_peak_afl_python_interface.peak_afl_double_limit_min_set, doc=r"""
    Minimum allowed value

    The lower bound for the parameter. The controller will not set
    values below this limit.
    """)
    max: "float" = property(_ids_peak_afl_python_interface.peak_afl_double_limit_max_get, _ids_peak_afl_python_interface.peak_afl_double_limit_max_set, doc=r"""
    Maximum allowed value

    The upper bound for the parameter. The controller will not set
    values above this limit.
    """)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_double_limit_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_double_limit())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_double_limit

# Register peak_afl_double_limit in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_double_limit_swigregister(peak_afl_double_limit)
class IntRange(object):
    r"""
    Generic arithmetic range with inclusive endpoints and a defined step size.

    Represents a numeric interval where both ``min`` and ``max`` are included,
    and ``inc`` specifies the step between successive admissible values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.IntRange_min_get, _ids_peak_afl_python_interface.IntRange_min_set)
    max: "int" = property(_ids_peak_afl_python_interface.IntRange_max_get, _ids_peak_afl_python_interface.IntRange_max_set)
    inc: "int" = property(_ids_peak_afl_python_interface.IntRange_inc_get, _ids_peak_afl_python_interface.IntRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.IntRange_swiginit(self, _ids_peak_afl_python_interface.new_IntRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_IntRange

# Register IntRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.IntRange_swigregister(IntRange)
class DoubleRange(object):
    r"""
    Generic arithmetic range with inclusive endpoints and a defined step size.

    Represents a numeric interval where both ``min`` and ``max`` are included,
    and ``inc`` specifies the step between successive admissible values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "float" = property(_ids_peak_afl_python_interface.DoubleRange_min_get, _ids_peak_afl_python_interface.DoubleRange_min_set)
    max: "float" = property(_ids_peak_afl_python_interface.DoubleRange_max_get, _ids_peak_afl_python_interface.DoubleRange_max_set)
    inc: "float" = property(_ids_peak_afl_python_interface.DoubleRange_inc_get, _ids_peak_afl_python_interface.DoubleRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.DoubleRange_swiginit(self, _ids_peak_afl_python_interface.new_DoubleRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_DoubleRange

# Register DoubleRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.DoubleRange_swigregister(DoubleRange)
class UCharRange(object):
    r"""
    Generic arithmetic range with inclusive endpoints and a defined step size.

    Represents a numeric interval where both ``min`` and ``max`` are included,
    and ``inc`` specifies the step between successive admissible values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.UCharRange_min_get, _ids_peak_afl_python_interface.UCharRange_min_set)
    max: "int" = property(_ids_peak_afl_python_interface.UCharRange_max_get, _ids_peak_afl_python_interface.UCharRange_max_set)
    inc: "int" = property(_ids_peak_afl_python_interface.UCharRange_inc_get, _ids_peak_afl_python_interface.UCharRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.UCharRange_swiginit(self, _ids_peak_afl_python_interface.new_UCharRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_UCharRange

# Register UCharRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.UCharRange_swigregister(UCharRange)
class ControllerAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[peak_afl_controller_algorithm]":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_size(self)

    def swap(self, v: "ControllerAlgorithmList") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerAlgorithmList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerAlgorithmList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerAlgorithmList

# Register ControllerAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerAlgorithmList_swigregister(ControllerAlgorithmList)
class ControllerBrightnessAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[peak_afl_controller_brightness_algorithm]":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_size(self)

    def swap(self, v: "ControllerBrightnessAlgorithmList") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerBrightnessAlgorithmList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerBrightnessAlgorithmList

# Register ControllerBrightnessAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_swigregister(ControllerBrightnessAlgorithmList)
class ControllerSharpnessAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[peak_afl_controller_sharpness_algorithm]":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_size(self)

    def swap(self, v: "ControllerSharpnessAlgorithmList") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerSharpnessAlgorithmList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerSharpnessAlgorithmList

# Register ControllerSharpnessAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_swigregister(ControllerSharpnessAlgorithmList)
class ControllerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.ControllerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[Controller]":
        return _ids_peak_afl_python_interface.ControllerList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_size(self)

    def swap(self, v: "ControllerList") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerList

# Register ControllerList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerList_swigregister(ControllerList)
class WeightedRectangleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.WeightedRectangleList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.WeightedRectangleList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.WeightedRectangleList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[peak_afl_weighted_rectangle]":
        return _ids_peak_afl_python_interface.WeightedRectangleList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_pop(self)

    def append(self, x: "peak_afl_weighted_rectangle") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.WeightedRectangleList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_size(self)

    def swap(self, v: "WeightedRectangleList") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.WeightedRectangleList_swiginit(self, _ids_peak_afl_python_interface.new_WeightedRectangleList(*args))

    def push_back(self, x: "peak_afl_weighted_rectangle") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_back(self)

    def assign(self, n: "Any", x: "peak_afl_weighted_rectangle") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.WeightedRectangleList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.WeightedRectangleList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_WeightedRectangleList

# Register WeightedRectangleList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.WeightedRectangleList_swigregister(WeightedRectangleList)

