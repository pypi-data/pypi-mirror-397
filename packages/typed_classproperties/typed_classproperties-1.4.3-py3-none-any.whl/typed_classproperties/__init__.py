"""Typed decorators for classproperty and cached_classproperty."""

import sys
from functools import cached_property
from typing import TYPE_CHECKING, Generic, TypeVar, cast, overload

if sys.version_info >= (3, 12):
    from typing import override
else:
    from typing_extensions import override

if TYPE_CHECKING:
    from collections.abc import Callable, Sequence
    from typing import Final

    from typing_extensions import Self


__all__: "Sequence[str]" = ("cached_classproperty", "classproperty")


T_class = TypeVar("T_class")
T_value = TypeVar("T_value")


class classproperty(property, Generic[T_value]):
    """
    Decorator for a Class-level property.

    Credit to Denis Rhyzhkov on Stackoverflow: https://stackoverflow.com/a/13624858/1280629
    """

    @override
    def __init__(self, func: "Callable[..., T_value]", /) -> None:  # type: ignore[explicit-any]
        """Initialise the classproperty object."""
        super().__init__(func)

    @overload  # type: ignore[override]
    def __get__(self, owner_self: None, owner_cls: type, /) -> T_value: ...

    @overload
    def __get__(self, owner_self: object, owner_cls: type | None = ..., /) -> T_value: ...

    @override
    def __get__(self, owner_self: object | None, owner_cls: type | None = None, /) -> T_value:
        """Retrieve the value of the property."""
        if self.fget is None:
            BROKEN_OBJECT_MESSAGE: Final[str] = f"Broken object '{type(self).__name__}'."
            raise RuntimeError(BROKEN_OBJECT_MESSAGE)

        return cast("T_value", self.fget(owner_cls))


class cached_classproperty(
    cached_property[T_value], Generic[T_class, T_value]
):  # NOTE: inherits lock and __set_name__ logic from functools.cached_property
    """
    Decorator for a Class-level property whose results are cached.

    Example:
        >>> class MyClass:
        ...     @cached_classproperty
        ...     def some_complex_calculation(cls):
        ...         return 1000

    Property function is executed once, on first access to the property.
    The returned value is stored directly on the class thereafter.

    To remove a cached value generated by a cached_classproperty use the classmethod:
    `cached_classproperty.remove_cached_value()`

    I.e. Do not use `del MyClass.some_complex_calculation`
    as this will completely remove the cached value and the cached property setter.
    """

    @override
    def __set_name__(self, owner: type, name: str, /) -> None:
        """Store the lookup key of the cached-classproperty."""
        super().__set_name__(owner, name)

        if not hasattr(owner, "_original_cached_classproperties"):
            setattr(owner, "_original_cached_classproperties", {})  # noqa: B010

        getattr(owner, "_original_cached_classproperties")[self.attrname] = self  # noqa: B009

    def _get_cached_property(self, owner: type | None) -> "Self | T_value":
        if self.attrname is None or owner is None:
            raise RuntimeError

        # NOTE: We must check if another thread filled the cache while we awaited lock
        attrval: Self | T_value = owner.__dict__[self.attrname]

        if attrval is not self:
            return attrval

        val = self.func(owner)
        setattr(owner, self.attrname, val)  # NOTE: This overwrites this property on the class
        getattr(owner, "_original_cached_classproperties")[self.attrname] = self  # noqa: B009

        return val

    @overload
    def __get__(self, instance: None, owner: type | None = None, /) -> "Self": ...

    @overload
    def __get__(self, instance: object, owner: type | None = None, /) -> T_value: ...

    @override
    def __get__(self, instance: object, owner: type | None = None, /) -> "Self | T_value":
        """Retrieve the value of the property."""
        if self.attrname is None:
            NO_NAME_SET_MESSAGE: Final[str] = (
                f"Cannot use {type(self).__name__} instance "
                "without calling `__set_name__()` on it."
            )
            raise TypeError(NO_NAME_SET_MESSAGE)

        if sys.version_info >= (3, 12):
            unlocked_cached_property: Self | T_value = self._get_cached_property(owner)
            return unlocked_cached_property

        with getattr(self, "lock"):  # type: ignore[unreachable, unused-ignore]  # noqa: B009
            locked_cached_property: Self | T_value = self._get_cached_property(owner)

        return locked_cached_property

    @classmethod
    def remove_cached_value(cls, cls_with_cache: object, name: str) -> None:
        """
        Remove a cached value generated by a cached_classproperty.

        If a cached_classproperty is deleted from the parent class
        (E.g. via `del MyClass.some_complex_calculation`),
        then it will be completely removed
        and subsequently accessing `MyClass.some_complex_calculation`
        will result in an AttributeError,
        so this method should be used instead.

        Raises:
            TypeError: If the classproperty never had any `cached_classproperty` attributes
                assigned to it.
        """
        if not hasattr(cls_with_cache, "_original_cached_classproperties"):
            NO_CLASS_PROPERTY_MESSAGE: Final[str] = (
                f"{cls_with_cache} has never had any `{cls.__name__}` attributes "
                "assigned to it."
            )
            raise TypeError(NO_CLASS_PROPERTY_MESSAGE)

        setattr(cls_with_cache, name, cls_with_cache._original_cached_classproperties[name])
