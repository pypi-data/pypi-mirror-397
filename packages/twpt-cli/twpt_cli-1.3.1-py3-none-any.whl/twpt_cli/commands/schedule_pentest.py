"""Schedule pentest command for ThreatWinds Pentest CLI."""

import json
import sys
import asyncio
import ipaddress
from pathlib import Path
from typing import Optional, List, Dict, Any

import click
from rich.console import Console
from rich.table import Table

from twpt_cli.config import load_credentials, get_api_endpoint, get_grpc_endpoint
from twpt_cli.config.playbooks import resolve_playbook_reference, get_playbook_metadata
from twpt_cli.config.memory import get_memory_for_pentest, get_memory_dir
from twpt_cli.sdk import (
    HTTPClient,
    GRPCClient,
    HTTPSchedulePentestRequest,
    HTTPTargetRequest,
    HTTPScope,
    HTTPType,
    HTTPStyle,
    Credentials,
)
from twpt_cli.sdk.models import UpdateType, convert_http_to_grpc_request

console = Console()


@click.command()
@click.option(
    '--config-file',
    type=click.Path(exists=True),
    help='Path to JSON configuration file'
)
@click.option(
    '--target',
    multiple=False,
    help='Single target to pentest'
)
@click.option(
    '--targets',
    multiple=True,
    help='Multiple targets to pentest (can be used multiple times)'
)
@click.option(
    '--no-exploit',
    is_flag=True,
    help='Disable exploitation phase (default: exploitation enabled)'
)
@click.option(
    '--safe',
    is_flag=True,
    help='Use safe mode instead of aggressive (default: aggressive)'
)
@click.option(
    '--scope',
    type=click.Choice(['holistic', 'targeted'], case_sensitive=False),
    help='Scope mode (default: auto-detect - holistic for public IPs/domains, targeted for private)'
)
@click.option(
    '--watch',
    is_flag=True,
    help='Watch pentest progress in real-time (streaming mode)'
)
@click.option(
    '--plan',
    type=str,
    help='Custom playbook: <name> from playbooks/ folder, or file:<path> for files'
)
@click.option(
    '--memory', '-m',
    multiple=True,
    help='Memory context (repeatable). Use @name for saved files, or plain text for inline'
)
@click.option(
    '--no-default-memory',
    is_flag=True,
    help='Do not include memory/default.md automatically'
)
def schedule_pentest(
    config_file: Optional[str],
    target: Optional[str],
    targets: tuple,
    no_exploit: bool,
    safe: bool,
    scope: Optional[str],
    watch: bool,
    plan: Optional[str],
    memory: tuple,
    no_default_memory: bool,
):
    """Schedule a new penetration test.

    By default, pentests run in AGGRESSIVE mode with exploitation ENABLED.
    Use --safe to switch to safe mode, and --no-exploit to disable exploitation.

    Scope is auto-detected: public IPs/domains use HOLISTIC mode, private IPs use TARGETED.
    Use --scope to override auto-detection.

    You can provide targets in three ways:
    1. Using --config-file with a JSON configuration
    2. Using --target for a single target
    3. Using --targets multiple times for multiple targets

    CUSTOM PLAYBOOKS:

    Use --plan to execute a custom playbook (markdown document with phases/steps).
    Playbooks are stored in the playbooks/ folder in your project directory.

    \b
      --plan web-audit              Load playbook from playbooks/web-audit.md
      --plan file:./my-plan.md      Load playbook from any file path

    Playbooks are markdown documents defining pentest phases, steps, and instructions.
    The AI agent will execute each section systematically.

    ADDING CONTEXT TO A PENTEST:

    Use --config-file with a JSON file to provide additional context such as
    credentials, specific scope settings per target, or test type configuration.

    JSON Configuration Format:
    \b
        {
          "Style": "AGGRESSIVE",
          "Exploit": true,
          "Targets": [
            {
              "Target": "example.com",
              "Scope": "HOLISTIC",
              "Type": "BLACK_BOX",
              "Credentials": {
                "username": "admin",
                "password": "secret",
                "api_key": "your-api-key"
              }
            }
          ]
        }

    Configuration Options:
    \b
      Style:       AGGRESSIVE (default) or SAFE
      Exploit:     true (default) or false
      Scope:       HOLISTIC (public targets) or TARGETED (private/internal)
      Type:        BLACK_BOX (no prior knowledge) or WHITE_BOX (with credentials)
      Credentials: Object with authentication details (username, password, api_key, etc.)

    MEMORY/CONTEXT:

    Memory items are notes or context passed to the AI agent. They persist across
    all phases of the pentest. Memory files are stored in the memory/ folder.

    \b
    How memory works:
      - memory/default.md is AUTO-INCLUDED in standard pentests
      - Use @name to load a saved memory file (e.g., @brute-force)
      - Use plain text for inline/ad-hoc context
      - Use --no-default-memory to skip auto-inclusion of default.md

    \b
    Memory syntax:
      -m @name           Load memory/name.md file
      -m "plain text"    Inline context (not saved)
      --no-default-memory   Skip default.md

    \b
    EXAMPLES:

    Basic usage:
      twpt-cli run example.com                    # Pentest with default memory
      twpt-cli run example.com --watch            # Watch progress in real-time
      twpt-cli run example.com --safe             # Safe/non-destructive mode
      twpt-cli run 192.168.1.1                    # Private IP (auto: targeted)

    \b
    With playbooks:
      twpt-cli run example.com --plan web-audit           # Saved playbook
      twpt-cli run example.com --plan file:./custom.md    # File as playbook

    \b
    With memory (use @ for files, plain text for inline):
      twpt-cli run example.com -m @brute-force            # Load memory/brute-force.md
      twpt-cli run example.com -m "Focus on SQLi"         # Inline context
      twpt-cli run example.com -m @creds -m @sqli         # Multiple memory files
      twpt-cli run example.com -m @tips -m "Check /admin" # Mixed: file + inline

    \b
    Combined:
      twpt-cli run example.com --plan web-audit -m @creds --watch
    """
    # Load credentials
    creds = load_credentials()
    if not creds:
        console.print("✗ Not configured. Please run: twpt-cli configure", style="red")
        sys.exit(1)

    # Handle custom playbook if provided
    plan_content = None
    plan_meta = None
    if plan:
        try:
            console.print(f"Loading playbook: {plan}", style="cyan")
            plan_content = resolve_playbook_reference(plan)
            plan_meta = get_playbook_metadata(plan)
            console.print(f"✓ Playbook loaded: {plan_meta['name']}", style="green")
        except FileNotFoundError as e:
            console.print(f"✗ Playbook not found: {e}", style="red")
            sys.exit(1)
        except ValueError as e:
            console.print(f"✗ Invalid playbook: {e}", style="red")
            sys.exit(1)

    # Build request
    try:
        if config_file:
            request = load_request_from_file(config_file)
        else:
            request = build_request_from_flags(target, targets, no_exploit, safe, scope)
    except Exception as e:
        console.print(f"✗ Failed to build request: {e}", style="red")
        sys.exit(1)

    # Validate request has targets
    if not request.targets:
        console.print("✗ No targets specified", style="red")
        console.print("Use --target, --targets, or --config-file to specify targets", style="yellow")
        sys.exit(1)

    # Add custom plan to request if provided
    if plan_content:
        request.custom_plan_content = plan_content
        request.is_custom_plan = True
        request.plan_metadata = plan_meta

    # Collect memory items for the pentest
    # Use @name for saved memory files, plain text for inline context
    memory_names = []
    inline_memory = []

    for mem in memory:
        mem_clean = mem.strip()
        if not mem_clean:
            continue

        if mem_clean.startswith('@'):
            # @name syntax -> load from memory/ folder
            memory_name = mem_clean[1:]  # Remove @ prefix
            from twpt_cli.config.memory import memory_exists
            if memory_exists(memory_name):
                memory_names.append(memory_name)
            else:
                console.print(f"[yellow]Warning: Memory file not found: {memory_name}[/yellow]")
                console.print(f"[dim]Looking in: {get_memory_dir()}/{memory_name}.md[/dim]")
        else:
            # Plain text -> inline memory
            inline_memory.append(mem_clean)

    # Don't include default memory when using custom plans
    include_default = not no_default_memory and not plan_content

    memory_items = get_memory_for_pentest(
        memory_names=memory_names if memory_names else None,
        inline_memory=inline_memory if inline_memory else None,
        include_default=include_default,
    )

    # Add memory to request if any items collected
    if memory_items:
        request.memory_items = memory_items
        console.print(f"[cyan]Memory: {len(memory_items)} item(s) will be included[/cyan]")
        for item in memory_items:
            preview = item['content'][:40] + '...' if len(item['content']) > 40 else item['content']
            console.print(f"  - {item['name']}: {preview}", style="dim")

    # Display request summary
    display_request_summary(request, plan_meta, memory_items)

    # Execute based on mode
    if watch:
        # Streaming mode with gRPC
        console.print("\n⚙ Starting pentest with real-time streaming...\n", style="cyan")
        asyncio.run(stream_pentest(request, creds))
    else:
        # Regular HTTP mode
        console.print("\n⚙ Scheduling pentest...\n", style="cyan")
        schedule_via_http(request, creds)


def is_public_target(target: str) -> bool:
    """Determine if a target is a public IP or domain.

    Private targets include:
    - Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
    - Loopback (127.0.0.0/8)
    - Link-local (169.254.0.0/16)
    - localhost and .local domains

    All other targets (public IPs and domains) are considered public.

    Args:
        target: IP address or domain name

    Returns:
        True if the target is public, False if private
    """
    # Strip protocol and path if present
    target_clean = target.split('://')[1] if '://' in target else target
    target_clean = target_clean.split('/')[0]  # Remove path
    target_clean = target_clean.split(':')[0]  # Remove port

    # Check if it's localhost or .local domain
    if target_clean.lower() in ('localhost', 'localhost.localdomain'):
        return False
    if target_clean.lower().endswith('.local'):
        return False

    # Try to parse as IP address
    try:
        ip = ipaddress.ip_address(target_clean)
        # Check if it's a private IP
        return not ip.is_private and not ip.is_loopback and not ip.is_link_local and not ip.is_reserved
    except ValueError:
        # Not a valid IP, treat as domain
        # Assume all domains that aren't .local are public
        return True


def load_request_from_file(file_path: str) -> HTTPSchedulePentestRequest:
    """Load pentest request from JSON file.

    Args:
        file_path: Path to JSON configuration file

    Returns:
        HTTPSchedulePentestRequest object
    """
    with open(file_path, 'r') as f:
        data = json.load(f)

    # Convert to request object
    targets = []
    for target_data in data.get('Targets', data.get('targets', [])):
        targets.append(HTTPTargetRequest(
            target=target_data.get('Target', target_data.get('target')),
            scope=HTTPScope(target_data.get('Scope', target_data.get('scope', 'TARGETED'))),
            type=HTTPType(target_data.get('Type', target_data.get('type', 'BLACK_BOX'))),
            credentials=target_data.get('Credentials', target_data.get('credentials'))
        ))

    return HTTPSchedulePentestRequest(
        style=HTTPStyle(data.get('Style', data.get('style', 'AGGRESSIVE'))),
        exploit=data.get('Exploit', data.get('exploit', True)),
        targets=targets
    )


def build_request_from_flags(
    target: Optional[str],
    targets: tuple,
    no_exploit: bool,
    safe: bool,
    scope: Optional[str]
) -> HTTPSchedulePentestRequest:
    """Build pentest request from command-line flags.

    Args:
        target: Single target (can be comma-separated for multiple targets)
        targets: Multiple targets (from --targets flag, each can be comma-separated)
        no_exploit: Disable exploitation
        safe: Use safe mode
        scope: Scope mode override (holistic/targeted), or None for auto-detect

    Returns:
        HTTPSchedulePentestRequest object
    """
    # Collect all targets, splitting any comma-separated values
    all_targets = []
    if target:
        # Split comma-separated targets and strip whitespace
        for t in target.split(','):
            t = t.strip()
            if t:
                all_targets.append(t)
    # Process --targets options, also splitting comma-separated values
    for targets_item in targets:
        for t in targets_item.split(','):
            t = t.strip()
            if t:
                all_targets.append(t)

    # Build target requests
    target_requests = []
    for t in all_targets:
        # Determine scope: use override if provided, otherwise auto-detect
        if scope:
            target_scope = HTTPScope.HOLISTIC if scope.lower() == 'holistic' else HTTPScope.TARGETED
        else:
            # Auto-detect: public targets get HOLISTIC, private targets get TARGETED
            target_scope = HTTPScope.HOLISTIC if is_public_target(t) else HTTPScope.TARGETED

        target_requests.append(HTTPTargetRequest(
            target=t,
            scope=target_scope,
            type=HTTPType.BLACK_BOX,
            credentials=None
        ))

    return HTTPSchedulePentestRequest(
        style=HTTPStyle.SAFE if safe else HTTPStyle.AGGRESSIVE,
        exploit=not no_exploit,
        targets=target_requests
    )


def display_request_summary(
    request: HTTPSchedulePentestRequest,
    plan_meta: Optional[Dict[str, Any]] = None,
    memory_items: Optional[List[Dict[str, str]]] = None
):
    """Display a summary of the pentest request.

    Args:
        request: The pentest request to display
        plan_meta: Optional plan metadata if using a custom plan
        memory_items: Optional list of memory items being included
    """
    console.print("\n╔══════════════════════════════════════════════╗", style="cyan")
    console.print("║          Pentest Request Summary             ║", style="cyan")
    console.print("╚══════════════════════════════════════════════╝\n", style="cyan")

    style_color = "red" if request.style == "AGGRESSIVE" else "yellow"
    exploit_color = "red" if request.exploit else "yellow"

    # Display custom playbook info if present
    if plan_meta:
        console.print(f"Mode: [magenta]CUSTOM PLAYBOOK[/magenta]", style="white")
        console.print(f"Playbook: [magenta]{plan_meta.get('name', 'Unknown')}[/magenta]", style="white")
        if plan_meta.get('description'):
            console.print(f"Source: {plan_meta['description']}", style="dim")
        console.print("")

    console.print(f"Style: [{style_color}]{request.style}[/{style_color}] {'(default)' if request.style == 'AGGRESSIVE' else ''}", style="white")
    console.print(f"Exploit: [{exploit_color}]{'Enabled' if request.exploit else 'Disabled'}[/{exploit_color}] {'(default)' if request.exploit else ''}", style="white")
    console.print(f"Targets: {len(request.targets)}", style="white")

    # Display targets table
    table = Table(title="Targets", show_header=True, header_style="bold cyan")
    table.add_column("Target", style="white")
    table.add_column("Scope", style="yellow")
    table.add_column("Type", style="green")

    for target in request.targets:
        table.add_row(
            target.target,
            target.scope,
            target.type
        )

    console.print(table)

    # Display memory items if present
    if memory_items:
        console.print(f"\nMemory: [cyan]{len(memory_items)} item(s)[/cyan]", style="white")
        for item in memory_items:
            preview = item['content'][:50] + '...' if len(item['content']) > 50 else item['content']
            console.print(f"  • {item['name']}: {preview}", style="dim")


def schedule_via_http(request: HTTPSchedulePentestRequest, creds: Credentials):
    """Schedule pentest via HTTP API.

    Args:
        request: Pentest request
        creds: API credentials
    """
    try:
        client = HTTPClient(get_api_endpoint(), creds)
        pentest_id = client.schedule_pentest(request)

        console.print("\n✓ Pentest scheduled successfully!", style="green bold")
        console.print(f"Pentest ID: {pentest_id}", style="cyan")
        console.print("\nYou can check the status with:", style="dim")
        console.print(f"  twpt-cli get-pentest {pentest_id}", style="white")

    except Exception as e:
        console.print(f"\n✗ Failed to schedule pentest: {e}", style="red")
        sys.exit(1)


async def stream_pentest(request: HTTPSchedulePentestRequest, creds: Credentials):
    """Stream pentest progress via gRPC.

    Args:
        request: Pentest request
        creds: API credentials
    """
    client = GRPCClient(get_grpc_endpoint(), creds)
    pentest_id = None
    completed = False

    try:
        # Convert HTTP request to gRPC format
        request_dict = {
            'style': request.style,
            'exploit': request.exploit,
            'targets': [
                {
                    'target': t.target,
                    'scope': t.scope,
                    'type': t.type,
                    'credentials': json.dumps(t.credentials) if t.credentials else None
                }
                for t in request.targets
            ]
        }

        console.print("Streaming pentest updates (Ctrl+C to exit)...\n", style="dim")

        async for response in client.schedule_pentest_stream(request_dict):
            # Track pentest ID
            if response.get('type') == 'schedule_response':
                pentest_id = response.get('pentest_id')

            # Check for completion
            if response.get('type') == 'pentest_data':
                if response.get('status') == 'COMPLETED':
                    completed = True

            handle_stream_response(response)

    except KeyboardInterrupt:
        console.print("\n\nStream interrupted by user", style="yellow")
    except Exception as e:
        console.print(f"\n✗ Streaming error: {e}", style="red")
    finally:
        await client.close()

    # Auto-download on completion
    if completed and pentest_id:
        console.print("\n[cyan]Auto-downloading evidence...[/cyan]")
        try:
            from twpt_cli.commands.download_evidence import download_pentest_evidence
            download_pentest_evidence(pentest_id, creds)
        except Exception as e:
            console.print(f"[yellow]Auto-download failed: {e}[/yellow]")


def handle_stream_response(response: Dict[str, Any]):
    """Handle a streaming response from gRPC.

    Args:
        response: Parsed response dictionary
    """
    response_type = response.get('type')

    if response_type == 'schedule_response':
        console.print(f"✓ Pentest scheduled: {response['pentest_id']}", style="green bold")
        console.print(f"  {response['message']}", style="dim")

    elif response_type == 'pentest_data':
        # Display pentest status update
        data = response
        console.print(f"\n◆ Pentest Status Update", style="cyan")
        console.print(f"  ID: {data['id']}")
        console.print(f"  Status: {data['status']}")
        console.print(f"  Findings: {data.get('findings', 0)}")
        console.print(f"  Severity: {data.get('severity', 'NONE')}")

        # Display target statuses
        if data.get('targets'):
            for target in data['targets']:
                console.print(f"  Target: {target['target']}")
                console.print(f"    Status: {target['status']}")
                phase = target.get('phase')
                if phase and phase != 'PHASE_UNSPECIFIED':
                    console.print(f"    Phase: {phase}")

    elif response_type == 'status_update':
        update_type = response.get('update_type')
        message = response.get('message', '')

        # Only display if there's a message
        if message:
            # Map update types to symbols and colors
            type_map = {
                UpdateType.INFO.value: ('ℹ', 'blue'),
                UpdateType.ERROR.value: ('✗', 'red'),
                UpdateType.STATUS.value: ('◆', 'cyan'),
                UpdateType.DEBUG.value: ('⚙', 'dim'),
            }

            symbol, color = type_map.get(update_type, ('•', 'white'))
            console.print(f"{symbol} {message}", style=color)

        # If there's pentest data in the status update, display it
        if response.get('data'):
            handle_stream_response(response['data'])

    elif response_type == 'error':
        console.print(f"✗ Error: {response['error']}", style="red")
        if response.get('details'):
            console.print(f"  Details: {response['details']}", style="dim red")

    else:
        console.print(f"Unknown response: {response}", style="dim")