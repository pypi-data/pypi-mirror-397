# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ...core.serialization import FieldMetadata
from ...core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from ...types.classification import Classification
from ...types.classification_advanced_options import ClassificationAdvancedOptions
from ...types.classification_config_base_processor import ClassificationConfigBaseProcessor
from ...types.extraction_advanced_options import ExtractionAdvancedOptions
from ...types.extraction_config_base_processor import ExtractionConfigBaseProcessor
from ...types.json_object import JsonObject
from ...types.parse_config import ParseConfig
from ...types.splitter_advanced_options import SplitterAdvancedOptions
from ...types.splitter_config_base_processor import SplitterConfigBaseProcessor


class ProcessorCreateRequestConfig_Classify(UncheckedBaseModel):
    """
    The configuration for the processor. The type of configuration must match the processor type. One of `cloneProcessorId` or `config` must be provided.
    """

    type: typing.Literal["CLASSIFY"] = "CLASSIFY"
    base_processor: typing_extensions.Annotated[
        typing.Optional[ClassificationConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = None
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = None
    classifications: typing.List[Classification]
    classification_rules: typing_extensions.Annotated[
        typing.Optional[str], FieldMetadata(alias="classificationRules")
    ] = None
    advanced_options: typing_extensions.Annotated[
        typing.Optional[ClassificationAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = None
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class ProcessorCreateRequestConfig_Extract(UncheckedBaseModel):
    """
    The configuration for the processor. The type of configuration must match the processor type. One of `cloneProcessorId` or `config` must be provided.
    """

    type: typing.Literal["EXTRACT"] = "EXTRACT"
    base_processor: typing_extensions.Annotated[
        typing.Optional[ExtractionConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = None
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = None
    extraction_rules: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="extractionRules")] = None
    schema_: typing_extensions.Annotated[typing.Optional[JsonObject], FieldMetadata(alias="schema")] = None
    fields: typing.Optional[typing.List["ExtractionField"]] = None
    advanced_options: typing_extensions.Annotated[
        typing.Optional[ExtractionAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = None
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class ProcessorCreateRequestConfig_Splitter(UncheckedBaseModel):
    """
    The configuration for the processor. The type of configuration must match the processor type. One of `cloneProcessorId` or `config` must be provided.
    """

    type: typing.Literal["SPLITTER"] = "SPLITTER"
    base_processor: typing_extensions.Annotated[
        typing.Optional[SplitterConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = None
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = None
    split_classifications: typing_extensions.Annotated[
        typing.List[Classification], FieldMetadata(alias="splitClassifications")
    ]
    split_rules: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="splitRules")] = None
    advanced_options: typing_extensions.Annotated[
        typing.Optional[SplitterAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = None
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


ProcessorCreateRequestConfig = typing_extensions.Annotated[
    typing.Union[
        ProcessorCreateRequestConfig_Classify,
        ProcessorCreateRequestConfig_Extract,
        ProcessorCreateRequestConfig_Splitter,
    ],
    UnionMetadata(discriminant="type"),
]
from ...types.extraction_field import ExtractionField  # noqa: E402, I001

update_forward_refs(ProcessorCreateRequestConfig_Extract, ExtractionField=ExtractionField)
