import os
import re
import difflib
from typing import List, Dict, Tuple, Optional
from .annotation_parser import AnnotationParser

class SourceModifier:
    def __init__(self, axion_instance):
        self.axion = axion_instance
        self.annotation_parser = AnnotationParser()

    def _generate_axion_tag(self, reg: Dict, existing_tag_content: str = None) -> str:
        """
        Generate the @axion attribute string (comment content).
        Preserves custom attributes from existing tag if provided.
        """
        attrs = []
        
        # 1. Access Mode
        access = reg.get('access', 'RW')
        attrs.append(f"{access}") 
        
        # 2. Addr (Preserve if existed, OR if manually set in GUI)
        # Note: Usually ADDR is auto-generated by VHDL code structure or comments.
        manual_addr = reg.get('manual_address')
        addr_val = reg.get('address')
        
        if manual_addr and addr_val:
            # User manually locked/edited this address
            # Ensure proper hex formatting
            if isinstance(addr_val, str) and not addr_val.lower().startswith('0x'):
                 try:
                     val_int = int(addr_val)
                     attrs.append(f"ADDR=0x{val_int:X}")
                 except ValueError:
                     attrs.append(f"ADDR={addr_val}") # Fallback
            else:
                 attrs.append(f"ADDR={addr_val}")

        elif existing_tag_content:
             # Fallback: Preserve ADDR if it was already there and NOT explicitly manual (e.g. slight edit to other field)
             # Quick check for ADDR=...
             addr_match = re.search(r'ADDR=0x[0-9A-F]+', existing_tag_content, re.IGNORECASE)
             if addr_match:
                 attrs.append(addr_match.group(0))
        
        # 3. Default Value
        default_val = reg.get('default_value')
        if default_val is not None:
             # Convert numeric string to int for proper formatting (hex logic below)
             if isinstance(default_val, str) and default_val.strip().isdigit():
                 default_val = int(default_val.strip())
        
        if default_val and default_val != '0' and default_val != 0 and default_val != '0x0':
            # Check format - if hex string, keep it. If int, convert.
            if isinstance(default_val, int):
                width = int(reg.get('width', 32))
                nibbles = (width + 3) // 4
                attrs.append(f"DEFAULT=0x{default_val:0{nibbles}X}")
            else:
                 attrs.append(f"DEFAULT={default_val}")
        elif (default_val == 0 or default_val == '0') and existing_tag_content:
             # Preserve explicit DEFAULT=0 if it was present
             if re.search(r'\bDEFAULT=(0|0x0)\b', existing_tag_content, re.IGNORECASE):
                  attrs.append("DEFAULT=0")
                 
        # 4. Description
        desc = reg.get('description')
        if desc:
            attrs.append(f'DESC="{desc}"')

        # 5. Strobes
        if reg.get('read_strobe') or reg.get('r_strobe'):
            attrs.append("R_STROBE")
        if reg.get('write_strobe') or reg.get('w_strobe'):
            attrs.append("W_STROBE")
            
        # 6. Custom Attributes Preservation (Other stuff)
        if existing_tag_content:
            # Parse existing tag to find "other" attributes
            dummy_line = f"-- @axion {existing_tag_content}" if not existing_tag_content.strip().startswith("--") else existing_tag_content
            parsed = self.annotation_parser.parse_annotation(dummy_line)
            
            if parsed:
                standard_keys = {
                    'access', 'access_mode', 
                    'read_strobe', 'write_strobe', 'r_strobe', 'w_strobe',
                    'width', 'default', 'default_value',
                    'addr', 'address', 'base_addr', 
                    'reg_name', 'signal_name', 'description'
                }
                
                for key, val in parsed.items():
                    if key not in standard_keys:
                        if val is True:
                            attrs.append(key.upper())
                        else:
                            attrs.append(f"{key}={val}")

        return f"-- @axion { ' '.join(attrs) }"

    def _generate_vhdl_signal(self, reg: Dict, include_description: bool = True, existing_tag: str = None, delimiter: str = " ") -> str:
        """Generate VHDL signal declaration for a new register."""
        name = reg['name']
        try:
            width = int(reg.get('width', 32))
        except (ValueError, TypeError):
            width = 32
            
        default_val_raw = reg.get('default_value', '')
        
        # Determine type
        if width == 1:
            sig_type = "std_logic"
            width_suffix = ""
            default_str = ""
        else:
            sig_type = "std_logic_vector"
            width_suffix = f"({width-1} downto 0)"
            default_str = ""

        # Default value handling:
        # User requested NOT to generate VHDL initialization (:= ...).
        # We only keep the DEFAULT attribute in the @axion tag.
        default_str = ""

        lines = []
        if include_description and reg.get('description'):
            lines.append(f"    -- {reg['description']}")
            
        axion_tag = self._generate_axion_tag(reg, existing_tag)
        # Use captured delimiter (e.g. "  ") instead of hardcoded space
        lines.append(f"    signal {name} : {sig_type}{width_suffix}{default_str};{delimiter}{axion_tag}")
        
        return "\n".join(lines)

    def _update_generics(self, content: str, properties: Dict) -> str:
        """Updates VHDL generics based on provided properties."""
        if not properties:
            return content
            
        # Update CDC Enable
        if 'cdc_enabled' in properties:
            val = 'true' if properties['cdc_enabled'] else 'false'
            # Look for C_CDC_ENABLE or CDC_ENABLED or similar
            # Pattern: (Name) : (Type) := (Value)
            pattern = r'(?i)((?:C_)?CDC_EN(?:ABLE|ABLED))\s*:\s*boolean\s*:=\s*(\w+)'
            
            def replace_bool(match):
                return f"{match.group(1)} : boolean := {val}"
                
            content = re.sub(pattern, replace_bool, content)
            
        # Update CDC Stages
        if 'cdc_stages' in properties:
            val = str(properties['cdc_stages'])
            pattern = r'(?i)((?:C_)?CDC_STAGES?)\s*:\s*integer\s*:=\s*(\d+)'
            
            def replace_int(match):
                return f"{match.group(1)} : integer := {val}"
                
            content = re.sub(pattern, replace_int, content)
            
        # Update Base Address (if it exists as generic C_BASEADDR)
        if 'base_address' in properties:
            val = properties['base_address']
            # Only update if it looks like a hex string
            if val and val.startswith('0x'):
                 # Pattern: C_BASEADDR : std_logic_vector... := X"..."
                 pass # Base address usually hex, complicated to match generic type easily without destroying formatting
                 # Skipping base addr as it is often a top-level param, not local default.
        
        return content

    def get_modified_content(self, module_name: str, new_registers: List[Dict], properties: Dict = None, file_path: str = None) -> Tuple[str, str]:
        """
        Generates the new content for the file associated with the module.
        Handles both adding NEW registers and UPDATING existing ones used Smart Preservation.
        
        Args:
            module_name: Name of the module
            new_registers: List of register dictionaries
            properties: Optional properties dict
            file_path: Optional file path for disambiguation when multiple modules have same name
        """
        # Find module - use file_path if provided for disambiguation
        if file_path:
            module = next((m for m in self.axion.analyzed_modules 
                          if m['name'] == module_name and m['file'] == file_path), None)
        else:
            module = next((m for m in self.axion.analyzed_modules if m['name'] == module_name), None)
            
        if not module:
            raise ValueError(f"Module {module_name} not found")

        filepath = module['file']
        
        # Route to appropriate handler based on file type
        if filepath.endswith(('.yaml', '.yml')):
            return self._modify_yaml_content(module, new_registers, properties)
        elif filepath.endswith('.json'):
            return self._modify_json_content(module, new_registers, properties)
        elif filepath.endswith('.xml'):
            return self._modify_xml_content(module, new_registers, properties)
        
        # VHDL files - original logic
        with open(filepath, 'r') as f:
            content = f.read()

        # Update Generics first
        content = self._update_generics(content, properties)
        
        # Update Module Definitions (@axion_def)
        content = self._update_module_definition(content, properties)

        # Identify existing signals
        existing_names = set()
        for r in module['registers']:
            existing_names.add(r.get('reg_name'))
            existing_names.add(r.get('signal_name'))
            if r.get('is_packed') and r.get('fields'):
                for f in r['fields']:
                    existing_names.add(f.get('signal_name'))
        
        # Regex to find architecture start
        arch_pattern = r'architecture\s+\w+\s+of\s+\w+\s+is'
        arch_match = re.search(arch_pattern, content, re.IGNORECASE)
        
        if not arch_match:
            return content, filepath
            
        search_start_idx = arch_match.end()
        is_vhdl = filepath.endswith(('.vhd', '.vhdl'))
        
        to_add = []
        
        for reg in new_registers:
            if reg['name'] in existing_names:
                # UPDATE existing register
                pattern = r'(\s*)signal\s+' + re.escape(reg['name']) + r'\s*:\s*[^;]+;.*'
                match = re.search(pattern, content, re.IGNORECASE)
                
                if match:
                    line_content = match.group(0)
                    existing_tag_content = None
                    
                    # Capture existing delimiter (whitespace before --)
                    # Look for ;<detected_whitespace>--
                    delimiter_match = re.search(r';(\s*)--', line_content)
                    detected_delimiter = delimiter_match.group(1) if delimiter_match else " "
                    
                    # Extract existing tag content for preservation
                    # Look for -- @axion ...
                    tag_match = re.search(r'--\s*@axion\s*:?(.+)$', line_content, re.IGNORECASE)
                    if tag_match:
                        existing_tag_content = tag_match.group(1).strip()
                    elif '--' in line_content: # Maybe just -- RW etc without @axion explicitly if loose?
                        # Parser expects @axion usually. If missing, maybe standard comments?
                        pass
                        
                    
                    # Smart Preservation Logic (VHDL Only)
                    structure_changed = True
                    original_reg = next((r for r in module['registers'] if r.get('reg_name') == reg['name'] or r.get('signal_name') == reg['name']), None)
                    
                    if is_vhdl and original_reg:
                        # Compare fields to see if line regeneration is even needed
                        if self._are_registers_identical(original_reg, reg):
                            structure_changed = False
                    
                    indent = match.group(1)
                    
                    if not structure_changed:
                         # Skip regeneration entirely - preserve exact line content
                         pass 
                    else:
                        # Full regeneration
                        new_line_content = self._generate_vhdl_signal(reg, include_description=False, existing_tag=existing_tag_content, delimiter=detected_delimiter).strip()
                        full_new_line = f"{indent}{new_line_content}"
                        content = re.sub(pattern, full_new_line, content, count=1)
            else:
                to_add.append(reg)
                
        if not to_add:
            return content, filepath

        # Logic for ADDING new registers
        lines_to_inject = []
        for reg in to_add:
             lines_to_inject.append(self._generate_vhdl_signal(reg))
             
        if not lines_to_inject:
             return content, filepath
            
        # Find position to insert new registers
        begin_match = re.search(r'\bbegin\b', content[search_start_idx:], re.IGNORECASE)
        
        if begin_match:
            insert_pos = search_start_idx + begin_match.start()
            injection = "\n    -- Axion-HDL Auto-Injected Signals\n"
            injection += "\n".join(lines_to_inject)
            injection += "\n"
            new_content = content[:insert_pos] + injection + content[insert_pos:]
            return new_content, filepath
            
        return content, filepath

    def compute_diff(self, module_name: str, new_registers: List[Dict], properties: Dict = None, file_path: str = None) -> Optional[str]:
        """Returns the unified diff between original and modified content.
        
        Args:
            module_name: Name of the module
            new_registers: List of register dictionaries
            properties: Optional properties dict
            file_path: Optional file path for disambiguation when multiple modules have same name
        """
        try:
            new_content, filepath = self.get_modified_content(module_name, new_registers, properties, file_path=file_path)
            with open(filepath, 'r') as f:
                original_content = f.read()
            
            if new_content == original_content:
                return None
            
            diff = difflib.unified_diff(
                original_content.splitlines(keepends=True),
                new_content.splitlines(keepends=True),
                fromfile=f"a/{os.path.basename(filepath)}",
                tofile=f"b/{os.path.basename(filepath)}"
            )
            return "".join(diff)
        except Exception as e:
            return f"Error generating diff: {str(e)}"

    def save_changes(self, module_name: str, new_registers: List[Dict], properties: Dict = None, file_path: str = None) -> bool:
        """Writes the modified content to disk."""
        new_content, filepath = self.get_modified_content(module_name, new_registers, properties, file_path=file_path)
        with open(filepath, 'w') as f:
            f.write(new_content)
        return True

    def _modify_yaml_content(self, module: Dict, new_registers: List[Dict], properties: Dict = None) -> Tuple[str, str]:
        """Modify YAML content preserving original structure using text-based replacement."""
        import re
        
        filepath = module['file']
        
        # Read original file as text to preserve comments and formatting
        with open(filepath, 'r') as f:
            content = f.read()
        
        # Build register lookup by name - only include registers that actually changed
        original_regs = {r.get('reg_name', r.get('signal_name', r.get('name'))): r for r in module.get('registers', [])}
        
        # Update base_addr if it changed
        if properties and properties.get('base_address'):
            new_base = properties.get('base_address')
            orig_base = module.get('base_address_raw', module.get('base_address', '0'))
            try:
                orig_base_int = int(orig_base, 16) if isinstance(orig_base, str) and orig_base.startswith('0x') else int(orig_base)
                new_base_int = int(new_base, 16) if isinstance(new_base, str) and new_base.startswith('0x') else int(new_base)
                if new_base_int != orig_base_int:
                    # Replace base_addr in YAML
                    content = re.sub(r'(base_addr:\s*)([^\n]+)', rf'\g<1>0x{new_base_int:04X}', content)
            except (ValueError, TypeError):
                pass
        
        # Build new register name set for deletion detection
        new_reg_names = {r.get('name') for r in new_registers}
        
        # Remove registers that are no longer in the new list
        for orig_name in list(original_regs.keys()):
            if orig_name not in new_reg_names:
                # Remove the entire register block from YAML
                # Match: "  - name: reg_name\n    ...until next register or end of registers section"
                pattern = rf'^\s*-\s*name:\s*{re.escape(orig_name)}\b[^\n]*\n(?:\s+[^\n]+\n)*?(?=\s*-\s*name:|\s*$)'
                content = re.sub(pattern, '', content, flags=re.MULTILINE)
        
        for new_reg in new_registers:
            reg_name = new_reg.get('name')
            orig_reg = original_regs.get(reg_name)
            
            if not orig_reg:
                continue
            
            # Check if access actually changed
            if new_reg.get('access') != orig_reg.get('access'):
                # Find and replace access for this register's block
                pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?access:\s*)[A-Z]+(\s)'
                replacement = rf'\g<1>{new_reg.get("access", "RW")}\2'
                content = re.sub(pattern, replacement, content, flags=re.DOTALL)
            
            # Check if width actually changed (compare as integers)
            orig_width = orig_reg.get('signal_width', orig_reg.get('width', 32))
            new_width = new_reg.get('width')
            try:
                orig_width_int = int(orig_width) if orig_width else 32
                new_width_int = int(new_width) if new_width else 32
            except (ValueError, TypeError):
                orig_width_int = 32
                new_width_int = 32
                
            if new_width_int != orig_width_int:
                pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?width:\s*)\d+(\s)'
                replacement = rf'\g<1>{new_width_int}\2'
                content = re.sub(pattern, replacement, content, flags=re.DOTALL)
            
            # Helper to insert field if missing
            def update_or_insert_yaml_field(content, reg_name, field_name, new_value, anchor_field='width'):
                # Try replacing first
                pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?{field_name}:\s*)([^\n]+)(\n)'
                match = re.search(pattern, content, flags=re.DOTALL | re.IGNORECASE)
                
                if match:
                    # Field exists, update it
                    replacement = rf'\g<1>{new_value}\3'
                    return re.sub(pattern, replacement, content, flags=re.DOTALL | re.IGNORECASE)
                else:
                    # Field missing, insert it after anchor
                    anchor_pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?{anchor_field}:\s*[^\n]+\n)'
                    anchor_match = re.search(anchor_pattern, content, flags=re.DOTALL)
                    if anchor_match:
                        # Find indentation of the anchor line
                        indent = re.match(r'\s*', anchor_match.group(0).split('\n')[-2]).group(0)
                        # Use same indentation for new field
                        insertion = f'{indent}{field_name}: {new_value}\n'
                        return content[:anchor_match.end()] + insertion + content[anchor_match.end():]
                return content

            # Check if description changed
            new_desc = new_reg.get('description')
            if new_desc and new_desc != orig_reg.get('description'):
                content = update_or_insert_yaml_field(content, reg_name, 'description', f'"{new_desc}"')

            # Check if default_value changed
            new_default = new_reg.get('default_value')
            if new_default and new_default not in (0, '0', '0x0', ''):
                if new_default != orig_reg.get('default_value'):
                    content = update_or_insert_yaml_field(content, reg_name, 'default_value', new_default)
            elif not new_default:
                # Remove if exists and new value is empty
                pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?)\s+default_value:\s*[^\n]+\n'
                content = re.sub(pattern, r'\1', content, flags=re.DOTALL)

            # Check if r_strobe changed
            new_r_strobe = new_reg.get('r_strobe', False)
            orig_r_strobe = orig_reg.get('rd_strobe')
            if orig_r_strobe is None:
                orig_r_strobe = orig_reg.get('r_strobe', False)
            
            if new_r_strobe != orig_r_strobe:
                if new_r_strobe: # True
                    content = update_or_insert_yaml_field(content, reg_name, 'r_strobe', 'true')
                else: # False -> remove
                    pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?)\s+r_strobe:\s*[^\n]+\n'
                    content = re.sub(pattern, r'\1', content, flags=re.DOTALL | re.IGNORECASE)
            
            # Check if w_strobe changed
            new_w_strobe = new_reg.get('w_strobe', False)
            orig_w_strobe = orig_reg.get('wr_strobe')
            if orig_w_strobe is None:
                orig_w_strobe = orig_reg.get('w_strobe', False)
            
            if new_w_strobe != orig_w_strobe:
                if new_w_strobe: # True
                    content = update_or_insert_yaml_field(content, reg_name, 'w_strobe', 'true')
                else: # False -> remove
                    pattern = rf'(- name:\s*{re.escape(reg_name)}\b.*?)\s+w_strobe:\s*[^\n]+\n'
                    content = re.sub(pattern, r'\1', content, flags=re.DOTALL | re.IGNORECASE)
        
        return content, filepath

    def _modify_json_content(self, module: Dict, new_registers: List[Dict], properties: Dict = None) -> Tuple[str, str]:
        """Modify JSON content preserving original structure, only updating changed registers."""
        import json
        
        filepath = module['file']
        
        # Read original file
        with open(filepath, 'r') as f:
            original_data = json.load(f)
        
        if not original_data:
            original_data = {}
        
        # Build lookup maps
        new_reg_map = {r.get('name'): r for r in new_registers}
        original_regs = {r.get('reg_name', r.get('signal_name', r.get('name'))): r for r in module.get('registers', [])}
        
        # Update module-level properties (base_addr, cdc, etc.) if they changed
        if properties:
            new_base = properties.get('base_address')
            # Use 'base_addr' key for JSON files
            if new_base and 'base_addr' in original_data:
                # Compare as normalized hex strings or integers
                try:
                    orig_base = original_data.get('base_addr', 0)
                    orig_base_int = int(orig_base, 16) if isinstance(orig_base, str) and orig_base.startswith('0x') else int(orig_base)
                    new_base_int = int(new_base, 16) if isinstance(new_base, str) and new_base.startswith('0x') else int(new_base)
                    if new_base_int != orig_base_int:
                        # Preserve original format (hex string vs int)
                        if isinstance(orig_base, str) and orig_base.startswith('0x'):
                            original_data['base_addr'] = f"0x{new_base_int:04X}"
                        elif isinstance(orig_base, str):
                            original_data['base_addr'] = str(new_base_int)
                        else:
                            original_data['base_addr'] = new_base_int
                except (ValueError, TypeError):
                    pass
            
            # Update CDC settings if they exist in original
            if 'cdc' in original_data or 'cdc_enabled' in original_data:
                if properties.get('cdc_enabled') is not None:
                    cdc_key = 'cdc' if 'cdc' in original_data else 'cdc_enabled'
                    original_data[cdc_key] = properties.get('cdc_enabled')
                if 'cdc_stages' in original_data and properties.get('cdc_stages'):
                    original_data['cdc_stages'] = int(properties.get('cdc_stages', 2))
        
        # Update registers in place - only if actually changed
        if 'registers' in original_data:
            # First, remove any registers that are no longer in the new list
            original_data['registers'] = [
                reg for reg in original_data['registers'] 
                if reg.get('name') in new_reg_map
            ]
            
            for i, file_reg in enumerate(original_data['registers']):
                reg_name = file_reg.get('name')
                if reg_name not in new_reg_map:
                    continue
                    
                new_reg = new_reg_map[reg_name]
                orig_reg = original_regs.get(reg_name, {})
                
                # Only update fields that actually changed AND exist in original
                if new_reg.get('access') != orig_reg.get('access') and 'access' in file_reg:
                    original_data['registers'][i]['access'] = new_reg.get('access')
                    
                # Compare width as integers to avoid false positives from type differences
                orig_width = orig_reg.get('signal_width', orig_reg.get('width', 32))
                new_width = new_reg.get('width')
                try:
                    orig_width_int = int(orig_width) if orig_width else 32
                    new_width_int = int(new_width) if new_width else 32
                except (ValueError, TypeError):
                    orig_width_int = 32
                    new_width_int = 32
                    
                if new_width_int != orig_width_int and 'width' in file_reg:
                    # Preserve original type (int or str)
                    if isinstance(file_reg['width'], int):
                        original_data['registers'][i]['width'] = new_width_int
                    else:
                        original_data['registers'][i]['width'] = str(new_width_int)
                    
                # Update or ADD description
                new_desc = new_reg.get('description')
                if new_desc and new_desc != orig_reg.get('description'):
                    original_data['registers'][i]['description'] = new_desc
                    
                # Update or ADD default_value (add if non-zero/non-empty)
                new_default = new_reg.get('default_value')
                if new_default and new_default not in (0, '0', '0x0', ''):
                    if new_default != orig_reg.get('default_value'):
                        original_data['registers'][i]['default_value'] = new_default
                elif 'default_value' in file_reg and not new_default:
                    # Remove if set to empty/zero and was present
                    del original_data['registers'][i]['default_value']
                
                # Update or ADD r_strobe
                new_r_strobe = new_reg.get('r_strobe', False)
                orig_r_strobe = orig_reg.get('rd_strobe')
                if orig_r_strobe is None:
                    orig_r_strobe = orig_reg.get('r_strobe', False)
                if new_r_strobe != orig_r_strobe:
                    if new_r_strobe:  # Add or update if True
                        original_data['registers'][i]['r_strobe'] = True
                    elif 'r_strobe' in file_reg:  # Remove if False and was present
                        del original_data['registers'][i]['r_strobe']
                
                # Update or ADD w_strobe
                new_w_strobe = new_reg.get('w_strobe', False)
                orig_w_strobe = orig_reg.get('wr_strobe')
                if orig_w_strobe is None:
                    orig_w_strobe = orig_reg.get('w_strobe', False)
                if new_w_strobe != orig_w_strobe:
                    if new_w_strobe:  # Add or update if True
                        original_data['registers'][i]['w_strobe'] = True
                    elif 'w_strobe' in file_reg:  # Remove if False and was present
                        del original_data['registers'][i]['w_strobe']
        
        new_content = json.dumps(original_data, indent=2)
        return new_content, filepath

    def _modify_xml_content(self, module: Dict, new_registers: List[Dict], properties: Dict = None) -> Tuple[str, str]:
        """Modify XML content preserving original structure, only updating changed register attributes."""
        import re
        
        filepath = module['file']
        
        # Read original file - preserve all structure including comments
        with open(filepath, 'r') as f:
            content = f.read()
        
        # Build lookup maps
        new_reg_map = {r.get('name'): r for r in new_registers}
        original_regs = {r.get('reg_name', r.get('signal_name', r.get('name'))): r for r in module.get('registers', [])}
        
        # Update base_addr if it changed
        if properties and properties.get('base_address'):
            new_base = properties.get('base_address')
            orig_base = module.get('base_address_raw', module.get('base_address', '0'))
            try:
                orig_base_int = int(orig_base, 16) if isinstance(orig_base, str) and orig_base.startswith('0x') else int(orig_base)
                new_base_int = int(new_base, 16) if isinstance(new_base, str) and new_base.startswith('0x') else int(new_base)
                if new_base_int != orig_base_int:
                    # Replace base_addr attribute in module tag
                    content = re.sub(r'(base_addr\s*=\s*["\'])([^"\']+)(["\'])', rf'\g<1>0x{new_base_int:04X}\3', content)
            except (ValueError, TypeError):
                pass
        
        # Remove registers that are no longer in the new list
        new_reg_names = {r.get('name') for r in new_registers}
        for orig_name in list(original_regs.keys()):
            if orig_name not in new_reg_names:
                # Remove the entire register tag
                # Match: <register ... name="orig_name" ... /> or <register ... name="orig_name" ...>...</register>
                pattern = rf'<register\s+[^>]*name=["\']{re.escape(orig_name)}["\'][^>]*(?:/>|>[^<]*</register>)'
                content = re.sub(pattern, '', content, flags=re.DOTALL)

        def update_register_tag(match):
            """Update a single register tag only for fields that actually changed."""
            tag = match.group(0)
            
            # Extract current name
            name_match = re.search(r'name\s*=\s*["\']([^"\']+)["\']', tag)
            if not name_match:
                return tag  # Keep original if no name found
                
            reg_name = name_match.group(1)
            if reg_name not in new_reg_map:
                return tag  # Should have been deleted already if not in map, but safe check
            
            new_reg = new_reg_map[reg_name]
            orig_reg = original_regs.get(reg_name, {})
            
            # Helper to insert attribute if missing
            def insert_attr(tag_str, attr_name, attr_value):
                if attr_value is None: return tag_str
                # Insert before closing /> or >
                if '/>' in tag_str:
                    return tag_str.replace('/>', f' {attr_name}="{attr_value}"/>')
                elif '>' in tag_str:
                    # Find the first > that closes the opening tag
                    first_close = tag_str.find('>')
                    return tag_str[:first_close] + f' {attr_name}="{attr_value}"' + tag_str[first_close:]
                return tag_str

            # Only update attributes that actually changed
            if new_reg.get('access') and new_reg.get('access') != orig_reg.get('access'):
                if re.search(r'access\s*=', tag):
                    tag = re.sub(r'access\s*=\s*["\'][^"\']*["\']', f'access="{new_reg.get("access")}"', tag)
                else:
                    tag = insert_attr(tag, 'access', new_reg.get('access'))
            
            # Compare width as integers to avoid type mismatch
            orig_width = orig_reg.get('signal_width', orig_reg.get('width', 32))
            new_width = new_reg.get('width')
            try:
                orig_width_int = int(orig_width) if orig_width else 32
                new_width_int = int(new_width) if new_width else 32
            except (ValueError, TypeError):
                orig_width_int = 32
                new_width_int = 32
                
            if new_width_int != orig_width_int:
                if re.search(r'width\s*=', tag):
                    tag = re.sub(r'width\s*=\s*["\'][^"\']*["\']', f'width="{new_width_int}"', tag)
                else:
                    tag = insert_attr(tag, 'width', new_width_int)
            
            # Description update/add
            new_desc = new_reg.get('description')
            if new_desc and new_desc != orig_reg.get('description'):
                desc = new_desc.replace('&', '&amp;').replace('"', '&quot;')
                if re.search(r'description\s*=', tag):
                    tag = re.sub(r'description\s*=\s*["\'][^"\']*["\']', f'description="{desc}"', tag)
                else:
                    tag = insert_attr(tag, 'description', desc)
            
            # Default value update/add/remove
            new_default = new_reg.get('default_value')
            if new_default and new_default not in (0, '0', '0x0', ''):
                if new_default != orig_reg.get('default_value'):
                    if re.search(r'default\s*=', tag):
                        tag = re.sub(r'default\s*=\s*["\'][^"\']*["\']', f'default="{new_default}"', tag)
                    else:
                        tag = insert_attr(tag, 'default', new_default)
            elif re.search(r'default\s*=', tag) and not new_default:
                # Remove if exists and new value is empty
                tag = re.sub(r'\s+default\s*=\s*["\'][^"\']*["\']', '', tag)
            
            # r_strobe update/add/remove
            new_r_strobe = new_reg.get('r_strobe', False)
            orig_r_strobe = orig_reg.get('rd_strobe')
            if orig_r_strobe is None:
                orig_r_strobe = orig_reg.get('r_strobe', False)
            
            if new_r_strobe != orig_r_strobe:
                if new_r_strobe: # True
                    if re.search(r'r_strobe\s*=', tag):
                        tag = re.sub(r'r_strobe\s*=\s*["\'][^"\']*["\']', f'r_strobe="true"', tag)
                    else:
                        tag = insert_attr(tag, 'r_strobe', 'true')
                elif re.search(r'r_strobe\s*=', tag): # False and exists -> remove
                    tag = re.sub(r'\s+r_strobe\s*=\s*["\'][^"\']*["\']', '', tag)
            
            # w_strobe update/add/remove
            new_w_strobe = new_reg.get('w_strobe', False)
            orig_w_strobe = orig_reg.get('wr_strobe')
            if orig_w_strobe is None:
                orig_w_strobe = orig_reg.get('w_strobe', False)
                
            if new_w_strobe != orig_w_strobe:
                if new_w_strobe: # True
                    if re.search(r'w_strobe\s*=', tag):
                        tag = re.sub(r'w_strobe\s*=\s*["\'][^"\']*["\']', f'w_strobe="true"', tag)
                    else:
                        tag = insert_attr(tag, 'w_strobe', 'true')
                elif re.search(r'w_strobe\s*=', tag): # False and exists -> remove
                    tag = re.sub(r'\s+w_strobe\s*=\s*["\'][^"\']*["\']', '', tag)
            
            return tag
        
        # Match <register ... /> or <register ...>...</register> tags
        new_content = re.sub(
            r'<register\s+[^>]*(?:/>|>[^<]*</register>)', 
            update_register_tag, 
            content, 
            flags=re.DOTALL
        )
        
        return new_content, filepath

    def _are_registers_identical(self, old_reg: Dict, new_reg: Dict) -> bool:
        """Compare register properties to check if any change occurred."""
        # 1. Access Mode
        # 1. Access Mode (normalize key names: parser uses access_mode, source uses access)
        old_access = old_reg.get('access') or old_reg.get('access_mode')
        new_access = new_reg.get('access') or new_reg.get('access_mode')
        if old_access != new_access:
            return False
            
        # 2. Width (Integer comparison)
        try:
            # Check for signal_width first in both (parser artifact)
            old_w = int(old_reg.get('signal_width', old_reg.get('width', 32)))
            new_w = int(new_reg.get('signal_width', new_reg.get('width', 32)))
            if old_w != new_w: return False
        except:
            return False # Assume changed on error
            
        # 3. Description
        # Normalize None -> empty string for safe comparison
        old_desc = old_reg.get('description') or ''
        new_desc = new_reg.get('description') or ''
        if old_desc.strip() != new_desc.strip():
             return False
             
        # 4. Strobes
        # Normalize none/false
        old_r = bool(old_reg.get('read_strobe') or old_reg.get('r_strobe'))
        new_r = bool(new_reg.get('r_strobe'))
        if old_r != new_r: return False
        
        old_w = bool(old_reg.get('write_strobe') or old_reg.get('w_strobe'))
        new_w = bool(new_reg.get('w_strobe'))
        if old_w != new_w: return False
        
        # 5. Default Value (Smart Compare)
        def parse_val(v):
            try:
                if isinstance(v, int): return v
                if isinstance(v, str):
                    if v.startswith('0x') or v.startswith('0X'): return int(v, 16)
                    return int(v)
                return 0
            except: return 0
            
        if parse_val(old_reg.get('default_value')) != parse_val(new_reg.get('default_value')):
            return False
            
        return True

    def _update_module_definition(self, content: str, properties: Dict) -> str:
        """Updates or injects @axion_def annotation for module properties."""
        if not properties:
            return content
            
        def_pattern = r'(--\s*@axion_def\s+)(.+)'
        match = re.search(def_pattern, content, re.IGNORECASE)
        
        cdc_en = properties.get('cdc_enabled')
        cdc_stages = properties.get('cdc_stages')
        
        if match:
            # Update existing
            prefix = match.group(1)
            attrs_str = match.group(2)
            
            # Standardized CDC Logic: Use KV pairs (CDC_EN=true/false)
            # Find existing CDC_EN token (flag or KV)
            # Pattern matches: CDC_EN, CDC_EN=true, CDC_EN=false, CDC_EN=1, etc.
            cdc_pattern = r'\bCDC_EN(?:=(?:true|false|yes|no|1|0))?\b'
            
            if cdc_en is True:
                if re.search(cdc_pattern, attrs_str, re.IGNORECASE):
                    # Replace existing with explicit true
                    attrs_str = re.sub(cdc_pattern, 'CDC_EN=true', attrs_str, flags=re.IGNORECASE)
                else:
                    # Append if missing
                    attrs_str += " CDC_EN=true"
            elif cdc_en is False:
                if re.search(cdc_pattern, attrs_str, re.IGNORECASE):
                    # Replace existing with explicit false (if it was there)
                    attrs_str = re.sub(cdc_pattern, 'CDC_EN=false', attrs_str, flags=re.IGNORECASE)
                # If explicit false was NOT there, we generally don't add it to keep it clean,
                # UNLESS the user explicitly requested it in properties? 
                # For now, if we are disabling, we overwrite existing to =false.
                
            # 2. CDC Stages
            if cdc_stages:
                if re.search(r'\bCDC_STAGE=\d+', attrs_str):
                     attrs_str = re.sub(r'\bCDC_STAGE=\d+', f'CDC_STAGE={cdc_stages}', attrs_str)
                elif cdc_en is True:
                     attrs_str += f" CDC_STAGE={cdc_stages}"
                     
            updated_line = f"{prefix}{attrs_str.strip()}"
            return re.sub(def_pattern, updated_line, content, count=1)
            
        else:
            # Inject new if CDC enabled
            if cdc_en:
                new_attrs = ["CDC_EN=true"]
                if cdc_stages:
                    new_attrs.append(f"CDC_STAGE={cdc_stages}")
                    
                new_line = f"-- @axion_def {' '.join(new_attrs)}"
                
                # Insert before entity
                entity_match = re.search(r'entity\s+(\w+)\s+is', content, re.IGNORECASE)
                if entity_match:
                    start = entity_match.start()
                    return content[:start] + new_line + "\n" + content[start:]
                else:
                    # Fallback: Top of file
                    return new_line + "\n" + content
                    
        return content
