# AUTOGENERATED FILE
from fastapi import FastAPI, Request, HTTPException, Header, Depends, UploadFile, File, Form, Query
from fastapi.responses import FileResponse, JSONResponse, StreamingResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.staticfiles import StaticFiles
from starlette.responses import Response
from starlette.testclient import TestClient
from starlette.exceptions import HTTPException as StarletteHTTPException
from pathlib import Path
from typing import Dict, Any, List, Optional
import json
import re
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from os import path as file_path

import asyncio
import tempfile
import uuid
import os
import shutil
from fastapi import UploadFile, File, Form
import aiofiles


from naeural_core.utils.uvicorn_fast_api_ipc_manager import UvicornPluginComms

eng = UvicornPluginComms(port={{ manager_port }}, auth={{ manager_auth }})

app = FastAPI(
  title={{ api_title }},
  summary={{ api_summary }},
  description={{ api_description }},
  version={{ api_version }},
)

app.add_middleware(
  CORSMiddleware,
  allow_origins=["*"],
  allow_credentials=True,
  allow_methods=["*"],
  allow_headers=["*"],
)

STATIC_DIR = "{{ static_directory }}"
DEBUG = {{ debug_web_app }}
{% if default_route is not none %}
DEFAULT_ROUTE = "{{ default_route }}"
{% else %}
DEFAULT_ROUTE = None
{% endif %}

# Define security scheme for Swagger UI
security = HTTPBearer()

def get_bearer_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    """
    Extract the Bearer token using FastAPI's HTTPBearer dependency.

    Parameters
    ----------
    credentials : HTTPAuthorizationCredentials
        Automatically provided by FastAPI when using HTTPBearer.

    Returns
    -------
    str
        The extracted token.

    Raises
    ------
    HTTPException
        If the token is invalid or missing.
    """
    if DEBUG:
        print(f"Received authorization credentials: {credentials}")
    if not credentials:
        raise HTTPException(status_code=401, detail="Authorization credentials are missing. Please provide a Bearer token.")
    if credentials.scheme.lower() != "bearer":
        raise HTTPException(status_code=401, detail=f"Invalid authorization scheme '{credentials.scheme}'. Expected 'Bearer'.")
    return credentials.credentials


{% for item in node_comm_params %}
{% if item['streaming_type'] == 'upload' %}
# Streaming upload endpoint
@app.post("/{{ item['name'] }}")
async def {{ item['name'] }}_upload(
    file: UploadFile = File(...),
    body: str = Form(None),
    {% if item['has_kwargs'] %}extras: str | None = Form(None),{% endif %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""

    body_json = {}
    if body:
        try:
            body_json = json.loads(body)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in form field 'body'")

    {% if item['has_kwargs'] %}
        extras_dict: Dict[str, Any] = {}
        if extras:
            try:
                extras_dict = json.loads(extras)
            except Exception:
                raise HTTPException(status_code=400,
                                    detail="Invalid JSON in form field 'extras'")
    {% endif %}

    temp_dir = None
    file_path = None

    try:
        # Create a unique temp directory and file path
        temp_dir = tempfile.mkdtemp(prefix="upload_", dir="/tmp")
        file_name = f"{file.filename}"
        file_path = os.path.join(temp_dir, file_name)

        # Save uploaded file stream chunk by chunk to disk
        with open(file_path, "wb") as f:
            while True:
                chunk = await file.read(1024 * 1024)
                if not chunk:
                    break
                f.write(chunk)

        # Prepare arguments for plugin call

        call_plugin_args: List = []
        {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
        call_plugin_args += [file_path, body_json]

{#        call_plugin_kwargs: Dict[str, Any] = {}#}
{#        {% if item['has_kwargs'] %}call_plugin_kwargs.update(extras_dict){% endif %}#}
        {% if item['has_kwargs'] %}call_plugin_args.append(extras_dict){% endif %}

        result = await eng.call_plugin(
            "{{ item['name'] }}",
            *call_plugin_args,
        )

        return result

    except Exception as e:
        # Optionally log the exception or wrap it in an HTTPException
        import traceback
        print(f"Error during file upload endpoint: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

    finally:
        # Cleanup: remove temp file and directory if they exist
        try:
            if file_path and os.path.isfile(file_path):
                os.remove(file_path)
            if temp_dir and os.path.isdir(temp_dir):
                shutil.rmtree(temp_dir)
        except Exception as cleanup_exc:
            print(f"Failed to cleanup temp upload files: {cleanup_exc}")


{% elif item['streaming_type'] == 'download' %}
# Streaming download endpoint
@app.get("/{{ item['name'] }}")
async def {{ item['name'] }}_download(
{#    {% for arg in item['args'] %}{{ arg }}, {% endfor %}#}
    {% if item['has_kwargs'] %}extras: str | None = Query(None),{% endif %}
    {% for arg in item['args'] %}{{ arg }}, {% endfor %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""

    {% if item['has_kwargs'] %}
    kwargs_dict: dict = {}
    if extras:
        try:
            kwargs_dict = json.loads(extras)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in query param 'extras'")
    {% endif %}

    response = await eng.call_plugin(
{#        "{{ item['name'] }}", token{% for param in item['params'] %}, {{ param }}{% endfor %}#}
        "{{ item['name'] }}",
        {% if item['require_token'] %}token,{% endif %}
        {% for param in item['params'] %}{{ param }},{% endfor %}
        {% if item['has_kwargs'] %}**kwargs_dict{% endif %}
    )

    file_path = ''
    meta = {}

    if isinstance(response, dict):
        # If the plugin returns a dict, extract the file path and metadata
        result = response.get("result", {})
        file_path = result.get("file_path", "")
        meta = result.get("meta", {})

    if not (isinstance(file_path, str) and os.path.isfile(file_path)):
        a = f"File not found!"
        raise HTTPException(status_code=404, detail=a)

    meta_str = json.dumps(meta)

    async def file_generator():
        chunk_size = 1024 * 1024  # 1 MB chunks
        async with aiofiles.open(file_path, 'rb') as f:
            while True:
                chunk = await f.read(chunk_size)
                if not chunk:
                    break
                yield chunk

    headers = {
        "x-meta": meta_str
    }

    return StreamingResponse(file_generator(), media_type='application/octet-stream', headers=headers)

{% else %}
# Regular endpoint
{% if item['method']=='post' %}
class {{ item['name'] }}Model(BaseModel):
    {% if item['args'] %}
    {% for arg in item['args'] %}
    {{ arg }}
    {% endfor %}
    {% if item['has_kwargs'] %}extras: Dict[str, Any] | None = None{% endif %}
    {% else %}
    pass
    {% endif %}

@app.post("/{{ item['name'] }}")
async def {{ item['name'] }}(
    request: {{ item['name'] }}Model
    {% if item['require_token'] %}, token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    {% for param in item['params'] %}
    {{ param }} = request.{{ param }}
    {% endfor %}

    {% if item['has_kwargs'] %}
    kwargs_dict = request.extras or {}
    {% endif %}

    # ---- build call arguments once, no nested ifs ----
    call_plugin_args: List = []
    {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
    {% for param in item['params'] %}
    call_plugin_args.append({{ param }})
    {% endfor %}

{#    call_plugin_kwargs: Dict[str, Any] = {}#}
{#    {% if item['has_kwargs'] %}call_plugin_kwargs.update(kwargs_dict){% endif %}#}
    {% if item['has_kwargs'] %}call_plugin_args.append(kwargs_dict){% endif %}

    result = await eng.call_plugin(
        "{{ item['name'] }}",
        *call_plugin_args,
    )

    {% if item['require_token'] %}
    if result.get("result") == "Unauthorized token" or result.get("status_code") == 401:
        raise HTTPException(status_code=401, detail=result.get("result", result))
    {% endif %}
    return result
{% else %}
{% if item['method'] is not none %}@app.{{ item['method'] }}("/{{ item['name'] }}"){% endif %}
async def {{ item['name'] }}(
    {% if item['has_kwargs'] %}extras: str | None = Query(None), {% endif %}
    {% for arg in item['args'] %}
    {{ arg }}, {% if not loop.last %} {% endif %}
    {% endfor %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    {% if item['has_kwargs'] %}
    kwargs_dict: Dict[str, Any] = {}
    if extras:
        try:
            kwargs_dict = json.loads(extras)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in query param 'extras'")
    {% endif %}

    # ---- build call arguments once, no nested ifs ----
    call_plugin_args: List = []
    {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
    {% for param in item['params'] %}
    call_plugin_args.append({{ param }})
    {% endfor %}

{#    call_plugin_kwargs: Dict[str, Any] = {}#}
{#    {% if item['has_kwargs'] %}call_plugin_kwargs.update(kwargs_dict){% endif %}#}
    {% if item['has_kwargs'] %}call_plugin_args.append(kwargs_dict){% endif %}

    result = await eng.call_plugin(
        "{{ item['name'] }}",
        *call_plugin_args,
    )

    {% if item['require_token'] %}
    if result.get("result") == "Unauthorized token" or result.get("status_code") == 401:
        raise HTTPException(status_code=401, detail=result.get("result", result))
    {% endif %}
    return result
{% endif %}
{% endif %} # endif item['streaming_type'] %}
{% endfor %}


{% for item in html_files %}
@app.{{ item['method'] }}('{{ item['route'] }}')
async def html_route{{ loop.index }}():
  return FileResponse(file_path.join(STATIC_DIR, '{{ item['name'] }}'))

{% endfor %}


@app.exception_handler(StarletteHTTPException)
async def custom_404_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code == 404:
        # Regex pattern to match files with specific extensions
        pattern = re.compile(r".*\.(js|png|jpg|css|jpeg|gif|svg|ico)$")
        if pattern.match(request.url.path):
            file_path = Path(STATIC_DIR) / request.url.path.strip("/")
            if file_path.exists() and file_path.is_file():
                return FileResponse(file_path)

    if DEFAULT_ROUTE is not None and request.url.path != DEFAULT_ROUTE:
        # Using TestClient to simulate a request internally
        with TestClient(app) as client:
            # Make a get request to the default route
            response = client.get(DEFAULT_ROUTE)
            return Response(content=response.content, status_code=response.status_code, headers=dict(response.headers))
    # endif DEFAULT_ROUTE defined

    print(f"StarletteHTTPException during request for {request.url}:\n{exc}")
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail or "An error occurred."},
    )

app.mount(f"/{STATIC_DIR}", StaticFiles(directory=STATIC_DIR), name="static")
