from matplotlib.axes import Axes
from matplotlib.figure import Figure, SubFigure

from .common import figaxs_defaults, centertext
import xarray as xr
from ....units.conversion import convert_time
from ....units.definitions import time


def plot_time_interstate_error(data: xr.Dataset, ax: Axes) -> Axes:
    """Function to plot the error bars/confidence intervals on time series interstate plots.

    Uses the `upper`, `lower` and `mean` variables of

    Args:
        data (Dataset): Interstate Dataset containing the `upper`, `lower` and `mean` variables generated by a confidence interval calculation.
            Data must have the appropriate unit as conversion is not possible without knowing the target dimension or unit.
            You can set the units in the `unit` attribute of the data.
            Similarly, you can specify the y-axis label with the `tex` attribute of the data.
            The time will, however, be converted to fs if not yet converted.
        ax (Axes): Axes object to plot the graph to.

    Returns:
        Axes: The axes that have been plotted to
    """
    # TODO: FIXME: Support more states.
    # vas = {
    #     '$S_2 - S_0$': 'bottom',
    #     '$S_2 - S_1$': 'bottom',
    #     '$S_1 - S_0$': 'top',
    # }
    for sc, scdata in data.groupby('statecomb'):
        c = scdata['_color'].item()
        scdata = scdata.squeeze('statecomb')

        # TODO: FIXME: Check if the state_names coordinate is maintained in a variable array.
        state_name_from = str(data['state_names'][sc[0] - 1].item())
        state_name_to = str(data['state_names'][sc[1] - 1].item())

        time_in_fs = convert_time(scdata['time'], time.femto_seconds)

        ax.fill_between(
            time_in_fs, scdata['upper'], scdata['lower'], color=c, alpha=0.3
        )
        ax.plot(time_in_fs, scdata['mean'], c=c, lw=0.8)
        # va = vas.get(sc, 'baseline')
        va = 'baseline'

        ax.text(
            float(scdata['time'][-1]),
            float(scdata['mean'][-1]),
            f"${state_name_from} \\to {state_name_to}$",
            c=c,
            va=va,
            ha='right',
        )

    ylabel = data.attrs['tex']
    if u := data.attrs.get('units'):
        ylabel += f" / {u}"
    ax.set_ylabel(ylabel)

    return ax


def plot_populations_graph(pops: xr.Dataset, ax: Axes) -> Axes:
    """Plot a graph of populations to the provided axes.

    Args:
        pops (xr.Dataset): The per-state population Dataset. We expect the `time` data to be in fs. If it can be converted, it will be converted to fs.
        ax (Axes): The Axes object to plot the population graph into

    Returns:
        Axes: The resulting Axes object after the plot
    """
    for state, sdata in pops.groupby('state'):
        c = sdata['_color'].item()
        # TODO: FIXME: Check if the state_names coordinate is maintained in a variable array.
        state_name = str(sdata['state_names'].item())

        time_in_fs = convert_time(sdata['time'], time.femto_seconds)

        ax.plot(time_in_fs, sdata, c=c, lw=0.5)
        ax.text(float(time_in_fs[-1]), float(sdata[-1]), state_name, c=c)

    ax.set_ylabel('Population')
    return ax


@figaxs_defaults(mosaic=[['pop'], ['de'], ['ft']], scale_factors=(1 / 3, 1 / 2))
def plot_timeplots(
    pops: xr.Dataset,
    delta_E: xr.Dataset,
    fig: Figure | SubFigure,
    fosc_time: xr.Dataset | None = None,
    axs: dict[str, Axes] | None = None,
) -> dict[str, Axes]:
    """Function to generate all time plots, involving population plots and state-transition plots.

    Args:
        pops (xr.DataArray): DataArray containing state population data with a time coordinate
        delta_E (xr.DataArray): DataArray containing the energy delta per state combination.
        fig (Figure| SubFigure): A figure, consumed by the autmatic axes generation. Not used by the function itself.
        fosc_time (xr.DataArray, optional): The oscillation frequency in a DataArray groupable by `time`
        axs (dict[str, Axes], optional): The dictionary of named Axes objects to plot the inidividual graphs into. Defaults to None.

    Returns:
        dict[str, Axes]: The axes dictionary after plotting.
    """
    assert axs is not None, "Could not generate axes for time plots."
    plot_populations_graph(pops, axs['pop'])
    plot_time_interstate_error(delta_E, axs['de'])
    if fosc_time is not None:
        plot_time_interstate_error(fosc_time, axs['ft'])
        lowest_ax = axs['ft']
        higher_axnames = ['de', 'pop']
    else:
        centertext(r"No $\mathbf{\mu}_{ij}$ data", ax=axs['ft'])
        axs['ft'].get_yaxis().set_visible(False)
        axs['ft'].get_xaxis().set_visible(False)
        lowest_ax = axs['de']
        higher_axnames = ['pop']

    lowest_ax.set_xlabel(r'$t$ / fs')  # TODO: Make configurable or ensure conversion.
    lowest_ax.minorticks_on()

    for axn in higher_axnames:
        axs[axn].sharex(lowest_ax)
        axs[axn].tick_params(axis='x', labelbottom=False)

    return axs
