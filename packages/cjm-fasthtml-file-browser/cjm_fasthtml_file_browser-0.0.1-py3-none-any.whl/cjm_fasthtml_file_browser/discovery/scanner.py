"""Scans directories for files with caching support"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/discovery/scanner.ipynb.

# %% auto 0
__all__ = ['FileScanner']

# %% ../../nbs/discovery/scanner.ipynb 3
import time
from pathlib import Path
from typing import Any, List, Dict, Optional
from fastcore.basics import patch

from ..core.types import FileType
from ..core.config import BrowserConfig
from ..core.models import FileEntry
from .utils import format_file_size, format_timestamp, matches_patterns

# %% ../../nbs/discovery/scanner.ipynb 5
class FileScanner:
    """Scans directories for files with instance-level caching."""

    def __init__(
        self,
        config: BrowserConfig  # Browser configuration with directories and filters
    ):
        """Initialize the scanner."""
        self.config = config
        self._cache: Optional[List[FileEntry]] = None
        self._cache_timestamp: float = 0

# %% ../../nbs/discovery/scanner.ipynb 6
@patch
def _is_cache_valid(
    self: FileScanner
) -> bool:  # True if cache exists and hasn't expired
    """Check if cache is still valid."""
    if not self.config.cache_results or self._cache is None:
        return False
    cache_duration = self.config.cache_duration_minutes * 60
    return (time.time() - self._cache_timestamp) < cache_duration

# %% ../../nbs/discovery/scanner.ipynb 7
@patch
def clear_cache(
    self: FileScanner
) -> None:
    """Clear the scan cache."""
    self._cache = None
    self._cache_timestamp = 0

# %% ../../nbs/discovery/scanner.ipynb 8
@patch
def _update_cache(
    self: FileScanner, 
    files: List[FileEntry]  # List of scanned FileEntry objects
) -> None:
    """Update cache with new scan results."""
    self._cache = files
    self._cache_timestamp = time.time()

# %% ../../nbs/discovery/scanner.ipynb 10
@patch
def _scan_directories(
    self: FileScanner
) -> List[FileEntry]:  # List of FileEntry objects matching the configuration
    """Perform actual directory scan."""
    files = []

    # Get enabled extensions and build extension->type map
    extensions = self.config.get_all_enabled_extensions()
    ext_to_type = self.config.build_extension_to_type_map()

    if not extensions:
        return []

    # Get file size limits in bytes
    max_size = self.config.max_file_size_mb * 1024 * 1024
    min_size = self.config.min_file_size_kb * 1024

    # Scan each directory
    for scan_dir in self.config.directories:
        if not Path(scan_dir).exists():
            continue

        scan_path = Path(scan_dir)

        # Determine glob pattern
        pattern = "**/*" if self.config.recursive_scan else "*"

        # Scan for files
        for file_path in scan_path.glob(pattern):
            # Skip directories
            if file_path.is_dir():
                continue

            # Skip symlinks if not following them
            if file_path.is_symlink() and not self.config.follow_symlinks:
                continue

            # Skip hidden files if configured
            if not self.config.include_hidden and file_path.name.startswith('.'):
                continue

            # Check exclude patterns
            if matches_patterns(str(file_path), self.config.exclude_patterns):
                continue

            # Check extension
            extension = file_path.suffix[1:].lower() if file_path.suffix else ""
            if extension not in extensions:
                continue

            # Get file stats
            try:
                stats = file_path.stat()
                file_size = stats.st_size

                # Check size limits
                if min_size > 0 and file_size < min_size:
                    continue
                if max_size > 0 and file_size > max_size:
                    continue

                # Determine file type from extension
                file_type = ext_to_type.get(extension, FileType.OTHER)

                # Create FileEntry object
                file_entry = FileEntry(
                    path=str(file_path),
                    name=file_path.name,
                    extension=extension,
                    size=file_size,
                    size_str=format_file_size(file_size),
                    modified=stats.st_mtime,
                    modified_str=format_timestamp(stats.st_mtime),
                    file_type=file_type,
                    directory=str(file_path.parent)
                )
                files.append(file_entry)

            except (OSError, PermissionError):
                # Skip files we can't access
                continue

    # Sort results
    files = self._sort_files(files)

    # Apply max results limit
    if self.config.max_results > 0 and len(files) > self.config.max_results:
        files = files[:self.config.max_results]

    return files

# %% ../../nbs/discovery/scanner.ipynb 11
@patch
def _sort_files(
    self: FileScanner,
    files: List[FileEntry]  # Files to sort
) -> List[FileEntry]:  # Sorted files
    """Sort files according to configuration."""
    sort_by = self.config.sort_by
    reverse = self.config.sort_descending

    if sort_by == "name":
        files.sort(key=lambda f: f.name.lower(), reverse=reverse)
    elif sort_by == "size":
        files.sort(key=lambda f: f.size, reverse=reverse)
    elif sort_by == "modified":
        files.sort(key=lambda f: f.modified, reverse=reverse)
    elif sort_by == "type":
        files.sort(key=lambda f: f.file_type.value, reverse=reverse)

    return files

# %% ../../nbs/discovery/scanner.ipynb 12
@patch
def scan(
    self: FileScanner, 
    force_refresh: bool = False  # Force a fresh scan, ignoring cache
) -> List[FileEntry]:  # List of FileEntry objects
    """Scan for files, using cache if valid."""
    if not force_refresh and self._is_cache_valid():
        return self._cache

    files = self._scan_directories()
    self._update_cache(files)
    return files

# %% ../../nbs/discovery/scanner.ipynb 13
@patch
def get_summary(
    self: FileScanner
) -> Dict[str, Any]:  # Dictionary with total count, size, and breakdowns by type/extension
    """Get summary statistics for scanned files."""
    files = self.scan()

    if not files:
        return {
            "total_files": 0,
            "total_size": 0,
            "total_size_str": "0 B",
            "by_type": {},
            "by_extension": {}
        }

    total_size = sum(f.size for f in files)

    # Count by type
    by_type = {}
    for f in files:
        type_name = f.file_type.value
        by_type[type_name] = by_type.get(type_name, 0) + 1

    # Count by extension
    by_extension = {}
    for f in files:
        ext = f.extension.upper() if f.extension else "NO EXT"
        by_extension[ext] = by_extension.get(ext, 0) + 1

    # Sort extensions by count and limit to top 10
    by_extension = dict(sorted(
        by_extension.items(),
        key=lambda x: x[1],
        reverse=True
    )[:10])

    return {
        "total_files": len(files),
        "total_size": total_size,
        "total_size_str": format_file_size(total_size),
        "by_type": by_type,
        "by_extension": by_extension
    }
