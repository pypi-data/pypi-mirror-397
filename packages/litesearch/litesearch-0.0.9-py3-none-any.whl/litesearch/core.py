# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['database']

# %% ../nbs/01_core.ipynb 4
from fastcore.all import first, dict2obj, L, Path, Generator, patch, Optional, Union, Iterable
from fastlite import Database
from apswutils.utils import cursor_row2dict
import numpy as np

# %% ../nbs/01_core.ipynb 5
@patch
def query(self: Database, sql: str, params: Optional[Union[Iterable, dict]] = None) -> Generator[dict, None, None]:
    '''Execute a query and return results as a list of AttrDict'''
    p = params if isinstance(params, dict) else tuple(params or tuple())
    cursor = self.execute(sql, p)
    cursor.row_trace = cursor_row2dict
    yield from cursor

# %% ../nbs/01_core.ipynb 7
@patch
def get_store(self:Database,    # database connection
            name:str='store',   # table name
            hash:bool=False,    # whether to create hash index on content
            **kw,               # additional args to pass to fastlite create
):
    "Make a sql table for content storage with FTS5 and vector search capabilities"
    cols = dict(content=str, embedding=bytes, metadata=str, uploaded_at=float,defaults=dict(uploaded_at='CURRENT_TIMESTAMP'),pk='id')
    if hash: cols.update(dict(hash_id='id',hash_id_columns=['content']))
    else: cols.update(dict(id=int, not_null=['content']))
    _content = self.t[name].create(**cols,if_not_exists=True, **kw)
    if not _content.detect_fts(): _content.enable_fts(['content','metadata'], create_triggers=True, tokenize='porter', replace=True)
    return _content

# %% ../nbs/01_core.ipynb 8
def database(pth_or_uri:str=':memory:',     # the database name or URL
             wal:bool=True,                 # use WAL mode
             sem_search:bool=True,          # enable usearch extensions
             **kw,                          # additional args to pass to apswutils database
             ) -> Database:
    'Set up a database connection and load usearch extensions.'

    if isinstance(pth_or_uri, (str, Path)): Path(pth_or_uri).parent.mkdir(exist_ok=True)
    _db = Database(pth_or_uri, **kw)
    if wal: _db.enable_wal()
    if not sem_search: return _db
    from usearch import sqlite_path
    _db.conn.enableloadextension(True)
    _db.conn.loadextension(sqlite_path())
    _db.conn.enableloadextension(False)
    return _db

# %% ../nbs/01_core.ipynb 9
@patch
def search(self: Database,  # database connection
           q:str,  # query string
           emb:bytes,  # embedding vector
           columns:list=None,  # columns to return
           where:str=None,  # additional where clause
           where_args:dict=None,  # args for where clause
           limit:int|None=50,  # limit on number of results
           offset:int|None=None,  # offset for results
           table_name='store',  # table name
           emb_col='embedding',  # embedding column name
           emb_metric:str='cosine',  # embedding distance metric (cosine,sqeuclidean,inner,divergence)
           rrf=True,  # need to rerank results with reciprocal rank fusion
           dtype=np.float16,  # embedding dtype
           ):
    'Search the litesearch store with fts and vector search combined.'
    if not q.strip(): return None
    content = self.get_store(table_name)
    if not columns: columns = ['content', 'metadata', 'embedding']
    fts = content.search(q, order_by='rank', columns=columns, limit=limit, where=where, where_args=where_args, quote=True)
    df='i8' if dtype==np.int8 else 'f16' if dtype==np.float16 else 'f64' if dtype==np.float64 else 'f32'
    vecs = content(select=','.join(columns), where=f'{emb_col} is not null' + (' AND ' + where if where else ''),
        where_args=dict(qvec=emb, **(where_args or {})), order_by=f'distance_{emb_metric}_{df}({emb_col}, :qvec)', limit=limit, offset=offset)
    if not rrf: return dict(fts=[f for f in fts], vec=vecs)
    ranked = (dict2obj(L(fts)) + L(dict2obj(vecs))).groupby('content')
    return [first(kv[1]) for kv in ranked.items()][:limit]
