package plugins.big.vascular.steerable3DFilter;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import javax.swing.JTextArea;import additionaluserinterface.WalkBar;import ij.*;import ij.process.*;import ij.gui.*;import java.lang.Math.*;public class Steerable3D {		private JTextArea logWindow;	private WalkBar walk;		private double precision = 0.00000000000000000001;			public Steerable3D() {				/*loadDialog = new FileDialog(new Frame(), "Browse", FileDialog.LOAD);		loadDialog.show();		String dirName = loadDialog.getDirectory();		String fileName = loadDialog.getFile();		String filePath = dirName+fileName;				if (fileName.endsWith(".txt")) {			try {				FileReader freader = new FileReader(filePath);				BufferedReader reader = new BufferedReader(freader);				int nx = Integer.parseInt(reader.readLine());				int ny = Integer.parseInt(reader.readLine());				int nz = Integer.parseInt(reader.readLine());				int xySize = nx*ny;				double[][] volume = new double[nz][xySize];				ImageStack volumeStack = new ImageStack(nx, ny);				for (int z=0;z<nz;z++) {					for (int i=0;i<xySize;i++) {							volume[z][i] = Double.parseDouble(reader.readLine());					}					volumeStack.addSlice("slice: " +(z+1), new FloatProcessor(nx, ny, volume[z]));				}					ImagePlus stackImage = new ImagePlus("volume", volumeStack);				input = new ImageVolume(stackImage);			} catch (FileNotFoundException e) {				IJ.write("File not found: " + e);			} catch (IOException e) {				IJ.write("IOException: " + e);			}		} else if (fileName.endsWith(".tif")) {			input = new ImageVolume(new ImagePlus(filePath));					} else {			IJ.showStatus("Incompatible file type");			return;		}		input.showZ("original Z");		// detect positive surfaces		FilterResponse surfaceDetection = detector3D(input, 3.0, 4.0, 1.0); // 1.0: positive features		ImageVolume response = surfaceDetection.getResponse();		ImageVolume nmsResult = surfaceNMS(surfaceDetection);		nmsResult.showZ("nms");		double[][][][] orientation = surfaceDetection.getOrientation();				// exportation of the array orientation		String s = System.getProperty("file.separator");				String ijPath = Prefs.getHomeDir() + s;		String dPath = ijPath + "plugins/Semester Project/";		vol2em(orientation, dPath+"orientation.em");				//IJ.showMessage("orientation[93][37][11] = "+orientation[93][37][11][0]+", "+orientation[93][37][11][1]+", "+orientation[93][37][11][2]+", ");						// detect positive curves		//FilterResponse tubeDetection = detector3D(input, 2.0, -(2.0/3.0), -1.0);		//ImageVolume response = tubeDetection.getResponse();		//FilterResponse nmsResult = curveNMS(tubeDetection);				response.showZ("response Z");		*/	}		/*	 * surface detector	 */	public FilterResponse detector3D(JTextArea logWindow, WalkBar walk, ImageVolume input, double sigma, double alpha, double sign) {				if (logWindow != null){			this.logWindow = logWindow;			this.walk = walk;						logWindow.append("\nMULTITHREADING: computing derivatives");			logWindow.setCaretPosition(logWindow.getDocument().getLength());		}				BaseFilters3D filterGxx = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GXX);		BaseFilters3D filterGyy = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GYY);		BaseFilters3D filterGzz = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GZZ);		BaseFilters3D filterGxy = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GXY);		BaseFilters3D filterGxz = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GXZ);		BaseFilters3D filterGyz = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GYZ);				int nBaseFilters = 6;		ExecutorService executor = Executors.newFixedThreadPool(nBaseFilters);		executor.execute(filterGxx);		executor.execute(filterGyy);		executor.execute(filterGzz);		executor.execute(filterGxy);		executor.execute(filterGxz);		executor.execute(filterGyz);				executor.shutdown();		while (!executor.isTerminated()) {}			ImageVolume gxx = filterGxx.getOutput(); 		ImageVolume gyy = filterGyy.getOutput();		ImageVolume gzz = filterGzz.getOutput(); 		ImageVolume gxy = filterGxy.getOutput();		ImageVolume gxz = filterGxz.getOutput(); 		ImageVolume gyz = filterGyz.getOutput(); 						if (logWindow != null){			logWindow.append("\nMULTITHREADING: computing derivatives done.");			logWindow.setCaretPosition(logWindow.getDocument().getLength());		}				int nx = input.getSizeX();		int ny = input.getSizeY();		int nz = input.getSizeZ();				double a, b, c, d, e, f, R, S, T;		double[] eigenValues = new double[3];		double maxEigenValue;		int maxIndex;		int multiplicity;		ImageVolume response = new ImageVolume(nx, ny, nz);		double m11,m12,m13,m22,m23,m33;		double[] U = new double[6];		double maxU;		//double p1, p2;		int index;		double[] eV = new double[3];		double[][][][] orientation = new double[nx][ny][nz][3];				if (logWindow != null)			walk.reset();				for (int x=0;x<nx;x++) {						if (logWindow != null)				walk.progress("3D steerable filter in progress.. ", (100.0*x)/nx);					for (int y=0;y<ny;y++) {				for (int z=0;z<nz;z++) {										a = sign*(gyy.getPixel(x, y, z) + gzz.getPixel(x, y, z) - alpha*gxx.getPixel(x, y, z));					b = sign*(gxx.getPixel(x, y, z) + gzz.getPixel(x, y, z) - alpha*gyy.getPixel(x, y, z));					c = sign*(gxx.getPixel(x, y, z) + gyy.getPixel(x, y, z) - alpha*gzz.getPixel(x, y, z));					d = -sign*(1.0+alpha)*gxy.getPixel(x, y, z);					e = -sign*(1.0+alpha)*gxz.getPixel(x, y, z);					f = -sign*(1.0+alpha)*gyz.getPixel(x, y, z);												a = approxZero(a, precision);					b = approxZero(b, precision);					c = approxZero(c, precision);					d = approxZero(d, precision);					e = approxZero(e, precision);					f = approxZero(f, precision);					/*if (x==32 && y==32 && z==32) {						IJ.write("a: "+a);						IJ.write("b: "+b);						IJ.write("c: "+c);						IJ.write("d: "+d);						IJ.write("e: "+e);						IJ.write("f: "+f);					}	*/														if  ( (d == 0.0) && (e == 0.0) && (f == 0.0) ) {						eigenValues[0] = a;						eigenValues[1] = b;						eigenValues[2] = c;						} else {						R = -a-b-c;						S = a*b + a*c + b*c - d*d - e*e - f*f;						T = a*f*f + b*e*e + c*d*d - a*b*c - 2.0*d*e*f;						eigenValues = cubic(R, S, T);					}										double tol = 0.00001;										multiplicity = 1;										maxEigenValue = eigenValues[0];					maxIndex = 0;					if ((eigenValues[1] > maxEigenValue) && (eigenValues[1] != 0.0)) {						maxEigenValue = eigenValues[1];						maxIndex = 1;					}					if ((eigenValues[2] > maxEigenValue) && (eigenValues[2] != 0.0)) {						maxEigenValue = eigenValues[2];						maxIndex = 2;					}													if (approxEqual(eigenValues[mod3(maxIndex+1)], maxEigenValue, tol)) {						maxEigenValue = eigenValues[mod3(maxIndex+2)];						multiplicity = 2;						} else if (approxEqual(eigenValues[mod3(maxIndex+2)], maxEigenValue, tol)) {						maxEigenValue = eigenValues[mod3(maxIndex+1)];						multiplicity = 2;						}					response.putPixel(x,y,z,maxEigenValue);										if (multiplicity == 2 || multiplicity == 3) {						orientation[x][y][z][0] = 0.0;						orientation[x][y][z][1] = 0.0;						orientation[x][y][z][2] = 0.0;					} else { // multiplicity == 1											m11 = a - maxEigenValue;						m12 = d;						m13 = e;						m22 = b - maxEigenValue;						m23 = f;						m33 = c - maxEigenValue;												U[0] = m22*m33-m23*m23;						U[1] = m13*m23-m12*m33;						U[2] = m12*m23-m13*m22;						U[3] = m11*m33-m13*m13;						U[4] = m12*m13-m23*m11;						U[5] = m11*m22-m12*m12;												/*						p1 = m11*m22 - m12*m12;						p2 = m22*m33 - m23*m23;						p1 = approxZero(p1, precision);						p2 = approxZero(p2, precision);						if (p1 > p2) {							eV[0] = m12*m23 - m13*m22;							eV[1] = m12*m13 - m11*m23;							eV[2] = p1;						} else {							eV[0] = p2;							eV[1] = m23*m13 - m12*m33;							eV[2] = m12*m23 - m22*m13;												}						*/						maxU = Math.abs(U[0]);						index = 0;						for (int i=1;i<6;i++) {							if (Math.abs(U[i]) > maxU) {								maxU = Math.abs(U[i]);								index = i;							}						}												if (index == 0) {							eV[0] = U[0];							eV[1] = U[1];							eV[2] = U[2];						} else if ( (index == 1) || (index == 3) ) {							eV[0] = U[1];							eV[1] = U[3]; 							eV[2] = U[4];						} else {							eV[0] = U[2];							eV[1] = U[4];							eV[2] = U[5];						}						eV = normalize(eV);						orientation[x][y][z][0] = eV[0];						orientation[x][y][z][1] = eV[1];						orientation[x][y][z][2] = eV[2];					}								}			}		}				FilterResponse output = new FilterResponse(response, orientation);				if (logWindow != null)			walk.finish("3D steerable filtering done.");				return output;	}		/*	 * step detector	 */	public FilterResponse detector3DStep(JTextArea logWindow, WalkBar walk, ImageVolume input, double sigma) {				if (logWindow != null){			this.logWindow = logWindow;			this.walk = walk;						logWindow.append("\nMULTITHREADING: computing derivatives");			logWindow.setCaretPosition(logWindow.getDocument().getLength());		}				BaseFilters3D filterGx = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GX);		BaseFilters3D filterGy = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GY);		BaseFilters3D filterGz = new BaseFilters3D(logWindow, input, sigma, BaseFilters3D.GZ);						int nBaseFilters = 3;		ExecutorService executor = Executors.newFixedThreadPool(nBaseFilters);		executor.execute(filterGx);		executor.execute(filterGy);		executor.execute(filterGz);						executor.shutdown();		while (!executor.isTerminated()) {}			ImageVolume gx = filterGx.getOutput(); 		ImageVolume gy = filterGy.getOutput();		ImageVolume gz = filterGz.getOutput(); 							if (logWindow != null){			logWindow.append("\nMULTITHREADING: computing derivatives done.");			logWindow.setCaretPosition(logWindow.getDocument().getLength());		}				int nx = input.getSizeX();		int ny = input.getSizeY();		int nz = input.getSizeZ();				double t11, t12, p11, p12; // angles theta and phi 		double t21, t22, p21, p22;				double[] r = new double[8]; // filter responses --> take maximum among these				double pGx, pGy, pGz; // pixels				double[][][][] orientation = new double[nx][ny][nz][3];				ImageVolume response = new ImageVolume(nx, ny, nz);				if (logWindow != null)			walk.reset();				for (int x=0;x<nx;x++) {						if (logWindow != null)				walk.progress("3D steerable (step) filter in progress.. ", (100.0*x)/nx);					for (int y=0;y<ny;y++) {				for (int z=0;z<nz;z++) {					pGx = gx.getPixel(x, y, z);					pGy = gy.getPixel(x, y, z);					pGz = gz.getPixel(x, y, z);										// calculate all possible angles (1st solution pair)					t11 = -Math.atan(pGx/pGy);					t12 = -Math.atan(pGx/pGy + Math.PI);					p11 = 0;					p12 = Math.atan(Math.PI);										// calculate all possible angles (2nd solution pair)					t21 = Math.atan(pGy/pGx);					t22 = Math.atan(pGy/pGx + Math.PI);					p21 = Math.atan( (pGx*pGx + pGy*pGy) / (pGx*pGz));					p22 = Math.atan( (pGx*pGx + pGy*pGy) / (pGx*pGz) + Math.PI);										// evaluate response											// 1st possible solution pair					r[0] = Math.cos(t11)*Math.sin(p11)*pGx + Math.sin(t11)*Math.sin(p11)*pGy + Math.cos(p11)*pGz;					r[1] = Math.cos(t12)*Math.sin(p11)*pGx + Math.sin(t12)*Math.sin(p11)*pGy + Math.cos(p11)*pGz;					r[2] = Math.cos(t11)*Math.sin(p12)*pGx + Math.sin(t11)*Math.sin(p12)*pGy + Math.cos(p12)*pGz;					r[3] = Math.cos(t12)*Math.sin(p12)*pGx + Math.sin(t12)*Math.sin(p12)*pGy + Math.cos(p12)*pGz;										// 2nd possible solution pair					r[4] = Math.cos(t21)*Math.sin(p21)*pGx + Math.sin(t21)*Math.sin(p21)*pGy + Math.cos(p21)*pGz;					r[5] = Math.cos(t22)*Math.sin(p21)*pGx + Math.sin(t22)*Math.sin(p21)*pGy + Math.cos(p21)*pGz;					r[6] = Math.cos(t21)*Math.sin(p22)*pGx + Math.sin(t21)*Math.sin(p22)*pGy + Math.cos(p22)*pGz;					r[7] = Math.cos(t22)*Math.sin(p22)*pGx + Math.sin(t22)*Math.sin(p22)*pGy + Math.cos(p22)*pGz;															int index = 0;					double max = -Double.MAX_VALUE;					for (int i=0; i<r.length; i++)	{												r[i] = approxZero(r[i], precision);												if (r[i] > max){							max = r[i];							index = i;						}													}										switch (index){					case 0: 						orientation[x][y][z][0] = Math.cos(t11)*Math.sin(p11);						orientation[x][y][z][1] = Math.sin(t11)*Math.sin(p11);						orientation[x][y][z][2] = Math.cos(p11);						break;											case 1: 						orientation[x][y][z][0] = Math.cos(t12)*Math.sin(p11);						orientation[x][y][z][1] = Math.sin(t12)*Math.sin(p11);						orientation[x][y][z][2] = Math.cos(p11);						break;											case 2: 						orientation[x][y][z][0] = Math.cos(t11)*Math.sin(p12);						orientation[x][y][z][1] = Math.sin(t11)*Math.sin(p12);						orientation[x][y][z][2] = Math.cos(p12);						break;											case 3: 						orientation[x][y][z][0] = Math.cos(t12)*Math.sin(p12);						orientation[x][y][z][1] = Math.sin(t12)*Math.sin(p12);						orientation[x][y][z][2] = Math.cos(p12);						break;											case 4: 						orientation[x][y][z][0] = Math.cos(t21)*Math.sin(p21);						orientation[x][y][z][1] = Math.sin(t21)*Math.sin(p21);						orientation[x][y][z][2] = Math.cos(p21);						break;											case 5: 						orientation[x][y][z][0] = Math.cos(t22)*Math.sin(p21);						orientation[x][y][z][1] = Math.sin(t22)*Math.sin(p21);						orientation[x][y][z][2] = Math.cos(p21);						break;										case 6: 						orientation[x][y][z][0] = Math.cos(t21)*Math.sin(p22);						orientation[x][y][z][1] = Math.sin(t21)*Math.sin(p22);						orientation[x][y][z][2] = Math.cos(p22);						break;										case 7: 						orientation[x][y][z][0] = Math.cos(t22)*Math.sin(p22);						orientation[x][y][z][1] = Math.sin(t22)*Math.sin(p22);						orientation[x][y][z][2] = Math.cos(p22);						break;					}															max = Math.sqrt(pGx*pGx + pGy*pGy + pGz*pGz);					response.putPixel(x,y,z,max);										}			}		}				FilterResponse output = new FilterResponse(response, orientation);				if (logWindow != null)			walk.finish("3D steerable (step) filtering done.");				return output;	}				/*	 * 	 */	private static boolean approxEqual(double a, double b, double precision) {		if (Math.abs(a-b)/Math.abs(a) < precision) {			return true;		} else {			return false;		}					}		/*	private ImageVolume neighbor3D(FilterResponse fresponse) {				ImageVolume response = fresponse.getResponse();		double[][][][] orientation = fresponse.getOrientation();		double[] values = new double[27];		int index;		double max, current;		int nx = response.getSizeX();		int ny = response.getSizeY();		int nz = response.getSizeZ();		double[] n = new double[3];		double[] v = new double[3];		double[] proj = new double[3];		double p;		ImageVolume result = new ImageVolume(nx, ny, nz);		int counter;		double value;				// border conditions missing		for (int x=1;x<nx-1;x++) {			for (int y=1;y<ny-1;y++) {				for (int z=1;z<nz-1;z++) {					n[0] = orientation[x][y][z][0];					n[1] = orientation[x][y][z][1];					n[2] = orientation[x][y][z][2];					n = roundVector(n); // we only want values on the grid					counter = 0;					if (n[0]==0.0 && n[1]==0.0 && n[2]==0.0) { // no orientation -> 0						result.putPixel(x,y,z,0.0);					} else {						index = 0;						for (int xi=-1;xi<2;xi++) {							for (int yi=-1;yi<2;yi++) {								for (int zi=-1;zi<2;zi++) {									v[0] = xi;									v[1] = yi;									v[2] = zi;									p = dotProduct(n, v);									if (Math.abs(p) < 0.0000000001) { // vectors are orthogonal										v = roundVector(v);										value = response.getPixel(x+(int)v[0], y+(int)v[1], z+(int)v[2]);										if (Math.abs(value) > 0.0000000001) {											counter++;										}									}																												}							}						}					}						if (counter > 2) {						result.putPixel(x,y,z,0.0);					} else {						result.putPixel(x,y,z,response.getPixel(x,y,z));					}					}			}		}						return result;	}	*/							public static ImageVolume surfaceNMS(FilterResponse fresponse) {				boolean largeNMS = false;		System.out.println("largeNMS = " + largeNMS);			ImageVolume response = fresponse.getResponse();		double[][][][] orientation = fresponse.getOrientation();		int nx = response.getSizeX();		int ny = response.getSizeY();		int nz = response.getSizeZ();		ImageVolume nms = new ImageVolume(nx, ny, nz);		double[] n = new double[3];		double A1, A2, current;				double A3, A4, A5, A6;		// border conditions missing		for (int x=1;x<nx-1;x++) {			for (int y=1;y<ny-1;y++) {				for (int z=1;z<nz-1;z++) {					n[0] = orientation[x][y][z][0];					n[1] = orientation[x][y][z][1];					n[2] = orientation[x][y][z][2];										if ((n[0] == 0.0) && (n[1] == 0.0) && (n[2] == 0.0)) {						nms.putPixel(x,y,z,0.0);					} else {											A1 = response.getInterpolatedPixel(x+n[0], y+n[1], z+n[2]);						A2 = response.getInterpolatedPixel(x-n[0], y-n[1], z-n[2]);						current = response.getPixel(x,y,z);												if (!largeNMS){							if ( (current > A1) && (current > A2) ) {								nms.putPixel(x,y,z,current);							} else {								nms.putPixel(x,y,z,0.0);							}						}						else{							A3 = response.getInterpolatedPixel(x+2*n[0], y+2*n[1], z+2*n[2]);							A4 = response.getInterpolatedPixel(x-2*n[0], y-2*n[1], z-2*n[2]);														A5 = response.getInterpolatedPixel(x+3*n[0], y+3*n[1], z+3*n[2]);							A6 = response.getInterpolatedPixel(x-3*n[0], y-3*n[1], z-3*n[2]);														if ( (current > A1) && (current > A2) && (current > A3) && (current > A4) && (current > A5) && (current > A6))								nms.putPixel(x,y,z,current);							else 							nms.putPixel(x,y,z,0.0);						}																							}					}			}		}		return nms;		}					private FilterResponse curveNMS(FilterResponse fresponse) {				ImageVolume response = fresponse.getResponse();		double[][][][] orientation = fresponse.getOrientation();		double[] values = new double[27];		int index;		double max, current;		int nx = response.getSizeX();		int ny = response.getSizeY();		int nz = response.getSizeZ();		double[] n = new double[3];		double[] v = new double[3];		double[] proj = new double[3];		double p;		ImageVolume nms = new ImageVolume(nx, ny, nz);				// border conditions missing		for (int x=1;x<nx-1;x++) {			for (int y=1;y<ny-1;y++) {				for (int z=1;z<nz-1;z++) {					n[0] = orientation[x][y][z][0];					n[1] = orientation[x][y][z][1];					n[2] = orientation[x][y][z][2];										/*n[0] = approxZero(n[0], precision);					n[1] = approxZero(n[1], precision);					n[2] = approxZero(n[2], precision);*/															if (n[0]==0.0 && n[1]==0.0 && n[2]==0.0) { // no orientation -> 0						nms.putPixel(x,y,z,0.0);					} else {						index = 0;						for (int xi=-1;xi<2;xi++) {							for (int yi=-1;yi<2;yi++) {								for (int zi=-1;zi<2;zi++) {									v[0] = xi;									v[1] = yi;									v[2] = zi;									p = dotProduct(n, v); 									if (p < 0) { // normalize here!!										n[0] = -n[0];										n[1] = -n[1];										n[2] = -n[2];										p = -p;									}																		if (p != 1) { // ok for projection										proj[0] = v[0] - p*n[0];										proj[1] = v[1] - p*n[1];										proj[2] = v[2] - p*n[2];										proj = normalize(proj);										values[index] = response.getInterpolatedPixel(x+proj[0], y+proj[1], z+proj[2]);																			} else { //p=1, no projection needed, no angle w/ n										values[index] = 0.0;									}									index++;								}							}						}												/*if (x == 31 && y == 32 && z==32) {							IJ.write("n[0]: "+n[0]);							IJ.write("n[1]: "+n[1]);							IJ.write("n[2]: "+n[2]);						}*/						/*if (x == 32 && y == 32 && z==32) {							IJ.write("n[0]: "+n[0]);							IJ.write("n[1]: "+n[1]);							IJ.write("n[2]: "+n[2]);							IJ.write("current: "+response.getPixel(x,y,z));							for (int i=0;i<27;i++) {								IJ.write(""+i+" "+values[i]);							}							}*/												max = values[0];						for (int i=1;i<13;i++) {										if (values[i] > max) {								max = values[i];							}						}						for (int i=14;i<27;i++) {										if (values[i] > max) {								max = values[i];							}						}												current = response.getPixel(x,y,z);						if (current > max) {							nms.putPixel(x,y,z,current);						} else {							nms.putPixel(x,y,z,0.0);						}		 								}				}			}		}				FilterResponse result = new FilterResponse(nms, orientation);		return result;			}				private static double approxZero(double n, double precision) {		if (Math.abs(n) < precision) {			return 0.0;		} else {			return n;		}		}		private static double[] normalize(double[] v) {		double n = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);		if (n != 0.0) {			v[0] /= n;			v[1] /= n;			v[2] /= n;		}		return v;	}		private static double[] roundVector(double[] v) {		v[0] = Math.round(v[0]);		v[1] = Math.round(v[1]);		v[2] = Math.round(v[2]);		return v;	}		private static double norm(double[] v) {		return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);	}		private static double dotProduct(double[] v1, double[] v2) {		return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];	}			/*private double[] normalize(double[] vector) {		double n = 0.0;		int i;		int l = vector.length;		for (i=0;i<l;i++) {			n += vector[i]*vector[i];		}		n = Math.sqrt(n);		for (i=0;i<l;i++) {			vector[i] /= n;		}		return vector;	}*/		private static int mod3(int n) {		if (n>2) {			return n-3;		} else {			return n;		}	}		public static double[] cubic(double a, double b, double c) {		double theta, A, B;		double q = a*a - 3.0*b;		double Q = q/9.0;		double R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;		double roots[] = new double[3];		double signR, delta;				if (c == 0.0) {			roots[0] = 0.0;			delta = a*a - 4.0*b;			if (delta >= 0.0) {				roots[1] = (-a + Math.sqrt(delta))/2.0;				roots[2] = (-a - Math.sqrt(delta))/2.0;			} else {				roots[1] = roots[2] = 0.0;			}				} else {			if (R >= 0.0) {				signR = 1.0;			} else {				signR = -1.0;			}					if (R*R < Q*Q*Q) {				theta = Math.acos(R/Math.sqrt(Q*Q*Q));				roots[0] = -2.0*Math.sqrt(Q)*Math.cos(theta/3.0) - (a/3.0);				roots[1] = -2.0*Math.sqrt(Q)*Math.cos((theta+2.0*Math.PI)/3.0) - (a/3.0);				roots[2] = -2.0*Math.sqrt(Q)*Math.cos((theta-2.0*Math.PI)/3.0) - (a/3.0);			}	else {				A = - signR*Math.pow(Math.abs(R) + Math.sqrt(R*R-Q*Q*Q), 1.0/3.0);				if (A == 0.0) {					B = 0.0;				} else {					B = Q/A;				}				roots[0]  = A + B	- (a/3.0);				roots[1] = roots[2] = 0.0;			}		}		return roots;	}			public static void vol2em(double[][][][] volume, String filePath) {				int nx = volume.length;		int ny = volume[0].length;		int nz = volume[0][0].length;				byte[] header = new byte[12];		header[0] = (byte)nx;		header[1] = (byte)(nx >> 8);		header[2] = (byte)(nx >> 16);		header[3] = (byte)(nx >> 24);		header[4] = (byte)ny;		header[5] = (byte)(ny >> 8); 		header[6] = (byte)(ny >> 16); 		header[7] = (byte)(ny >> 24);		header[8] = (byte)nz; 		header[9] = (byte)(nz >> 8); 		header[10] = (byte)(nz >> 16); 		header[11] = (byte)(nz >> 24);				byte[] data = new byte[nx*ny*nz*3*4];		int index = 0;		for (int z=0;z<nz;z++) {			for (int y=0;y<ny;y++) {				for (int x=0;x<nx;x++) {					for(int i=0; i<3; i++) {						data[index] = (byte)Float.floatToIntBits((float)volume[x][y][z][i]);						data[index+1] = (byte)(Float.floatToIntBits((float)volume[x][y][z][i]) >> 8);						data[index+2] = (byte)(Float.floatToIntBits((float)volume[x][y][z][i]) >> 16);						data[index+3] = (byte)(Float.floatToIntBits((float)volume[x][y][z][i]) >> 24);						index += 4;					}				}			}		}					try {			FileOutputStream ostream = new FileOutputStream(filePath);			ostream.write(header);			ostream.write(data);			ostream.close();		} catch (IOException e) {			//IJ.write("IOException: " + e);		}		}			}		