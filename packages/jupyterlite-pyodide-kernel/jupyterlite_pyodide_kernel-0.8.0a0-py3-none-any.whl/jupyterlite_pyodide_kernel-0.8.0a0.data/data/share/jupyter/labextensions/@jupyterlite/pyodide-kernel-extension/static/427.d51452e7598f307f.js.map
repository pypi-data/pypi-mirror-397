{"version":3,"file":"427.d51452e7598f307f.js?v=d51452e7598f307f","sources":["webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/proxy-target/esm/types.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/channel.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/bridge.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/index.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/proxy-target/esm/traps.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/comlink/dist/esm/comlink.mjs"],"sourcesContent":["export const ARRAY     = 'array';\nexport const BIGINT    = 'bigint';\nexport const BOOLEAN   = 'boolean';\nexport const FUNCTION  = 'function';\nexport const NULL      = 'null';\nexport const NUMBER    = 'number';\nexport const OBJECT    = 'object';\nexport const STRING    = 'string';\nexport const SYMBOL    = 'symbol';\nexport const UNDEFINED = 'undefined';\n","// âš ï¸ AUTOMATICALLY GENERATED - DO NOT CHANGE\nexport const CHANNEL = '64e10b34-2bf7-4616-9668-f99de5aa046e';\n\nexport const MAIN = 'M' + CHANNEL;\nexport const THREAD = 'T' + CHANNEL;\n","// The goal of this file is to normalize SAB\n// at least in main -> worker() use cases.\n// This still cannot possibly solve the sync\n// worker -> main() use case if SharedArrayBuffer\n// is not available or usable.\n\nimport {CHANNEL} from './channel.js';\n\nconst {isArray} = Array;\n\nlet {SharedArrayBuffer, window} = globalThis;\nlet {notify, wait, waitAsync} = Atomics;\nlet postPatched = null;\n\n// This is needed for some version of Firefox\nif (!waitAsync) {\n  waitAsync = buffer => ({\n    value: new Promise(onmessage => {\n      // encodeURIComponent('onmessage=({data:b})=>(Atomics.wait(b,0),postMessage(0))')\n      let w = new Worker('data:application/javascript,onmessage%3D(%7Bdata%3Ab%7D)%3D%3E(Atomics.wait(b%2C0)%2CpostMessage(0))');\n      w.onmessage = onmessage;\n      w.postMessage(buffer);\n    })\n  });\n}\n\n// Monkey-patch SharedArrayBuffer if needed\ntry {\n  new SharedArrayBuffer(4);\n}\ncatch (_) {\n  SharedArrayBuffer = ArrayBuffer;\n\n  const ids = new WeakMap;\n  // patch only main -> worker():async use case\n  if (window) {\n    const resolvers = new Map;\n    const {prototype: {postMessage}} = Worker;\n\n    const listener = event => {\n      const details = event.data?.[CHANNEL];\n      if (!isArray(details)) {\n        event.stopImmediatePropagation();\n        const { id, sb } = details;\n        resolvers.get(id)(sb);\n      }\n    };\n\n    postPatched = function (data, ...rest) {\n      const details = data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n        this.addEventListener('message', listener);\n      }\n      return postMessage.call(this, data, ...rest);\n    };\n\n    waitAsync = sb => ({\n      value: new Promise(resolve => {\n        resolvers.set(ids.get(sb), resolve);\n      }).then(buff => {\n        resolvers.delete(ids.get(sb));\n        ids.delete(sb);\n        for (let i = 0; i < buff.length; i++) sb[i] = buff[i];\n        return 'ok';\n      })\n    });\n  }\n  else {\n    const as = (id, sb) => ({[CHANNEL]: { id, sb }});\n\n    notify = sb => {\n      postMessage(as(ids.get(sb), sb));\n    };\n\n    addEventListener('message', event => {\n      const details = event.data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n      }\n    });\n  }\n}\n\nexport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync};\n","/*! (c) Andrea Giammarchi - ISC */\n\nimport {FUNCTION} from 'proxy-target/types';\n\nimport {CHANNEL} from './channel.js';\nimport {GET, HAS, SET} from './shared/traps.js';\n\nimport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync} from './bridge.js';\n\n// just minifier friendly for Blob Workers' cases\nconst {Int32Array, Map, Uint16Array} = globalThis;\n\n// common constants / utilities for repeated operations\nconst {BYTES_PER_ELEMENT: I32_BYTES} = Int32Array;\nconst {BYTES_PER_ELEMENT: UI16_BYTES} = Uint16Array;\n\nconst waitInterrupt = (sb, delay, handler) => {\n  while (wait(sb, 0, 0, delay) === 'timed-out')\n    handler();\n};\n\n// retain buffers to transfer\nconst buffers = new WeakSet;\n\n// retain either main threads or workers global context\nconst context = new WeakMap;\n\nconst syncResult = {value: {then: fn => fn()}};\n\n// used to generate a unique `id` per each worker `postMessage` \"transaction\"\nlet uid = 0;\n\n/**\n * @typedef {Object} Interrupt used to sanity-check interrupts while waiting synchronously.\n * @prop {function} [handler] a callback invoked every `delay` milliseconds.\n * @prop {number} [delay=42] define `handler` invokes in terms of milliseconds.\n */\n\n/**\n * Create once a `Proxy` able to orchestrate synchronous `postMessage` out of the box.\n * @param {globalThis | Worker} self the context in which code should run\n * @param {{parse: (serialized: string) => any, stringify: (serializable: any) => string, transform?: (value:any) => any, interrupt?: () => void | Interrupt}} [JSON] an optional `JSON` like interface to `parse` or `stringify` content with extra `transform` ability.\n * @returns {ProxyHandler<globalThis> | ProxyHandler<Worker>}\n */\nconst coincident = (self, {parse = JSON.parse, stringify = JSON.stringify, transform, interrupt} = JSON) => {\n  // create a Proxy once for the given context (globalThis or Worker instance)\n  if (!context.has(self)) {\n    // ensure no SAB gets a chance to pass through this call\n    const sendMessage = postPatched || self.postMessage;\n    // ensure the CHANNEL and data are posted correctly\n    const post = (transfer, ...args) => sendMessage.call(self, {[CHANNEL]: args}, {transfer});\n\n    const handler = typeof interrupt === FUNCTION ? interrupt : interrupt?.handler;\n    const delay = interrupt?.delay || 42;\n    const decoder = new TextDecoder('utf-16');\n\n    // automatically uses sync wait (worker -> main)\n    // or fallback to async wait (main -> worker)\n    const waitFor = (isAsync, sb) => isAsync ?\n      waitAsync(sb, 0) :\n      ((handler ? waitInterrupt(sb, delay, handler) : wait(sb, 0)), syncResult);\n\n    // prevent Harakiri https://github.com/WebReflection/coincident/issues/18\n    let seppuku = false;\n\n    context.set(self, new Proxy(new Map, {\n      // there is very little point in checking prop in proxy for this very specific case\n      // and I don't want to orchestrate a whole roundtrip neither, as stuff would fail\n      // regardless if from Worker we access non existent Main callback, and vice-versa.\n      // This is here mostly to guarantee that if such check is performed, at least the\n      // get trap goes through and then it's up to developers guarantee they are accessing\n      // stuff that actually exists elsewhere.\n      [HAS]: (_, action) => typeof action === 'string' && !action.startsWith('_'),\n\n      // worker related: get any utility that should be available on the main thread\n      [GET]: (_, action) => action === 'then' ? null : ((...args) => {\n        // transaction id\n        const id = uid++;\n\n        // first contact: just ask for how big the buffer should be\n        // the value would be stored at index [1] while [0] is just control\n        let sb = new Int32Array(new SharedArrayBuffer(I32_BYTES * 2));\n\n        // if a transfer list has been passed, drop it from args\n        let transfer = [];\n        if (buffers.has(args.at(-1) || transfer))\n          buffers.delete(transfer = args.pop());\n\n        // ask for invoke with arguments and wait for it\n        post(transfer, id, sb, action, transform ? args.map(transform) : args);\n\n        // helps deciding how to wait for results\n        const isAsync = self !== globalThis;\n\n        // warn users about possible deadlock still allowing them\n        // to explicitly `proxy.invoke().then(...)` without blocking\n        let deadlock = 0;\n        if (seppuku && isAsync)\n          deadlock = setTimeout(console.warn, 1000, `ðŸ’€ðŸ”’ - Possible deadlock if proxy.${action}(...args) is awaited`);\n\n        return waitFor(isAsync, sb).value.then(() => {\n          clearTimeout(deadlock);\n\n          // commit transaction using the returned / needed buffer length\n          const length = sb[1];\n\n          // filter undefined results\n          if (!length) return;\n\n          // calculate the needed ui16 bytes length to store the result string\n          const bytes = UI16_BYTES * length;\n\n          // round up to the next amount of bytes divided by 4 to allow i32 operations\n          sb = new Int32Array(new SharedArrayBuffer(bytes + (bytes % I32_BYTES)));\n\n          // ask for results and wait for it\n          post([], id, sb);\n          return waitFor(isAsync, sb).value.then(() => parse(\n            decoder.decode(new Uint16Array(sb.buffer).slice(0, length)))\n          );\n        });\n      }),\n\n      // main thread related: react to any utility a worker is asking for\n      [SET](actions, action, callback) {\n        const type = typeof callback;\n        if (type !== FUNCTION)\n          throw new Error(`Unable to assign ${action} as ${type}`);\n        // lazy event listener and logic handling, triggered once by setters actions\n        if (!actions.size) {\n          // maps results by `id` as they are asked for\n          const results = new Map;\n          // add the event listener once (first defined setter, all others work the same)\n          self.addEventListener('message', async (event) => {\n            // grub the very same library CHANNEL; ignore otherwise\n            const details = event.data?.[CHANNEL];\n            if (isArray(details)) {\n              // if early enough, avoid leaking data to other listeners\n              event.stopImmediatePropagation();\n              const [id, sb, ...rest] = details;\n              let error;\n              // action available: it must be defined/known on the main thread\n              if (rest.length) {\n                const [action, args] = rest;\n                if (actions.has(action)) {\n                  seppuku = true;\n                  try {\n                    // await for result either sync or async and serialize it\n                    const result = await actions.get(action)(...args);\n                    if (result !== void 0) {\n                      const serialized = stringify(transform ? transform(result) : result);\n                      // store the result for \"the very next\" event listener call\n                      results.set(id, serialized);\n                      // communicate the required SharedArrayBuffer length out of the\n                      // resulting serialized string\n                      sb[1] = serialized.length;\n                    }\n                  }\n                  catch (_) {\n                    error = _;\n                  }\n                  finally {\n                    seppuku = false;\n                  }\n                }\n                // unknown action should be notified as missing on the main thread\n                else {\n                  error = new Error(`Unsupported action: ${action}`);\n                }\n                // unlock the wait lock later on\n                sb[0] = 1;\n              }\n              // no action means: get results out of the well known `id`\n              // wait lock automatically unlocked here as no `0` value would\n              // possibly ever land at index `0`\n              else {\n                const result = results.get(id);\n                results.delete(id);\n                // populate the SharedArrayBuffer with utf-16 chars code\n                for (let ui16a = new Uint16Array(sb.buffer), i = 0; i < result.length; i++)\n                  ui16a[i] = result.charCodeAt(i);\n              }\n              // release te worker waiting either the length or the result\n              notify(sb, 0);\n              if (error) throw error;\n            }\n          });\n        }\n        // store this action callback allowing the setter in the process\n        return !!actions.set(action, callback);\n      }\n    }));\n  }\n  return context.get(self);\n};\n\ncoincident.transfer = (...args) => (buffers.add(args), args);\n\nexport default coincident;\n","export const APPLY                        = 'apply';\nexport const CONSTRUCT                    = 'construct';\nexport const DEFINE_PROPERTY              = 'defineProperty';\nexport const DELETE_PROPERTY              = 'deleteProperty';\nexport const GET                          = 'get';\nexport const GET_OWN_PROPERTY_DESCRIPTOR  = 'getOwnPropertyDescriptor';\nexport const GET_PROTOTYPE_OF             = 'getPrototypeOf';\nexport const HAS                          = 'has';\nexport const IS_EXTENSIBLE                = 'isExtensible';\nexport const OWN_KEYS                     = 'ownKeys';\nexport const PREVENT_EXTENSION            = 'preventExtensions';\nexport const SET                          = 'set';\nexport const SET_PROTOTYPE_OF             = 'setPrototypeOf';\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n"],"names":["Array","globalThis","Atomics","p","Promise","Worker","ArrayBuffer","WeakMap","Map","e","postMessage","addEventListener","WeakSet","JSON","t","TextDecoder","Proxy","a","s","setTimeout","console","clearTimeout","Error","r","Symbol","MessageChannel","RegExp","Object","c","TypeError","FinalizationRegistry","Math","Number"],"mappings":"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"}