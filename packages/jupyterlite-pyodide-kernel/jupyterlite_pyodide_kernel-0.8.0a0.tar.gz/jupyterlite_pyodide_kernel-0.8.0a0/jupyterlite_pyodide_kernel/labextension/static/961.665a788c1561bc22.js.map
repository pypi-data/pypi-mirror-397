{"version":3,"file":"961.665a788c1561bc22.js?v=665a788c1561bc22","sources":["webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/licenses.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/pluginmanager.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/translation.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/statedb.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/tokens.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/workspaces.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/workspace-router.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/service-worker-manager.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/service-worker.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Licenses } from '@jupyterlab/apputils';\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class LiteLicensesClient extends Licenses.LicensesClient {\n    /**\n     * A GET handler for the licenses\n     */\n    async getBundles() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Download the licenses in the requested format.\n     */\n    async download(options) {\n        const link = document.createElement('a');\n        link.href = await this._getDownloadLink(options);\n        const extension = options.format === 'markdown' ? 'md' : options.format;\n        link.download = `jupyterlite-licenses.${extension}`;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Get the download link for the requested format\n     */\n    async _getDownloadLink(options) {\n        const bundles = await this.getBundles();\n        let formattedData;\n        let mime;\n        // Format the data based on the requested format\n        switch (options.format) {\n            case 'json':\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n                break;\n            case 'markdown':\n                formattedData = this._formatAsMarkdown(bundles);\n                mime = 'text/markdown';\n                break;\n            case 'csv':\n                formattedData = this._formatAsCSV(bundles);\n                mime = 'text/csv';\n                break;\n            default:\n                // Fallback to JSON\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n        }\n        // Create a blob with the appropriate MIME type\n        const blob = new Blob([formattedData], { type: mime });\n        // Generate a URL for the blob\n        return URL.createObjectURL(blob);\n    }\n    /**\n     * Format license data as Markdown\n     */\n    _formatAsMarkdown(data) {\n        let md = '# Third-Party Licenses\\n\\n';\n        // Process each bundle\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            md += `## ${bundleName}\\n\\n`;\n            // Process packages in the bundle\n            for (const pkg of bundle.packages) {\n                md += `### ${pkg.name}${pkg.versionInfo ? ` ${pkg.versionInfo}` : ''}\\n\\n`;\n                if (pkg.licenseId) {\n                    md += `**License ID:** ${pkg.licenseId}\\n\\n`;\n                }\n                if (pkg.extractedText) {\n                    md += `\\`\\`\\`\\n${pkg.extractedText}\\n\\`\\`\\`\\n\\n`;\n                }\n            }\n        }\n        return md;\n    }\n    /**\n     * Format license data as CSV\n     */\n    _formatAsCSV(data) {\n        // CSV header\n        const headers = ['Bundle', 'Package', 'Version', 'License ID', 'License Text'];\n        let csv = `${headers.join(',')}\\n`;\n        // Process each bundle and package\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            for (const pkg of bundle.packages) {\n                const row = [\n                    this._escapeCSVField(bundleName),\n                    this._escapeCSVField(pkg.name),\n                    this._escapeCSVField(pkg.versionInfo || ''),\n                    this._escapeCSVField(pkg.licenseId || ''),\n                    this._escapeCSVField(pkg.extractedText || ''),\n                ];\n                csv += `${row.join(',')}\\n`;\n            }\n        }\n        return csv;\n    }\n    /**\n     * Escape a field for CSV output\n     */\n    _escapeCSVField(field) {\n        // If the field contains commas, quotes, or newlines, wrap it in quotes and escape any quotes\n        if (field && (field.includes(',') || field.includes('\"') || field.includes('\\n'))) {\n            return `\"${field.replace(/\"/g, '\"\"')}\"`;\n        }\n        return field;\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PluginListModel } from '@jupyterlab/pluginmanager';\n/**\n * Custom PluginModel for use in JupyterLite\n */\nexport class LitePluginListModel extends PluginListModel {\n    /**\n     * Create a new PluginListModel.\n     */\n    constructor(options) {\n        super(options);\n        this._availablePlugins = options.pluginData.availablePlugins.map((plugin) => {\n            let tokenLabel = plugin.provides ? plugin.provides.name.split(':')[1] : undefined;\n            if (plugin.provides && !tokenLabel) {\n                tokenLabel = plugin.provides.name;\n            }\n            return {\n                ...plugin,\n                tokenLabel,\n                // keep all plugins locked and enabled for now until there is\n                // a way to enable/disable plugins in JupyterLite\n                locked: true,\n                enabled: true,\n            };\n        });\n    }\n    get available() {\n        return this._availablePlugins;\n    }\n    async refresh() {\n        // no-op\n    }\n    async enable(entry) {\n        // no-op\n    }\n    async disable(entry) {\n        // no-op\n    }\n}\n//# sourceMappingURL=pluginmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A fake locale to retrieve all the language packs.\n */\nconst ALL = 'all';\n/**\n * A class to fetch translation bundles.\n */\nexport class LiteTranslatorConnector extends DataConnector {\n    constructor() {\n        super(...arguments);\n        this._prevLocale = '';\n    }\n    async fetch(opts) {\n        var _a;\n        const language = (_a = opts === null || opts === void 0 ? void 0 : opts.language) !== null && _a !== void 0 ? _a : '';\n        // normalize the requested locale\n        let locale = language;\n        if (language === 'default') {\n            locale = 'en';\n        }\n        else if (language === '') {\n            locale = ALL;\n        }\n        const apiURL = URLExt.join(PageConfig.getBaseUrl(), `api/translations/${locale}.json`);\n        try {\n            const response = await fetch(apiURL);\n            const json = JSON.parse(await response.text());\n            if (this._prevLocale !== ALL && locale === ALL) {\n                // TODO: fix this logic upstream?\n                // the upstream translation plugin relies on the comparison between\n                // the display name and the native name to enable or disable the commands:\n                // https://github.com/jupyterlab/jupyterlab/blob/befa831ffef36321b87f352a48fbe2439df6c872/packages/translation-extension/src/index.ts#L117\n                const prev = this._prevLocale;\n                json.data[prev].displayName = json.data[prev].nativeName;\n                if (prev !== 'en') {\n                    json.data['en'].displayName = `${json.data['en'].nativeName} (default)`;\n                }\n            }\n            this._prevLocale = locale;\n            return json;\n        }\n        catch (e) {\n            if (locale) {\n                return {\n                    data: {},\n                    message: `Language pack '${locale}' not installed!`,\n                };\n            }\n            return {\n                data: {\n                    en: { displayName: 'English', nativeName: 'English' },\n                },\n                message: '',\n            };\n        }\n    }\n}\n//# sourceMappingURL=translation.js.map","import { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A StateDB data connector backed by IndexedDB\n */\nexport class IndexedDBDataConnector {\n    /**\n     * Construct a new IndexedDBDataConnector.\n     *\n     * @param options - The options for the data connector.\n     */\n    constructor(options) {\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n        this.initialize().catch(console.warn);\n    }\n    /**\n     * Initialize the data connector.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this._ready.promise.then(() => this._storage);\n    }\n    /**\n     * Initialize storage instance\n     */\n    async initStorage() {\n        this._storage = this.createStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for StateDB',\n            storeName: 'statedb',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Fetch a value from the data connector.\n     *\n     * @param id - The identifier of the value to fetch.\n     *\n     * @returns A promise that resolves with the fetched value, or undefined if not found.\n     */\n    async fetch(id) {\n        const result = (await (await this.storage).getItem(id));\n        return result !== null && result !== void 0 ? result : undefined;\n    }\n    /**\n     * List all values in a namespace.\n     *\n     * @param namespace - The namespace to list values from. Defaults to ''.\n     *\n     * @returns A promise that resolves with the list of IDs and values.\n     */\n    async list(namespace = '') {\n        const storage = await this.storage;\n        const items = {};\n        for (const key of await storage.keys()) {\n            // Casting to string here, we know for sure the item is there\n            items[key] = (await storage.getItem(key));\n        }\n        const result = Object.keys(items).reduce((acc, val) => {\n            if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                acc.ids.push(val);\n                acc.values.push(items[val]);\n            }\n            return acc;\n        }, { ids: [], values: [] });\n        return result;\n    }\n    /**\n     * Remove a value from the data connector.\n     *\n     * @param id - The identifier of the value to remove.\n     *\n     * @returns A promise that resolves when the value is removed.\n     */\n    async remove(id) {\n        await (await this.storage).removeItem(id);\n    }\n    /**\n     * Save a value to the data connector.\n     *\n     * @param id - The identifier of the value to save.\n     * @param value - The value to save.\n     *\n     * @returns A promise that resolves when the value is saved.\n     */\n    async save(id, value) {\n        await (await this.storage).setItem(id, value);\n    }\n}\n//# sourceMappingURL=statedb.js.map","import { Token } from '@lumino/coreutils';\nimport SW_URL from './service-worker?text';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token('@jupyterlite/apputils:IServiceWorkerManager', 'The service worker manager');\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n//# sourceMappingURL=tokens.js.map","import { ServerConnection } from '@jupyterlab/services';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IndexedDBDataConnector } from './statedb';\n/**\n * A workspace manager for workspaces stored in the browser and on the server.\n */\nexport class LiteWorkspaceManager extends IndexedDBDataConnector {\n    /**\n     * Construct a new LiteWorkspaceManager.\n     *\n     * @param options - The options for the workspace manager.\n     */\n    constructor(options) {\n        super({ ...options });\n        this._workspacesApiUrl = PageConfig.getOption('workspacesApiUrl') ||\n            URLExt.join(PageConfig.getBaseUrl(), 'api/workspaces');\n        this.serverSettings = options.settings || ServerConnection.makeSettings();\n    }\n    /**\n     * Fetch a workspace by id.\n     *\n     * @param id - The workspace id\n     * @returns A promise that resolves with the workspace.\n     */\n    async fetch(id) {\n        // First try to get from local storage\n        const localWorkspace = await super.fetch(id);\n        if (localWorkspace) {\n            return localWorkspace;\n        }\n        // Fall back to server\n        try {\n            const serverWorkspaces = await this._getServerWorkspaces();\n            if (serverWorkspaces[id]) {\n                return serverWorkspaces[id];\n            }\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspace from server:', error);\n        }\n        // If neither local nor server has the workspace, return an empty workspace\n        return {\n            data: {},\n            metadata: { id },\n        };\n    }\n    /**\n     * List all workspaces.\n     *\n     * @returns A promise that resolves with all workspace ids\n     */\n    async list() {\n        var _a;\n        let serverWorkspaces = {};\n        // Try to get server workspaces\n        try {\n            serverWorkspaces = await this._getServerWorkspaces();\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspaces from server:', error);\n        }\n        // Get local workspaces\n        const localResult = await super.list();\n        // Merge server and local workspaces, with local taking precedence for same IDs\n        const allWorkspaces = { ...serverWorkspaces };\n        for (const localWorkspace of localResult.values) {\n            if ((_a = localWorkspace.metadata) === null || _a === void 0 ? void 0 : _a.id) {\n                allWorkspaces[localWorkspace.metadata.id] = localWorkspace;\n            }\n        }\n        const ids = Object.keys(allWorkspaces);\n        const values = Object.values(allWorkspaces);\n        return { ids, values };\n    }\n    /**\n     * Clear all workspace data\n     *\n     * @returns A promise which resolves when the workspace data is cleared\n     */\n    async clear() {\n        await (await this.storage).clear();\n    }\n    /**\n     * Fetch all workspaces from the server\n     *\n     * @returns A promise that resolves with server workspaces\n     */\n    async _getServerWorkspaces() {\n        const workspacesUrl = URLExt.join(this._workspacesApiUrl, 'all.json');\n        const response = await fetch(workspacesUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch workspaces: ${response.status} ${response.statusText}`);\n        }\n        return await response.json();\n    }\n}\n//# sourceMappingURL=workspaces.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * A token to advertise the workspace router is installed\n */\nexport const IWorkspaceRouter = new Token('@jupyterlite/apputils:IWorkspaceRouter');\n//# sourceMappingURL=workspace-router.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DriveContentsProcessor } from '@jupyterlite/services';\nimport { PromiseDelegate, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { WORKER_NAME } from './tokens';\n/**\n * The service-worker broadcast channel id\n */\nexport const SERVICE_WORKER_BROADCAST_CHANNEL_ID = '/sw-api.v1';\n/**\n * The version of the app\n */\nconst VERSION = PageConfig.getOption('appVersion');\n/**\n * Used to keep the service worker alive\n */\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\n/**\n * A class that manages the ServiceWorker registration and communication,\n * used for accessing the file system.\n */\nexport class ServiceWorkerManager {\n    /**\n     * Construct a new ServiceWorkerManager.\n     */\n    constructor(options) {\n        var _a;\n        /**\n         * Handle a message received on the BroadcastChannel\n         *\n         * Message data is `any` because it can either be a drive message of type `TDriveReqiest<T>`\n         * or a stdin message of type `any` as ServiceWorkerManager passes it through to the\n         * stdinHandler without understanding or altering it.\n         */\n        this._onBroadcastMessage = async (event) => {\n            const { data, browsingContextId, requestId, pathname } = event.data;\n            if (browsingContextId !== this._browsingContextId) {\n                // Message is not meant for us\n                return;\n            }\n            if (pathname.includes('/api/stdin/')) {\n                this._onStdinMessage(pathname, data);\n            }\n            else {\n                this._onDriveMessage(data, requestId);\n            }\n        };\n        this._onDriveMessage = async (data, requestId) => {\n            const response = await this._driveContentsProcessor.processDriveRequest(data);\n            // pass the browsingContextId and requestId along so the Service Worker can identify the request\n            this._broadcastChannel.postMessage({\n                response,\n                browsingContextId: this._browsingContextId,\n                requestId,\n            });\n        };\n        this._onStdinMessage = async (pathname, data) => {\n            // Expecting pathname of the form '<optional something>/api/stdin/<suffix>' from which\n            // suffix is used to identify which stdinHandler to call.\n            // `data: any` because ServiceWorkerManager accepts any data and passes it through\n            // to the stdinHandler without understanding or altering it.\n            const suffix = pathname.slice(pathname.lastIndexOf('/') + 1);\n            const stdinHandler = this._stdinHandlers.get(suffix);\n            if (stdinHandler !== undefined) {\n                const response = await stdinHandler(data);\n                this._broadcastChannel.postMessage({\n                    response,\n                    browsingContextId: this._browsingContextId,\n                });\n            }\n            else {\n                console.warn(`No stdin handler registered for '${pathname}'`);\n            }\n        };\n        this._registration = null;\n        this._registrationChanged = new Signal(this);\n        this._ready = new PromiseDelegate();\n        this._stdinHandlers = new Map();\n        const workerUrl = (_a = options.workerUrl) !== null && _a !== void 0 ? _a : URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        // Initialize broadcast channel related properties\n        this._browsingContextId = UUID.uuid4();\n        this._contents = options.contents;\n        this._broadcastChannel = new BroadcastChannel(SERVICE_WORKER_BROADCAST_CHANNEL_ID);\n        this._broadcastChannel.addEventListener('message', this._onBroadcastMessage);\n        this._driveContentsProcessor = new DriveContentsProcessor({\n            contentsManager: this._contents,\n        });\n        void this._initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    /**\n     * A unique id to identify the browsing context where the ServiceWorkerManager was instantiated.\n     */\n    get browsingContextId() {\n        return this._browsingContextId;\n    }\n    /**\n     * Whether the ServiceWorker is ready or not.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Register a handler for stdin requests received via ServiceWorker.\n     * @param pathnameSuffix URL pathname suffix to match such as \"kernel\" or \"terminal\".\n     * @param stdinHandler\n     */\n    registerStdinHandler(pathnameSuffix, stdinHandler) {\n        this._stdinHandlers.set(pathnameSuffix, stdinHandler);\n    }\n    /**\n     * Initialize the ServiceWorkerManager.\n     */\n    async _initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n            return;\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this._unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Unregister old service workers if the version has changed.\n     */\n    async _unregisterOldServiceWorkers(scriptURL) {\n        const versionKey = `${scriptURL}-version`;\n        // Check if we have an installed version. If we do, compare it to the current version\n        // and unregister all service workers if they are different.\n        const installedVersion = localStorage.getItem(versionKey);\n        if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {\n            // eslint-disable-next-line no-console\n            console.info('New version, unregistering existing service workers.');\n            const registrations = await navigator.serviceWorker.getRegistrations();\n            await Promise.all(registrations.map((registration) => registration.unregister()));\n            // eslint-disable-next-line no-console\n            console.info('All existing service workers have been unregistered.');\n        }\n        localStorage.setItem(versionKey, VERSION);\n    }\n    /**\n     * Ping the service worker to keep it alive.\n     */\n    async _pingServiceWorker() {\n        const response = await fetch(SW_PING_ENDPOINT);\n        const text = await response.text();\n        if (text === 'ok') {\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Set the registration and emit a signal.\n     */\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n}\n//# sourceMappingURL=service-worker-manager.js.map","\"use strict\";\n/**\n * The name of the cache\n */\nconst CACHE = 'precache';\n/**\n * Communication channel with the main thread\n */\nconst broadcast = new BroadcastChannel('/sw-api.v1');\n/**\n * Whether to enable the cache\n */\nlet enableCache = false;\n/**\n * Install event listeners\n */\nself.addEventListener('install', onInstall);\nself.addEventListener('activate', onActivate);\nself.addEventListener('fetch', onFetch);\n// Event handlers\n/**\n * Handle installation with the cache\n */\nfunction onInstall(event) {\n    void self.skipWaiting();\n    event.waitUntil(cacheAll());\n}\n/**\n * Handle activation.\n */\nfunction onActivate(event) {\n    // check if we should enable the cache\n    const searchParams = new URL(location.href).searchParams;\n    enableCache = searchParams.get('enableCache') === 'true';\n    event.waitUntil(self.clients.claim());\n}\n/**\n * Handle fetching a single resource.\n */\nasync function onFetch(event) {\n    const { request } = event;\n    const url = new URL(event.request.url);\n    if (url.pathname === '/api/service-worker-heartbeat') {\n        event.respondWith(new Response('ok'));\n        return;\n    }\n    let responsePromise = null;\n    if (shouldBroadcast(url)) {\n        responsePromise = broadcastOne(request, url);\n    }\n    else if (!shouldDrop(request, url)) {\n        responsePromise = maybeFromCache(event);\n    }\n    if (responsePromise) {\n        event.respondWith(responsePromise);\n    }\n}\n// utilities\n/** Get a cached response, and update cache. */\nasync function maybeFromCache(event) {\n    const { request } = event;\n    if (!enableCache) {\n        return await fetch(request);\n    }\n    let response = await fromCache(request);\n    if (response) {\n        event.waitUntil(refetch(request));\n    }\n    else {\n        response = await fetch(request);\n        event.waitUntil(updateCache(request, response.clone()));\n    }\n    return response;\n}\n/**\n * Restore a response from the cache based on the request.\n */\nasync function fromCache(request) {\n    const cache = await openCache();\n    const response = await cache.match(request);\n    if (!response || response.status === 404) {\n        return null;\n    }\n    return response;\n}\n/**\n * This is where we call the server to get the newest version of the\n * file to use the next time we show view\n */\nasync function refetch(request) {\n    const fromServer = await fetch(request);\n    await updateCache(request, fromServer);\n    return fromServer;\n}\n/**\n * Whether a given URL should be broadcast\n */\nfunction shouldBroadcast(url) {\n    return (url.origin === location.origin &&\n        (url.pathname.includes('/api/drive') || url.pathname.includes('/api/stdin/')));\n}\n/**\n * Whether the fallback behavior should be used\n */\nfunction shouldDrop(request, url) {\n    return (request.method !== 'GET' ||\n        url.origin.match(/^http/) === null ||\n        url.pathname.includes('/api/'));\n}\n/**\n * Forward request to main using the broadcast channel\n */\nasync function broadcastOne(request, url) {\n    const message = await request.json();\n    const promise = new Promise((resolve) => {\n        const messageHandler = (event) => {\n            const data = event.data;\n            // Match both browsingContextId AND requestId to ensure correct correlation\n            if (data.browsingContextId !== message.browsingContextId ||\n                data.requestId !== message.requestId) {\n                // bail if the message is not for us\n                return;\n            }\n            const response = data.response;\n            resolve(new Response(JSON.stringify(response)));\n            broadcast.removeEventListener('message', messageHandler);\n        };\n        broadcast.addEventListener('message', messageHandler);\n    });\n    // Add URL pathname to message\n    message.pathname = url.pathname;\n    broadcast.postMessage(message);\n    return await promise;\n}\nasync function openCache() {\n    return await caches.open(CACHE);\n}\n/**\n * Cache a request/response pair.\n */\nasync function updateCache(request, response) {\n    const cache = await openCache();\n    return cache.put(request, response);\n}\n/**\n * Add all to the cache\n *\n * this is where we should (try to) add all relevant files\n */\nasync function cacheAll() {\n    const cache = await openCache();\n    return await cache.addAll([]);\n}\n//# sourceMappingURL=service-worker.js.map"],"names":["Object","document","JSON","Blob","URL","fetch","e","console","Promise","t","arguments","Error","s","Map","window","BroadcastChannel","navigator","setTimeout","localStorage","Response","location","o","caches","c","self"],"mappings":"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"}