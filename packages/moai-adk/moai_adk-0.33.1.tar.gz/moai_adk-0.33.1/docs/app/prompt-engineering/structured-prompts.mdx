---
title: "êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸"
description: "ì²´ê³„ì ì¸ í”„ë¡¬í”„íŠ¸ ì„¤ê³„, í…œí”Œë¦¿, ë³€ìˆ˜ í™œìš© ë° ë‹¤ë‹¨ê³„ í”„ë¡¬í”„íŠ¸ ì²´ì¸ êµ¬ì„± ë°©ë²•"
---

# êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸

ì²´ê³„ì ìœ¼ë¡œ ì„¤ê³„ëœ êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸ëŠ” ì¼ê´€ì„± ìˆëŠ” ê²°ê³¼ë¬¼ì„ ë³´ì¥í•˜ê³  ì¬ì‚¬ìš©ì„±ì„ ë†’ì—¬ì¤ë‹ˆë‹¤. í…œí”Œë¦¿ ê¸°ë°˜ ì ‘ê·¼ë²•ì„ í†µí•´ íš¨ìœ¨ì ì¸ í”„ë¡¬í”„íŠ¸ ê´€ë¦¬ë¥¼ ë°°ì›Œë´…ë‹ˆë‹¤.

## ğŸ—ï¸ êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸ ì„¤ê³„ ì›ì¹™

### 1. ëª¨ë“ˆëŸ¬ ì„¤ê³„

êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸ëŠ” ë…ë¦½ì ì¸ ëª¨ë“ˆë“¤ì˜ ì¡°í•©ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.

```python
# ê¸°ë³¸ êµ¬ì¡° í…œí”Œë¦¿
class StructuredPrompt:
    def __init__(self):
        self.role = ""           # ì—­í•  ì •ì˜
        self.context = ""        # ë°°ê²½ ì •ë³´
        self.task = ""           # ì£¼ìš” ì‘ì—…
        self.constraints = ""    # ì œì•½ ì¡°ê±´
        self.format = ""         # ì¶œë ¥ í˜•ì‹
        self.examples = []       # ì˜ˆì‹œ ëª©ë¡

    def build_prompt(self):
        return f"""
# ì—­í•  ì •ì˜
{self.role}

# ë°°ê²½ ì •ë³´
{self.context}

# ì£¼ìš” ì‘ì—…
{self.task}

# ì œì•½ ì¡°ê±´
{self.constraints}

# ì¶œë ¥ í˜•ì‹
{self.format}

# ì˜ˆì‹œ
{self.format_examples()}
        """
```

### 2. ê³„ì¸µì  êµ¬ì¡°

ë³µì¡í•œ ì‘ì—…ì€ ê³„ì¸µì ìœ¼ë¡œ ë¶„í•´í•˜ì—¬ ê´€ë¦¬í•©ë‹ˆë‹¤.

```python
# ê³„ì¸µì  í”„ë¡¬í”„íŠ¸ êµ¬ì¡°
1. ìµœìƒìœ„ ëª©í‘œ (High-level Goal)
   â”œâ”€â”€ 2. ì£¼ìš” êµ¬ì„± ìš”ì†Œ (Major Components)
   â”‚   â”œâ”€â”€ 3. ì„¸ë¶€ êµ¬í˜„ (Implementation Details)
   â”‚   â””â”€â”€ 3. ìœ íš¨ì„± ê²€ì‚¬ (Validation)
   â””â”€â”€ 2. í†µí•© ë° í…ŒìŠ¤íŠ¸ (Integration & Testing)
```

## ğŸ“‹ í‘œì¤€í™”ëœ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿

### 1. ê°œë°œ ì‘ì—… í…œí”Œë¦¿

```python
# í‘œì¤€ ê°œë°œ ì‘ì—… í…œí”Œë¦¿
DEVELOPMENT_TEMPLATE = """
# ì—­í•  ì •ì˜
ë‹¹ì‹ ì€ {role}ì…ë‹ˆë‹¤.
- ê²½í—˜: {experience}
- ì „ë¬¸ ë¶„ì•¼: {expertise}
- ì‘ì—… ìŠ¤íƒ€ì¼: {work_style}

# í”„ë¡œì íŠ¸ ì •ë³´
í”„ë¡œì íŠ¸ëª…: {project_name}
ì„¤ëª…: {project_description}
ê¸°ìˆ  ìŠ¤íƒ: {tech_stack}
íŒ€ ê·œëª¨: {team_size}

# ì„¸ë¶€ ìš”êµ¬ì‚¬í•­
{requirements}

# ì œì•½ ì¡°ê±´
- ë°˜ë“œì‹œ í¬í•¨: {must_include}
- ì œì™¸í•  í•­ëª©: {must_exclude}
- ì½”ë“œ ìŠ¤íƒ€ì¼: {code_style}
- í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­: {test_requirements}

# ì˜ˆìƒ ê²°ê³¼ë¬¼
{expected_deliverables}

# êµ¬ì²´ì ì¸ ì§€ì‹œ
{specific_instructions}

# í‰ê°€ ê¸°ì¤€
{evaluation_criteria}
"""

# ì‚¬ìš© ì˜ˆì‹œ
prompt = DEVELOPMENT_TEMPLATE.format(
    role="ì‹œë‹ˆì–´ ë°±ì—”ë“œ ê°œë°œì",
    experience="8ë…„",
    expertise="FastAPI, PostgreSQL, ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤",
    work_style="TDD, ì• ìì¼ ë°©ë²•ë¡ ",
    project_name="ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ",
    project_description="JWT ê¸°ë°˜ì˜ í™•ì¥ ê°€ëŠ¥í•œ ì¸ì¦ API",
    tech_stack="Python 3.11, FastAPI, PostgreSQL, Redis",
    team_size="3ëª… (ë°±ì—”ë“œ 2, í”„ë¡ íŠ¸ì—”ë“œ 1)",
    requirements="""
    - JWT í† í° ê¸°ë°˜ ì¸ì¦/ì¸ê°€
    - ë¦¬í”„ë ˆì‹œ í† í° ë©”ì»¤ë‹ˆì¦˜
    - ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ê¸°ëŠ¥
    - ì´ë©”ì¼ ì¸ì¦
    - ì†ë„ ì œí•œ (Rate Limiting)
    """,
    must_include="ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, API ë¬¸ì„œ, ì—ëŸ¬ í•¸ë“¤ë§",
    must_exclude="í•˜ë“œì½”ë”©ëœ ê°’, ì‹¤ì œ ì„œë²„ ì •ë³´",
    code_style="PEP 8, íƒ€ì… íŒíŠ¸, docstring",
    test_requirements="pytest 85% ì´ìƒ ì»¤ë²„ë¦¬ì§€",
    expected_deliverables="API ì½”ë“œ, í…ŒìŠ¤íŠ¸ ìŠˆíŠ¸, API ë¬¸ì„œ, ë°°í¬ ìŠ¤í¬ë¦½íŠ¸",
    specific_instructions="1. ëª¨ë¸ë¶€í„° ì„¤ê³„í•˜ê³  2. API êµ¬í˜„ 3. í…ŒìŠ¤íŠ¸ ì‘ì„± ìˆœì„œë¡œ ì§„í–‰",
    evaluation_criteria="ì„±ëŠ¥, ë³´ì•ˆ, ìœ ì§€ë³´ìˆ˜ì„±, í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€"
)
```

### 2. ì½”ë“œ ë¦¬ë·° í…œí”Œë¦¿

```python
# ì½”ë“œ ë¦¬ë·° í…œí”Œë¦¿
CODE_REVIEW_TEMPLATE = """
# ì—­í• 
ë‹¹ì‹ ì€ {reviewer_role}ì…ë‹ˆë‹¤.

# ë¦¬ë·° ëŒ€ìƒ ì½”ë“œ
ì–¸ì–´: {language}
í”„ë ˆì„ì›Œí¬: {framework}
íŒŒì¼: {file_path}
ë¼ì¸ ìˆ˜: {line_count}

# ë¦¬ë·° ê¸°ì¤€
{review_criteria}

# ì½”ë“œ
{code_content}

# ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì½”ë“œ ê°€ë…ì„± ë° ëª…ëª… ê·œì¹™
- [ ] ì„±ëŠ¥ ë° íš¨ìœ¨ì„±
- [ ] ë³´ì•ˆ ì·¨ì•½ì 
- [ ] í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±
- [ ] ëª¨ë²” ì‚¬ë¡€ ì¤€ìˆ˜

# ë¶„ì„ ê²°ê³¼ ì œì¶œ
ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë¦¬ë·° ê²°ê³¼ë¥¼ ì œì¶œí•´ì£¼ì„¸ìš”:

## ì „ì²´ í‰ê°€
- ì ìˆ˜: /10
- ì£¼ìš” ì¥ì :
- ê°œì„  í•„ìš” ì‚¬í•­:

## ì„¸ë¶€ ë¶„ì„
### 1. ì½”ë“œ í’ˆì§ˆ
{code_quality_analysis}

### 2. ì„±ëŠ¥ ë¶„ì„
{performance_analysis}

### 3. ë³´ì•ˆ ê²€í† 
{security_analysis}

### 4. êµ¬ì²´ì ì¸ ê°œì„  ì œì•ˆ
{improvement_suggestions}

## ìˆ˜ì •ëœ ì½”ë“œ
{improved_code}
"""

# ì‚¬ìš© ì˜ˆì‹œ
review_prompt = CODE_REVIEW_TEMPLATE.format(
    reviewer_role="ì‹œë‹ˆì–´ Python ê°œë°œì (10ë…„ ê²½í—˜)",
    language="Python",
    framework="FastAPI",
    file_path="/src/auth/token_manager.py",
    line_count="85",
    review_criteria="""
    - PEP 8 ì¤€ìˆ˜
    - íƒ€ì… íŒíŠ¸ ì‚¬ìš©
    - ì—ëŸ¬ ì²˜ë¦¬ ì™„ì „ì„±
    - JWT ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€
    - ì„±ëŠ¥ ìµœì í™”
    """,
    code_content="# ì‹¤ì œ ì½”ë“œ ë‚´ìš©",
    code_quality_analysis="[ë¶„ì„ ê²°ê³¼]",
    performance_analysis="[ì„±ëŠ¥ ë¶„ì„]",
    security_analysis="[ë³´ì•ˆ ë¶„ì„]",
    improvement_suggestions="[ê°œì„  ì œì•ˆ]",
    improved_code="[ìˆ˜ì •ëœ ì½”ë“œ]"
)
```

## ğŸ”„ ë³€ìˆ˜ì™€ íŒŒë¼ë¯¸í„° í™œìš©

### 1. ë™ì  ë³€ìˆ˜ ì‹œìŠ¤í…œ

```python
# ë™ì  ë³€ìˆ˜ ê´€ë¦¬ í´ë˜ìŠ¤
class PromptVariables:
    def __init__(self):
        self.global_vars = {}      # ì „ì—­ ë³€ìˆ˜
        self.session_vars = {}     # ì„¸ì…˜ ë³€ìˆ˜
        self.context_vars = {}     # ì»¨í…ìŠ¤íŠ¸ ë³€ìˆ˜

    def set_variable(self, name, value, scope="session"):
        """ë³€ìˆ˜ ì„¤ì •"""
        if scope == "global":
            self.global_vars[name] = value
        elif scope == "session":
            self.session_vars[name] = value
        else:
            self.context_vars[name] = value

    def get_variable(self, name):
        """ë³€ìˆ˜ ê°€ì ¸ì˜¤ê¸° (ìš°ì„ ìˆœìœ„: context > session > global)"""
        return (self.context_vars.get(name) or
                self.session_vars.get(name) or
                self.global_vars.get(name))

    def substitute_variables(self, template):
        """í…œí”Œë¦¿ì—ì„œ ë³€ìˆ˜ ì¹˜í™˜"""
        import re

        def replace_var(match):
            var_name = match.group(1)
            return str(self.get_variable(var_name) or f"{{{var_name}}}")

        return re.sub(r'\{(\w+)\}', replace_var, template)

# ë³€ìˆ˜ í™œìš© ì˜ˆì‹œ
variables = PromptVariables()
variables.set_variable("project_name", "MoAI-ADK", "global")
variables.set_variable("current_user", "ê°œë°œìA", "session")
variables.set_variable("task_type", "API ê°œë°œ", "context")

template = """
í”„ë¡œì íŠ¸: {project_name}
ì‚¬ìš©ì: {current_user}
ì‘ì—…: {task_type}
"""

result = variables.substitute_variables(template)
print(result)
# ì¶œë ¥:
# í”„ë¡œì íŠ¸: MoAI-ADK
# ì‚¬ìš©ì: ê°œë°œìA
# ì‘ì—…: API ê°œë°œ
```

### 2. ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ í”„ë¡¬í”„íŠ¸

```python
# ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°
class ContextAwarePrompt:
    def __init__(self):
        self.context_history = []
        self.current_context = {}

    def add_context(self, context_type, content):
        """ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€"""
        self.context_history.append({
            'type': context_type,
            'content': content,
            'timestamp': datetime.now()
        })

    def build_aware_prompt(self, base_prompt):
        """ì»¨í…ìŠ¤íŠ¸ë¥¼ ê³ ë ¤í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        recent_context = self.get_relevant_context()

        return f"""
# í˜„ì¬ ì»¨í…ìŠ¤íŠ¸
{self.format_context(recent_context)}

# ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
{base_prompt}

# ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì§€ì‹œ
{self.generate_context_instructions(recent_context)}
        """

    def get_relevant_context(self, hours=2):
        """ìµœê·¼ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        return [ctx for ctx in self.context_history
                if ctx['timestamp'] > cutoff_time]

    def format_context(self, contexts):
        """ì»¨í…ìŠ¤íŠ¸ í¬ë§·íŒ…"""
        formatted = []
        for ctx in contexts:
            formatted.append(f"**{ctx['type']}**: {ctx['content']}")
        return "\n".join(formatted)

    def generate_context_instructions(self, contexts):
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì¶”ê°€ ì§€ì‹œ ìƒì„±"""
        instructions = []

        for ctx in contexts:
            if ctx['type'] == 'previous_error':
                instructions.append("ì´ì „ ì˜¤ë¥˜ë¥¼ í”¼í•˜ì„¸ìš”.")
            elif ctx['type'] == 'user_preference':
                instructions.append(f"ì‚¬ìš©ì ì„ í˜¸: {ctx['content']}")
            elif ctx['type'] == 'tech_stack':
                instructions.append(f"ì‚¬ìš© ê¸°ìˆ : {ctx['content']}")

        return "\n".join(instructions) if instructions else "íŠ¹ë³„í•œ ì»¨í…ìŠ¤íŠ¸ ì§€ì‹œ ì—†ìŒ"
```

## â›“ï¸ ë‹¤ë‹¨ê³„ í”„ë¡¬í”„íŠ¸ ì²´ì¸

### 1. ìˆœì°¨ì  ì²˜ë¦¬ ì²´ì¸

```python
# ìˆœì°¨ì  í”„ë¡¬í”„íŠ¸ ì²´ì¸
class SequentialPromptChain:
    def __init__(self):
        self.steps = []
        self.intermediate_results = {}

    def add_step(self, name, prompt_template, dependencies=None):
        """ì²˜ë¦¬ ë‹¨ê³„ ì¶”ê°€"""
        self.steps.append({
            'name': name,
            'template': prompt_template,
            'dependencies': dependencies or []
        })

    def execute_chain(self, initial_input):
        """ì²´ì¸ ì‹¤í–‰"""
        current_input = initial_input
        results = {}

        for step in self.steps:
            # ì˜ì¡´ì„± í™•ì¸
            if self.check_dependencies(step['dependencies'], results):
                # í”„ë¡¬í”„íŠ¸ ìƒì„±
                prompt = self.build_step_prompt(step, results, current_input)

                # Claude ì‹¤í–‰ (ì‹¤ì œë¡œëŠ” Task() í˜¸ì¶œ)
                result = self.execute_claude(prompt)

                # ê²°ê³¼ ì €ì¥
                results[step['name']] = result
                current_input = result
            else:
                raise Exception(f"Step {step['name']} ì˜ì¡´ì„± ë¯¸ì¶©ì¡±")

        return results

    def build_step_prompt(self, step, previous_results, input_data):
        """ë‹¨ê³„ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        prompt = step['template']

        # ì´ì „ ê²°ê³¼ í†µí•©
        for dep_name in step['dependencies']:
            if dep_name in previous_results:
                prompt = prompt.replace(f"{{{dep_name}}}", previous_results[dep_name])

        # ì…ë ¥ ë°ì´í„° í†µí•©
        prompt = prompt.replace("{input}", input_data)

        return prompt

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
chain = SequentialPromptChain()

# 1ë‹¨ê³„: ìš”êµ¬ì‚¬í•­ ë¶„ì„
chain.add_step(
    name="analysis",
    prompt_template="""
    ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë¶„ì„í•´ì£¼ì„¸ìš”: {input}

    ë¶„ì„ ê²°ê³¼:
    - í•µì‹¬ ê¸°ëŠ¥:
    - ê¸°ìˆ  ìš”êµ¬ì‚¬í•­:
    - ë³µì¡ë„ í‰ê°€:
    - ì˜ˆìƒ ê°œë°œ ì‹œê°„:
    """
)

# 2ë‹¨ê³„: ì•„í‚¤í…ì²˜ ì„¤ê³„
chain.add_step(
    name="architecture",
    prompt_template="""
    ë‹¤ìŒ ë¶„ì„ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì•„í‚¤í…ì²˜ë¥¼ ì„¤ê³„í•´ì£¼ì„¸ìš”:

    ë¶„ì„ ê²°ê³¼:
    {analysis}

    ì„¤ê³„ ë‚´ìš©:
    - ì‹œìŠ¤í…œ êµ¬ì¡°:
    - ì£¼ìš” ì»´í¬ë„ŒíŠ¸:
    - ë°ì´í„° íë¦„:
    - ê¸°ìˆ  ìŠ¤íƒ ì„ íƒ:
    """,
    dependencies=["analysis"]
)

# 3ë‹¨ê³„: êµ¬í˜„ ê³„íš
chain.add_step(
    name="implementation",
    prompt_template="""
    ë‹¤ìŒ ì•„í‚¤í…ì²˜ ì„¤ê³„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„ ê³„íšì„ ìˆ˜ë¦½í•´ì£¼ì„¸ìš”:

    ì•„í‚¤í…ì²˜:
    {architecture}

    êµ¬í˜„ ê³„íš:
    - ê°œë°œ ë‹¨ê³„:
    - ìš°ì„ ìˆœìœ„:
    - ë¦¬ìŠ¤í¬ ê´€ë¦¬:
    - í…ŒìŠ¤íŠ¸ ì „ëµ:
    """,
    dependencies=["architecture"]
)
```

### 2. ë³‘ë ¬ ì²˜ë¦¬ ì²´ì¸

```python
# ë³‘ë ¬ ì²˜ë¦¬ í”„ë¡¬í”„íŠ¸ ì²´ì¸
class ParallelPromptChain:
    def __init__(self):
        self.parallel_tasks = {}
        self.merge_strategy = None

    def add_parallel_task(self, task_name, prompt_template):
        """ë³‘ë ¬ ì‘ì—… ì¶”ê°€"""
        self.parallel_tasks[task_name] = {
            'template': prompt_template,
            'result': None
        }

    def set_merge_strategy(self, merge_template):
        """ê²°ê³¼ ë³‘í•© ì „ëµ ì„¤ì •"""
        self.merge_strategy = merge_template

    def execute_parallel(self, input_data):
        """ë³‘ë ¬ ì‘ì—… ì‹¤í–‰"""
        import asyncio

        async def run_task(task_name, task_info):
            prompt = task_info['template'].replace("{input}", input_data)
            # ì‹¤ì œë¡œëŠ” ë¹„ë™ê¸° Claude í˜¸ì¶œ
            result = await self.execute_claude_async(prompt)
            self.parallel_tasks[task_name]['result'] = result
            return result

        # ëª¨ë“  ì‘ì—… ë³‘ë ¬ ì‹¤í–‰
        tasks = [
            run_task(name, info)
            for name, info in self.parallel_tasks.items()
        ]

        results = asyncio.run(asyncio.gather(*tasks))

        # ê²°ê³¼ ë³‘í•©
        if self.merge_strategy:
            merged_result = self.merge_results(results)
            return merged_result

        return results

    def merge_results(self, results):
        """ë³‘í•© ì „ëµìœ¼ë¡œ ê²°ê³¼ í†µí•©"""
        # ê²°ê³¼ë“¤ì„ í…œí”Œë¦¿ì— í†µí•©
        merge_prompt = self.merge_strategy

        for i, (task_name, task_info) in enumerate(self.parallel_tasks.items()):
            merge_prompt = merge_prompt.replace(
                f"{{{task_name}}}",
                task_info['result']
            )

        return self.execute_claude(merge_prompt)

# ë³‘ë ¬ ì²´ì¸ ì˜ˆì‹œ
parallel_chain = ParallelPromptChain()

# UI ë””ìì¸ê³¼ API ì„¤ê³„ ë³‘ë ¬ ì²˜ë¦¬
parallel_chain.add_parallel_task(
    "ui_design",
    """
    ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ë””ìì¸ì„ ì œì•ˆí•´ì£¼ì„¸ìš”: {input}
    - ì™€ì´ì–´í”„ë ˆì„
    - ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
    - ì‚¬ìš©ì í”Œë¡œìš°
    """
)

parallel_chain.add_parallel_task(
    "api_design",
    """
    API ì„¤ê³„ë¥¼ ì œì•ˆí•´ì£¼ì„¸ìš”: {input}
    - ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
    - ë°ì´í„° ëª¨ë¸
    - ì¸ì¦ ë°©ì‹
    """
)

parallel_chain.add_parallel_task(
    "database_schema",
    """
    ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ì„¤ê³„í•´ì£¼ì„¸ìš”: {input}
    - í…Œì´ë¸” êµ¬ì¡°
    - ê´€ê³„ ì •ì˜
    - ì¸ë±ìŠ¤ ì „ëµ
    """
)

# ê²°ê³¼ ë³‘í•© ì „ëµ
parallel_chain.set_merge_strategy("""
    ë‹¤ìŒ ì„¸ ê°€ì§€ ì„¤ê³„ ê²°ê³¼ë¥¼ í†µí•©í•˜ì—¬ ì „ì²´ ì†”ë£¨ì…˜ì„ ì œì•ˆí•´ì£¼ì„¸ìš”:

    UI ë””ìì¸:
    {ui_design}

    API ì„¤ê³„:
    {api_design}

    ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ:
    {database_schema}

    í†µí•©ëœ ì†”ë£¨ì…˜:
    - ì•„í‚¤í…ì²˜ ê°œìš”
    - êµ¬í˜„ ìš°ì„ ìˆœìœ„
    - ê¸°ìˆ  í†µí•© ë°©ì•ˆ
    - ê°œë°œ ê³„íš
""")
```

## ğŸ¯ ì¡°ê±´ë¶€ í”„ë¡¬í”„íŠ¸

### 1. ë¶„ê¸° ë¡œì§

```python
# ì¡°ê±´ë¶€ í”„ë¡¬í”„íŠ¸ ìƒì„±
class ConditionalPrompt:
    def __init__(self):
        self.conditions = []

    def add_condition(self, condition, prompt_template):
        """ì¡°ê±´ê³¼ í•´ë‹¹ í”„ë¡¬í”„íŠ¸ ì¶”ê°€"""
        self.conditions.append({
            'condition': condition,
            'template': prompt_template
        })

    def evaluate_and_build(self, context):
        """ì¡°ê±´ í‰ê°€ ë° í”„ë¡¬í”„íŠ¸ ë¹Œë“œ"""
        for cond in self.conditions:
            if self.evaluate_condition(cond['condition'], context):
                return self.build_prompt(cond['template'], context)

        # ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
        return self.build_default_prompt(context)

    def evaluate_condition(self, condition, context):
        """ì¡°ê±´ í‰ê°€"""
        # ê°„ë‹¨í•œ ì¡°ê±´ í‰ê°€ ë¡œì§
        try:
            return eval(condition, {"__builtins__": {}}, context)
        except:
            return False

    def build_prompt(self, template, context):
        """ì»¨í…ìŠ¤íŠ¸ë¡œ í”„ë¡¬í”„íŠ¸ ë¹Œë“œ"""
        import re

        def replace_var(match):
            var_name = match.group(1)
            return str(context.get(var_name, f"{{{var_name}}}"))

        return re.sub(r'\{(\w+)\}', replace_var, template)

# ì¡°ê±´ë¶€ í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œ
conditional = ConditionalPrompt()

# ë³µì¡ë„ì— ë”°ë¥¸ í”„ë¡¬í”„íŠ¸
conditional.add_condition(
    "complexity >= 8",
    """
    ë³µì¡í•œ ì‘ì—…ì…ë‹ˆë‹¤. ì²´ê³„ì ì¸ ì ‘ê·¼ì´ í•„ìš”í•©ë‹ˆë‹¤.

    í”„ë¡œì íŠ¸: {project_name}
    ë³µì¡ë„: {complexity}/10

    ë‹¨ê³„ë³„ ì ‘ê·¼:
    1. ë¬¸ì œ ë¶„í•´
    2. ìš°ì„ ìˆœìœ„ ì„¤ì •
    3. ì„¸ë¶€ ê³„íš ìˆ˜ë¦½
    4. ìœ„í—˜ ê´€ë¦¬
    5. ê²€ì¦ ì „ëµ
    """
)

conditional.add_condition(
    "time_constraint == 'urgent'",
    """
    ê¸´ê¸‰ ì‘ì—…ì…ë‹ˆë‹¤. ë¹ ë¥¸ í•´ê²°ì±…ì´ í•„ìš”í•©ë‹ˆë‹¤.

    í”„ë¡œì íŠ¸: {project_name}
    ë§ˆê°ì¼: {deadline}

    ì‹ ì† ì ‘ê·¼:
    1. MVP ë²”ìœ„ ì •ì˜
    2. í•µì‹¬ ê¸°ëŠ¥ ìš°ì„ 
    3. ë‹¨ìˆœí•œ ì†”ë£¨ì…˜ ì„ íƒ
    4. í›„ë°˜ ê°œì„  ê³„íš
    """
)

# ì»¨í…ìŠ¤íŠ¸ì— ë”°ë¥¸ ë™ì  í”„ë¡¬í”„íŠ¸ ìƒì„±
context = {
    "project_name": "ì‚¬ìš©ì ëŒ€ì‹œë³´ë“œ",
    "complexity": 9,
    "time_constraint": "urgent",
    "deadline": "3ì¼"
}

prompt = conditional.evaluate_and_build(context)
```

### 2. ë™ì  í”„ë¡¬í”„íŠ¸ ìƒì„±

```python
# ë™ì  í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°
class DynamicPromptGenerator:
    def __init__(self):
        self.prompt_templates = {}
        self.context_analyzers = {}

    def register_template(self, name, template):
        """í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ë“±ë¡"""
        self.prompt_templates[name] = template

    def analyze_context(self, context):
        """ì»¨í…ìŠ¤íŠ¸ ë¶„ì„"""
        analysis = {}

        # ë³µì¡ë„ ë¶„ì„
        if 'requirements' in context:
            analysis['complexity'] = self.calculate_complexity(
                context['requirements']
            )

        # ê¸°ìˆ  ìŠ¤íƒ ë¶„ì„
        if 'tech_stack' in context:
            analysis['tech_complexity'] = len(context['tech_stack'])

        # ì‹œê°„ ì œì•½ ë¶„ì„
        if 'deadline' in context:
            analysis['urgency'] self.calculate_urgency(context['deadline'])

        return analysis

    def generate_optimal_prompt(self, context):
        """ìµœì ì˜ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        analysis = self.analyze_context(context)

        # ë¶„ì„ ê²°ê³¼ì— ë”°ë¼ í…œí”Œë¦¿ ì„ íƒ
        if analysis.get('complexity', 0) > 8:
            template_name = "complex_project"
        elif analysis.get('urgency', 0) > 7:
            template_name = "urgent_task"
        elif analysis.get('tech_complexity', 0) > 5:
            template_name = "multi_tech"
        else:
            template_name = "standard"

        template = self.prompt_templates.get(template_name)
        if template:
            return self.build_prompt_from_template(template, context, analysis)
        else:
            return self.generate_basic_prompt(context)

    def build_prompt_from_template(self, template, context, analysis):
        """í…œí”Œë¦¿ìœ¼ë¡œ í”„ë¡¬í”„íŠ¸ ë¹Œë“œ"""
        import re

        def replace_placeholders(match):
            var_name = match.group(1)

            # ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì°¾ê¸°
            if var_name in context:
                return str(context[var_name])
            # ë¶„ì„ ê²°ê³¼ì—ì„œ ì°¾ê¸°
            elif var_name in analysis:
                return str(analysis[var_name])
            else:
                return f"{{{var_name}}}"

        return re.sub(r'\{(\w+)\}', replace_placeholders, template)

# ë™ì  í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸° ì„¤ì •
generator = DynamicPromptGenerator()

generator.register_template("complex_project", """
ë³µì¡ë„ {complexity}/10ì˜ ë³µì¡í•œ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤.

í”„ë¡œì íŠ¸: {project_name}
í•µì‹¬ ìš”êµ¬ì‚¬í•­: {requirements}

ì²´ê³„ì  ì ‘ê·¼ë²•:
1. ì•„í‚¤í…ì²˜ ì„¤ê³„ (ì¤‘ìš”ë„: ë†’ìŒ)
2. ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ (ì¤‘ìš”ë„: ë†’ìŒ)
3. ì¸í„°í˜ì´ìŠ¤ ì •ì˜ (ì¤‘ìš”ë„: ì¤‘ê°„)
4. êµ¬í˜„ ì „ëµ ìˆ˜ë¦½ (ì¤‘ìš”ë„: ì¤‘ê°„)
5. í…ŒìŠ¤íŠ¸ ê³„íš (ì¤‘ìš”ë„: ë†’ìŒ)

ì£¼ì˜ì‚¬í•­:
- ë°˜ë³µì ì¸ ë¦¬íŒ©í† ë§ ì¤€ë¹„
- ëª…í™•í•œ ë¬¸ì„œí™” í•„ìˆ˜
- ì ì§„ì  ê°œë°œ ì ‘ê·¼
""")

generator.register_template("urgent_task", """
ê¸´ê¸‰ë„ {urgency}/10ì˜ ì‹œê¸‰í•œ ì‘ì—…ì…ë‹ˆë‹¤.

í”„ë¡œì íŠ¸: {project_name}
ë§ˆê°ì¼: {deadline}

ì‹ ì† í•´ê²° ì „ëµ:
1. MVP ë²”ìœ„ ì¶•ì†Œ
2. í•µì‹¬ ê¸°ëŠ¥ ì§‘ì¤‘
3. ë‹¨ìˆœí•œ êµ¬í˜„ ì„ íƒ
4. í›„ë°˜ ê°œì„  ê³„íš
5. ë¹ ë¥¸ ê²€ì¦ í”„ë¡œì„¸ìŠ¤

ì‹œê°„ ê´€ë¦¬:
- ë¶ˆí•„ìš”í•œ ê¸°ëŠ¥ ì œê±°
- ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ í™œìš©
- ìœ„í—˜ ìš”ì†Œ ìµœì†Œí™”
""")
```

## ğŸ“Š í…œí”Œë¦¿ ê´€ë¦¬ ì‹œìŠ¤í…œ

### 1. í…œí”Œë¦¿ ì €ì¥ì†Œ

```python
# í…œí”Œë¦¿ ê´€ë¦¬ ì‹œìŠ¤í…œ
class PromptTemplateRepository:
    def __init__(self):
        self.templates = {}
        self.template_categories = {}
        self.usage_stats = {}

    def save_template(self, name, template, category="general", metadata=None):
        """í…œí”Œë¦¿ ì €ì¥"""
        self.templates[name] = {
            'content': template,
            'category': category,
            'metadata': metadata or {},
            'created_at': datetime.now(),
            'updated_at': datetime.now(),
            'version': 1
        }

        # ì¹´í…Œê³ ë¦¬ ë“±ë¡
        if category not in self.template_categories:
            self.template_categories[category] = []
        if name not in self.template_categories[category]:
            self.template_categories[category].append(name)

    def get_template(self, name):
        """í…œí”Œë¦¿ ê°€ì ¸ì˜¤ê¸°"""
        if name in self.templates:
            # ì‚¬ìš© í†µê³„ ì—…ë°ì´íŠ¸
            self.update_usage_stats(name)
            return self.templates[name]
        return None

    def update_template(self, name, new_content, metadata_updates=None):
        """í…œí”Œë¦¿ ì—…ë°ì´íŠ¸"""
        if name in self.templates:
            self.templates[name]['content'] = new_content
            self.templates[name]['updated_at'] = datetime.now()
            self.templates[name]['version'] += 1

            if metadata_updates:
                self.templates[name]['metadata'].update(metadata_updates)

    def search_templates(self, keyword, category=None):
        """í…œí”Œë¦¿ ê²€ìƒ‰"""
        results = []

        for name, template in self.templates.items():
            # ì¹´í…Œê³ ë¦¬ í•„í„°
            if category and template['category'] != category:
                continue

            # í‚¤ì›Œë“œ ê²€ìƒ‰
            if (keyword.lower() in name.lower() or
                keyword.lower() in template['content'].lower() or
                keyword.lower() in str(template['metadata']).lower()):
                results.append((name, template))

        return results

    def update_usage_stats(self, template_name):
        """ì‚¬ìš© í†µê³„ ì—…ë°ì´íŠ¸"""
        if template_name not in self.usage_stats:
            self.usage_stats[template_name] = {
                'usage_count': 0,
                'last_used': None,
                'success_rate': 0.0
            }

        stats = self.usage_stats[template_name]
        stats['usage_count'] += 1
        stats['last_used'] = datetime.now()

    def get_popular_templates(self, limit=10):
        """ì¸ê¸° í…œí”Œë¦¿ ê°€ì ¸ì˜¤ê¸°"""
        sorted_templates = sorted(
            self.usage_stats.items(),
            key=lambda x: x[1]['usage_count'],
            reverse=True
        )
        return sorted_templates[:limit]
```

### 2. í…œí”Œë¦¿ ë²„ì „ ê´€ë¦¬

```python
# í…œí”Œë¦¿ ë²„ì „ ê´€ë¦¬
class TemplateVersionManager:
    def __init__(self, repository):
        self.repo = repository
        self.version_history = {}

    def create_version(self, template_name, change_description=""):
        """ìƒˆ ë²„ì „ ìƒì„±"""
        template = self.repo.get_template(template_name)
        if not template:
            return None

        # ë²„ì „ ê¸°ë¡
        if template_name not in self.version_history:
            self.version_history[template_name] = []

        version_info = {
            'version': template['version'],
            'content': template['content'],
            'metadata': template['metadata'].copy(),
            'created_at': template['updated_at'],
            'change_description': change_description
        }

        self.version_history[template_name].append(version_info)
        return version_info

    def rollback_to_version(self, template_name, target_version):
        """íŠ¹ì • ë²„ì „ìœ¼ë¡œ ë¡¤ë°±"""
        if template_name in self.version_history:
            for version_info in self.version_history[template_name]:
                if version_info['version'] == target_version:
                    self.repo.update_template(
                        template_name,
                        version_info['content'],
                        version_info['metadata']
                    )
                    return True
        return False

    def compare_versions(self, template_name, version1, version2):
        """ë²„ì „ ê°„ ì°¨ì´ì  ë¹„êµ"""
        if template_name not in self.version_history:
            return None

        versions = {}
        for version_info in self.version_history[template_name]:
            if version_info['version'] in [version1, version2]:
                versions[version_info['version']] = version_info['content']

        if len(versions) == 2:
            return {
                'version1': version1,
                'version2': version2,
                'content1': versions[version1],
                'content2': versions[version2],
                'diff': self.calculate_diff(versions[version1], versions[version2])
            }

        return None
```

## ğŸ¯ ì‹¤ì „ ì˜ˆì œ: í†µí•© í”„ë¡¬í”„íŠ¸ ì‹œìŠ¤í…œ

```python
# í†µí•© í”„ë¡¬í”„íŠ¸ ì‹œìŠ¤í…œ ì˜ˆì‹œ
class IntegratedPromptSystem:
    def __init__(self):
        self.repo = PromptTemplateRepository()
        self.version_manager = TemplateVersionManager(self.repo)
        self.variables = PromptVariables()
        self.dynamic_generator = DynamicPromptGenerator()

        # í‘œì¤€ í…œí”Œë¦¿ ë¡œë“œ
        self.load_standard_templates()

    def load_standard_templates(self):
        """í‘œì¤€ í…œí”Œë¦¿ ë¡œë“œ"""
        # API ê°œë°œ í…œí”Œë¦¿
        self.repo.save_template(
            "api_development",
            API_DEVELOPMENT_TEMPLATE,
            category="development",
            metadata={
                "purpose": "API ê°œë°œ",
                "complexity": "medium",
                "tech_stack": ["FastAPI", "REST"]
            }
        )

        # ì½”ë“œ ë¦¬ë·° í…œí”Œë¦¿
        self.repo.save_template(
            "code_review",
            CODE_REVIEW_TEMPLATE,
            category="quality",
            metadata={
                "purpose": "ì½”ë“œ í’ˆì§ˆ ê²€í† ",
                "complexity": "low",
                "languages": ["Python", "JavaScript", "TypeScript"]
            }
        )

    def generate_contextual_prompt(self, task_type, context):
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        # 1. ê´€ë ¨ í…œí”Œë¦¿ ê²€ìƒ‰
        templates = self.repo.search_templates(
            task_type,
            category=context.get('category')
        )

        if templates:
            # 2. ê°€ì¥ ì í•©í•œ í…œí”Œë¦¿ ì„ íƒ
            best_template = self.select_best_template(templates, context)

            # 3. ë³€ìˆ˜ ì¹˜í™˜
            self.variables.set_variables_from_context(context)
            final_prompt = self.variables.substitute_variables(
                best_template['content']
            )

            # 4. ì‚¬ìš© í†µê³„ ê¸°ë¡
            self.repo.update_usage_stats(best_template['name'])

            return final_prompt
        else:
            # ë™ì  ìƒì„±ìœ¼ë¡œ ëŒ€ì²´
            return self.dynamic_generator.generate_optimal_prompt(context)

    def select_best_template(self, templates, context):
        """ì»¨í…ìŠ¤íŠ¸ì— ê°€ì¥ ì í•©í•œ í…œí”Œë¦¿ ì„ íƒ"""
        scored_templates = []

        for name, template in templates:
            score = self.calculate_template_score(template, context)
            scored_templates.append((score, name, template))

        # ì ìˆ˜ìˆœ ì •ë ¬ í›„ ìµœìƒìœ„ í…œí”Œë¦¿ ë°˜í™˜
        scored_templates.sort(reverse=True, key=lambda x: x[0])
        return scored_templates[0][2] if scored_templates else None

    def calculate_template_score(self, template, context):
        """í…œí”Œë¦¿ ì í•©ë„ ì ìˆ˜ ê³„ì‚°"""
        score = 0

        # ì¹´í…Œê³ ë¦¬ ì¼ì¹˜
        if template['category'] == context.get('category'):
            score += 30

        # ë©”íƒ€ë°ì´í„° ì¼ì¹˜
        metadata = template['metadata']

        if 'tech_stack' in context and 'tech_stack' in metadata:
            common_techs = set(context['tech_stack']) & set(metadata['tech_stack'])
            score += len(common_techs) * 10

        if 'complexity' in context and 'complexity' in metadata:
            if context['complexity'] == metadata['complexity']:
                score += 20

        # ì‚¬ìš© ë¹ˆë„ ê°€ì¤‘ì¹˜
        usage_stats = self.repo.usage_stats.get(template['name'], {})
        score += min(usage_stats.get('usage_count', 0), 20)

        return score

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
prompt_system = IntegratedPromptSystem()

# ì»¨í…ìŠ¤íŠ¸ ì •ì˜
context = {
    "task_type": "api_development",
    "category": "development",
    "tech_stack": ["FastAPI", "PostgreSQL", "Redis"],
    "complexity": "medium",
    "project_name": "ì‚¬ìš©ì ê´€ë¦¬ ì‹œìŠ¤í…œ",
    "timeline": "2ì£¼",
    "team_size": 3
}

# ìµœì ì˜ í”„ë¡¬í”„íŠ¸ ìƒì„±
optimal_prompt = prompt_system.generate_contextual_prompt("api_development", context)
print(optimal_prompt)
```

## ğŸ“– ë‹¤ìŒ ë‹¨ê³„

ì´ì œ êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸ ì„¤ê³„ë¥¼ í•™ìŠµí–ˆìœ¼ë‹ˆ, ë‹¤ìŒìœ¼ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **[ì¼ë°˜ì ì¸ íŒ¨í„´](./common-patterns)** - ì½”ë”©, ë””ë²„ê¹…, ë¬¸ì„œí™”ìš© íŒ¨í„´
2. **[ë¬¸ì œ í•´ê²°](./troubleshooting)** - ì¼ë°˜ì ì¸ ë¬¸ì œì™€ í•´ê²° ë°©ë²•
3. **[ëª¨ë²” ì‚¬ë¡€](./best-practices)** - Claude 4.5 ìµœì í™”ì™€ ì „ë¬¸ê°€ íŒ

---

## ğŸ”— ê´€ë ¨ ìë£Œ

- [Anthropic í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ê°€ì´ë“œ](https://docs.anthropic.com/claude/docs/prompt-engineering)
- [MoAI-ADK ì›Œí¬í”Œë¡œìš°](../core-concepts/workflow)
- [Nextra ë¬¸ì„œí™”](../skills/moai-library-nextra)