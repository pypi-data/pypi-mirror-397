---
title: "ì—ì´ì „íŠ¸ í†µì‹  í”„ë¡œí† ì½œ"
description: "ì—ì´ì „íŠ¸ ê°„ íš¨ìœ¨ì ì¸ í†µì‹  ë©”ì»¤ë‹ˆì¦˜, ë°ì´í„° êµí™˜ í”„ë¡œí† ì½œ, ì»¨í…ìŠ¤íŠ¸ ê³µìœ  ì‹œìŠ¤í…œ"
---

# ì—ì´ì „íŠ¸ í†µì‹  í”„ë¡œí† ì½œ

ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œì˜ ì„±ê³µì€ ì—ì´ì „íŠ¸ ê°„ì˜ **íš¨ìœ¨ì ì¸ í†µì‹ **ì— ë‹¬ë ¤ ìˆìŠµë‹ˆë‹¤. MoAI-ADKëŠ” Anthropicì˜ ì—°êµ¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í‘œì¤€í™”ëœ í†µì‹  í”„ë¡œí† ì½œê³¼ ë°ì´í„° êµí™˜ í˜•ì‹ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

## ğŸ¯ í†µì‹  ì•„í‚¤í…ì²˜ ê°œìš”

### 3ê³„ì¸µ í†µì‹  ëª¨ë¸

```mermaid
graph TB
    subgraph "Layer 3: Semantic Layer"
        A1[Intent Understanding<br/>ì˜ë„ ì´í•´]
        A2[Context Sharing<br/>ì»¨í…ìŠ¤íŠ¸ ê³µìœ ]
        A3[Knowledge Transfer<br/>ì§€ì‹ ì „ì´]
    end

    subgraph "Layer 2: Protocol Layer"
        B1[Message Format<br/>ë©”ì‹œì§€ í˜•ì‹]
        B2[Routing Logic<br/>ë¼ìš°íŒ… ë¡œì§]
        B3[Error Handling<br/>ì—ëŸ¬ ì²˜ë¦¬]
    end

    subgraph "Layer 1: Transport Layer"
        C1[Data Serialization<br/>ë°ì´í„° ì§ë ¬í™”]
        C2[Network Protocol<br/>ë„¤íŠ¸ì›Œí¬ í”„ë¡œí† ì½œ]
        C3[Security & Auth<br/>ë³´ì•ˆ ë° ì¸ì¦]
    end

    A1 --> B1
    A2 --> B2
    A3 --> B3

    B1 --> C1
    B2 --> C2
    B3 --> C3

    style A1 fill:#e3f2fd
    style B1 fill:#f3e5f5
    style C1 fill:#e8f5e9
```

## ğŸ“¨ ë©”ì‹œì§€ í˜•ì‹ ë° í”„ë¡œí† ì½œ

### í‘œì¤€ ë©”ì‹œì§€ êµ¬ì¡°

```python
class AgentMessage:
    """ì—ì´ì „íŠ¸ ê°„ í‘œì¤€ ë©”ì‹œì§€ í˜•ì‹"""

    def __init__(self):
        self.header = {
            "message_id": str(uuid.uuid4()),
            "sender": "",
            "receiver": "",
            "timestamp": datetime.now().isoformat(),
            "message_type": "",  # request, response, notification, broadcast
            "priority": "normal",  # low, normal, high, critical
            "correlation_id": ""  # For message chains
        }

        self.payload = {
            "intent": "",
            "data": {},
            "context": {},
            "requirements": {},
            "constraints": {}
        }

        self.metadata = {
            "estimated_tokens": 0,
            "processing_time": 0,
            "retry_count": 0,
            "dependencies": []
        }

    def to_toon(self) -> str:
        """TOON í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™” (í† í° íš¨ìœ¨ì„±)"""
        toon_data = {
            "id": self.header["message_id"],
            "from": self.header["sender"],
            "to": self.header["receiver"],
            "type": self.header["message_type"],
            "intent": self.payload["intent"],
            "data": self._serialize_data(self.payload["data"])
        }
        return encode_toon(toon_data)

    @staticmethod
    def _serialize_data(data: dict) -> str:
        """ë°ì´í„°ë¥¼ TOON í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™”"""
        if not data:
            return ""

        pairs = []
        for key, value in data.items():
            if isinstance(value, dict):
                nested_pairs = [f"{k}|{v}" for k, v in value.items()]
                pairs.append(f"{key}:{','.join(nested_pairs)}")
            elif isinstance(value, list):
                pairs.append(f"{key}:{'|'.join(map(str, value))}")
            else:
                pairs.append(f"{key}:{value}")

        return ','.join(pairs)
```

### í†µì‹  í”„ë¡œí† ì½œ ìœ í˜•

#### 1. ìš”ì²­-ì‘ë‹µ (Request-Response)

```python
class RequestResponseProtocol:
    """ë™ê¸° ìš”ì²­-ì‘ë‹µ í”„ë¡œí† ì½œ"""

    async def send_request(self, receiver: str, request: AgentMessage) -> AgentMessage:
        """ìš”ì²­ ì „ì†¡ ë° ì‘ë‹µ ëŒ€ê¸°"""

        # íƒ€ì„ì•„ì›ƒ ì„¤ì •
        timeout = self.calculate_timeout(request)

        try:
            # ìš”ì²­ ì „ì†¡
            await self.transport_layer.send(receiver, request)

            # ì‘ë‹µ ëŒ€ê¸°
            response = await self.wait_for_response(
                correlation_id=request.header["correlation_id"],
                timeout=timeout
            )

            return response

        except TimeoutError:
            # ì¬ì‹œë„ ë¡œì§
            return await self.retry_request(request)

    def calculate_timeout(self, request: AgentMessage) -> float:
        """ìš”ì²­ ë³µì¡ë„ì— ë”°ë¥¸ íƒ€ì„ì•„ì›ƒ ê³„ì‚°"""
        base_timeout = 30  # seconds
        complexity_factor = len(request.payload["data"]) / 100

        return base_timeout + (complexity_factor * 10)
```

#### 2. ë°œí–‰-êµ¬ë… (Publish-Subscribe)

```python
class PublishSubscribeProtocol:
    """ë¹„ë™ê¸° ë°œí–‰-êµ¬ë… í”„ë¡œí† ì½œ"""

    def __init__(self):
        self.subscriptions = {}
        self.message_queue = asyncio.Queue()

    async def publish(self, topic: str, message: AgentMessage):
        """ë©”ì‹œì§€ ë°œí–‰"""

        subscribers = self.subscriptions.get(topic, [])

        # ë³‘ë ¬ë¡œ ëª¨ë“  êµ¬ë…ìì—ê²Œ ì „ì†¡
        tasks = [
            self.transport_layer.send(subscriber, message)
            for subscriber in subscribers
        ]

        await asyncio.gather(*tasks, return_exceptions=True)

    async def subscribe(self, topic: str, subscriber: str):
        """í† í”½ êµ¬ë…"""

        if topic not in self.subscriptions:
            self.subscriptions[topic] = []

        self.subscriptions[topic].append(subscriber)

    # í† í”½ ì˜ˆì‹œ
    TOPICS = {
        "security.alerts": "ë³´ì•ˆ ê´€ë ¨ ì•Œë¦¼",
        "performance.metrics": "ì„±ëŠ¥ ì§€í‘œ",
        "code.changes": "ì½”ë“œ ë³€ê²½ ì‚¬í•­",
        "test.results": "í…ŒìŠ¤íŠ¸ ê²°ê³¼",
        "deployment.events": "ë°°í¬ ì´ë²¤íŠ¸"
    }
```

#### 3. ìŠ¤íŠ¸ë¦¬ë° (Streaming)

```python
class StreamingProtocol:
    """ëŒ€ìš©ëŸ‰ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë° í”„ë¡œí† ì½œ"""

    async def stream_data(self, receiver: str, data_stream: AsyncIterator):
        """ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°"""

        stream_id = str(uuid.uuid4())

        # ìŠ¤íŠ¸ë¦¼ ì‹œì‘ ë©”ì‹œì§€
        start_message = AgentMessage()
        start_message.header["message_type"] = "stream_start"
        start_message.payload["stream_id"] = stream_id
        await self.transport_layer.send(receiver, start_message)

        # ë°ì´í„° ì²­í¬ ì „ì†¡
        async for chunk in data_stream:
            chunk_message = AgentMessage()
            chunk_message.header["message_type"] = "stream_chunk"
            chunk_message.payload["stream_id"] = stream_id
            chunk_message.payload["data"] = chunk
            await self.transport_layer.send(receiver, chunk_message)

        # ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ë©”ì‹œì§€
        end_message = AgentMessage()
        end_message.header["message_type"] = "stream_end"
        end_message.payload["stream_id"] = stream_id
        await self.transport_layer.send(receiver, end_message)
```

## ğŸ§  ì»¨í…ìŠ¤íŠ¸ ê³µìœ  ì‹œìŠ¤í…œ

### ë¶„ì‚° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬

```python
class DistributedContextManager:
    """ë¶„ì‚° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.context_store = {}
        self.context_versions = {}
        self.access_control = {}

    async def share_context(self, context_id: str, data: dict,
                           sender: str, receivers: list):
        """ì»¨í…ìŠ¤íŠ¸ ê³µìœ """

        # ì»¨í…ìŠ¤íŠ¸ ë²„ì „ ê´€ë¦¬
        version = self.increment_version(context_id)

        # ì•¡ì„¸ìŠ¤ ê¶Œí•œ í™•ì¸
        if not self.check_access_permission(sender, receivers, context_id):
            raise PermissionError("No access permission for context sharing")

        # ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        self.context_store[context_id] = {
            "data": data,
            "version": version,
            "owner": sender,
            "shared_with": receivers,
            "timestamp": datetime.now(),
            "access_count": 0
        }

        # ìˆ˜ì‹ ìì—ê²Œ ì•Œë¦¼
        notification = AgentMessage()
        notification.header["message_type"] = "context_shared"
        notification.payload = {
            "context_id": context_id,
            "version": version,
            "sender": sender
        }

        for receiver in receivers:
            await self.transport_layer.send(receiver, notification)

    async def get_context(self, context_id: str, requester: str) -> dict:
        """ì»¨í…ìŠ¤íŠ¸ ì¡°íšŒ"""

        context = self.context_store.get(context_id)
        if not context:
            raise ValueError(f"Context {context_id} not found")

        # ì•¡ì„¸ìŠ¤ ê¶Œí•œ í™•ì¸
        if not self.has_access_permission(requester, context_id):
            raise PermissionError(f"No access to context {context_id}")

        # ì•¡ì„¸ìŠ¤ ì¹´ìš´íŠ¸ ì¦ê°€
        context["access_count"] += 1

        return context["data"]
```

### ì»¨í…ìŠ¤íŠ¸ ìµœì í™” ì „ëµ

#### 1. ì¦ë¶„ ì—…ë°ì´íŠ¸ (Incremental Updates)

```python
class IncrementalContextUpdater:
    """ì¦ë¶„ ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.context_snapshots = {}
        self.change_logs = {}

    async def update_context_incremental(self, context_id: str,
                                       changes: dict) -> dict:
        """ì¦ë¶„ ë°©ì‹ìœ¼ë¡œ ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""

        # ì´ì „ ìŠ¤ëƒ…ìƒ· ì¡°íšŒ
        previous_snapshot = self.context_snapshots.get(context_id, {})

        # ë³€ê²½ ì‚¬í•­ ì ìš©
        updated_context = self.apply_changes(previous_snapshot, changes)

        # ë³€ê²½ ë¡œê·¸ ê¸°ë¡
        self.record_change_log(context_id, changes)

        # ìƒˆ ìŠ¤ëƒ…ìƒ· ì €ì¥
        self.context_snapshots[context_id] = updated_context

        return updated_context

    def apply_changes(self, base_context: dict, changes: dict) -> dict:
        """ë³€ê²½ ì‚¬í•­ ì ìš©"""

        result = base_context.copy()

        for operation in changes.get("operations", []):
            op_type = operation["type"]
            path = operation["path"]
            value = operation.get("value")

            if op_type == "add":
                self.add_value(result, path, value)
            elif op_type == "update":
                self.update_value(result, path, value)
            elif op_type == "delete":
                self.delete_value(result, path)

        return result
```

#### 2. ì§€ëŠ¥í˜• ìºì‹± (Intelligent Caching)

```python
class IntelligentContextCache:
    """ì§€ëŠ¥í˜• ì»¨í…ìŠ¤íŠ¸ ìºì‹± ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.cache = {}
        self.access_patterns = {}
        self.relevance_scores = {}

    async def get_cached_context(self, context_id: str,
                                requester: str) -> Optional[dict]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ì¡°íšŒ"""

        cache_key = f"{context_id}:{requester}"

        if cache_key not in self.cache:
            return None

        cached_item = self.cache[cache_key]

        # ê´€ë ¨ì„± ì ìˆ˜ í™•ì¸
        if not self.is_context_relevant(cached_item, requester):
            # ìºì‹œì—ì„œ ì œê±°
            del self.cache[cache_key]
            return None

        # ì•¡ì„¸ìŠ¤ íŒ¨í„´ ì—…ë°ì´íŠ¸
        self.update_access_pattern(cache_key)

        return cached_item["data"]

    def is_context_relevant(self, cached_item: dict, requester: str) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ê´€ë ¨ì„± í™•ì¸"""

        # ì‹œê°„ ê¸°ë°˜ ê´€ë ¨ì„±
        age = datetime.now() - cached_item["cached_at"]
        if age > timedelta(hours=1):  # 1ì‹œê°„ ê²½ê³¼
            return False

        # ì‚¬ìš©ì ê¸°ë°˜ ê´€ë ¨ì„±
        relevance_score = self.relevance_scores.get(
            f"{cached_item['context_id']}:{requester}", 0
        )

        return relevance_score > 0.5
```

## ğŸ” ë³´ì•ˆ ë° ì¸ì¦

### ì—ì´ì „íŠ¸ ì¸ì¦ ì‹œìŠ¤í…œ

```python
class AgentAuthentication:
    """ì—ì´ì „íŠ¸ ì¸ì¦ ë° ê¶Œí•œ ê´€ë¦¬"""

    def __init__(self):
        self.agent_credentials = {}
        self.session_tokens = {}
        self.permissions = {}

    def authenticate_agent(self, agent_id: str, credentials: dict) -> str:
        """ì—ì´ì „íŠ¸ ì¸ì¦"""

        # ìê²© ì¦ëª… í™•ì¸
        if not self.verify_credentials(agent_id, credentials):
            raise AuthenticationError("Invalid credentials")

        # ì„¸ì…˜ í† í° ìƒì„±
        session_token = self.generate_session_token(agent_id)

        # ì„¸ì…˜ ì •ë³´ ì €ì¥
        self.session_tokens[session_token] = {
            "agent_id": agent_id,
            "created_at": datetime.now(),
            "expires_at": datetime.now() + timedelta(hours=24),
            "permissions": self.get_agent_permissions(agent_id)
        }

        return session_token

    def authorize_message(self, message: AgentMessage,
                          session_token: str) -> bool:
        """ë©”ì‹œì§€ ê¶Œí•œ í™•ì¸"""

        session_info = self.session_tokens.get(session_token)
        if not session_info:
            return False

        # ì„¸ì…˜ ë§Œë£Œ í™•ì¸
        if datetime.now() > session_info["expires_at"]:
            del self.session_tokens[session_token]
            return False

        # ë©”ì‹œì§€ íƒ€ì…ë³„ ê¶Œí•œ í™•ì¸
        required_permission = f"message.{message.header['message_type']}"
        return required_permission in session_info["permissions"]
```

### ë©”ì‹œì§€ ì•”í˜¸í™”

```python
class MessageEncryption:
    """ë©”ì‹œì§€ ì•”í˜¸í™” ë° ë³µí˜¸í™”"""

    def __init__(self):
        self.encryption_keys = {}

    async def encrypt_message(self, message: AgentMessage,
                            receiver: str) -> AgentMessage:
        """ë©”ì‹œì§€ ì•”í˜¸í™”"""

        # ìˆ˜ì‹ ìì˜ ê³µê°œí‚¤ ì¡°íšŒ
        public_key = self.get_public_key(receiver)

        # ë¯¼ê°í•œ ë°ì´í„°ë§Œ ì•”í˜¸í™”
        sensitive_data = self.extract_sensitive_data(message)

        # ì•”í˜¸í™”
        encrypted_data = await self.encrypt_with_public_key(
            sensitive_data, public_key
        )

        # ì•”í˜¸í™”ëœ ë°ì´í„°ë¡œ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        message.payload["encrypted_data"] = encrypted_data
        self.remove_sensitive_data(message)

        return message

    async def decrypt_message(self, message: AgentMessage,
                            receiver: str) -> AgentMessage:
        """ë©”ì‹œì§€ ë³µí˜¸í™”"""

        if "encrypted_data" not in message.payload:
            return message  # ì•”í˜¸í™”ë˜ì§€ ì•Šì€ ë©”ì‹œì§€

        # ìˆ˜ì‹ ìì˜ ê°œì¸í‚¤ ì¡°íšŒ
        private_key = self.get_private_key(receiver)

        # ë³µí˜¸í™”
        decrypted_data = await self.decrypt_with_private_key(
            message.payload["encrypted_data"], private_key
        )

        # ë³µí˜¸í™”ëœ ë°ì´í„°ë¡œ ë©”ì‹œì§€ ë³µì›
        message.payload.update(decrypted_data)
        del message.payload["encrypted_data"]

        return message
```

## ğŸ“Š í†µì‹  ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”

### í†µì‹  ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```python
class CommunicationMonitor:
    """ì—ì´ì „íŠ¸ í†µì‹  ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"""

    def __init__(self):
        self.metrics = {
            "message_count": 0,
            "total_tokens": 0,
            "average_response_time": 0,
            "error_rate": 0,
            "throughput": 0
        }

    async def monitor_message(self, message: AgentMessage):
        """ë©”ì‹œì§€ í†µê³„ ìˆ˜ì§‘"""

        self.metrics["message_count"] += 1
        self.metrics["total_tokens"] += message.metadata["estimated_tokens"]

        # ì‹¤ì‹œê°„ í†µê³„ ì—…ë°ì´íŠ¸
        await self.update_realtime_metrics()

    def calculate_communication_efficiency(self) -> dict:
        """í†µì‹  íš¨ìœ¨ì„± ê³„ì‚°"""

        efficiency = {
            "token_efficiency": self.calculate_token_efficiency(),
            "latency_efficiency": self.calculate_latency_efficiency(),
            "bandwidth_efficiency": self.calculate_bandwidth_efficiency(),
            "overall_score": self.calculate_overall_score()
        }

        return efficiency

    def get_communication_recommendations(self) -> list:
        """í†µì‹  ê°œì„  ì¶”ì²œì‚¬í•­"""

        recommendations = []

        if self.metrics["error_rate"] > 0.05:  # 5% ì´ìƒ ì—ëŸ¬
            recommendations.append({
                "type": "error_reduction",
                "message": "ì—ëŸ¬ìœ¨ì´ ë†’ìŠµë‹ˆë‹¤. ì¬ì‹œë„ ë¡œì§ì„ ê°œì„ í•˜ì„¸ìš”.",
                "priority": "high"
            })

        if self.metrics["average_response_time"] > 10:  # 10ì´ˆ ì´ìƒ
            recommendations.append({
                "type": "performance_optimization",
                "message": "ì‘ë‹µ ì‹œê°„ì´ ê¹ë‹ˆë‹¤. ì»¨í…ìŠ¤íŠ¸ ìºì‹±ì„ ìµœì í™”í•˜ì„¸ìš”.",
                "priority": "medium"
            })

        return recommendations
```

## ğŸ”„ ì‹¤ì œ í†µì‹  íŒ¨í„´

### íŒ¨í„´ 1: íŒŒì´í”„ë¼ì¸ í†µì‹  (Pipeline Communication)

```mermaid
sequenceDiagram
    participant A as Agent A
    participant B as Agent B
    participant C as Agent C
    participant D as Agent D

    Note over A,D: Pipeline Processing

    A->>B: Initial Request
    B->>B: Process Step 1
    B->>C: Intermediate Result
    C->>C: Process Step 2
    C->>D: Refined Request
    D->>D: Process Step 3
    D->>A: Final Result

    Note over A,D: Each agent adds value sequentially
```

### íŒ¨í„´ 2: í”¼ì–´ íˆ¬ í”¼ì–´ í†µì‹  (Peer-to-Peer Communication)

```python
class PeerToPeerCommunication:
    """ì—ì´ì „íŠ¸ ê°„ ì§ì ‘ í†µì‹  ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.peer_registry = {}
        self.direct_connections = {}

    async def establish_direct_connection(self, agent1: str, agent2: str):
        """ì—ì´ì „íŠ¸ ê°„ ì§ì ‘ ì—°ê²° ìˆ˜ë¦½"""

        connection_id = f"{agent1}<->{agent2}"

        # ì–‘ë°©í–¥ í†µì‹  ì±„ë„ ìƒì„±
        channel = asyncio.Queue()

        self.direct_connections[connection_id] = {
            "channel": channel,
            "agents": [agent1, agent2],
            "established_at": datetime.now()
        }

        # ì–‘ìª½ ì—ì´ì „íŠ¸ì—ê²Œ ì—°ê²° ì•Œë¦¼
        notification = AgentMessage()
        notification.header["message_type"] = "connection_established"
        notification.payload["peer"] = agent2 if agent1 != agent2 else agent1

        await self.send_notification(agent1, notification)
        await self.send_notification(agent2, notification)

    async def send_direct_message(self, sender: str, receiver: str,
                                message: AgentMessage):
        """ì§ì ‘ ë©”ì‹œì§€ ì „ì†¡"""

        connection_id = f"{sender}<->{receiver}"
        connection = self.direct_connections.get(connection_id)

        if not connection:
            # ì—°ê²°ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìˆ˜ë¦½
            await self.establish_direct_connection(sender, receiver)
            connection = self.direct_connections[connection_id]

        # ë©”ì‹œì§€ ì „ì†¡
        await connection["channel"].put(message)
```

### íŒ¨í„´ 3: ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹  (Event-Driven Communication)

```python
class EventDrivenCommunication:
    """ì´ë²¤íŠ¸ ê¸°ë°˜ ì—ì´ì „íŠ¸ í†µì‹ """

    def __init__(self):
        self.event_handlers = {}
        self.event_history = []

    async def emit_event(self, event_type: str, event_data: dict,
                        emitter: str):
        """ì´ë²¤íŠ¸ ë°œí–‰"""

        event = {
            "type": event_type,
            "data": event_data,
            "emitter": emitter,
            "timestamp": datetime.now(),
            "event_id": str(uuid.uuid4())
        }

        # ì´ë²¤íŠ¸ ê¸°ë¡
        self.event_history.append(event)

        # ê´€ë ¨ í•¸ë“¤ëŸ¬ ì‹¤í–‰
        handlers = self.event_handlers.get(event_type, [])
        tasks = [
            self.execute_handler(handler, event)
            for handler in handlers
        ]

        await asyncio.gather(*tasks, return_exceptions=True)

    def register_event_handler(self, event_type: str, handler: callable,
                               agent: str):
        """ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡"""

        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []

        self.event_handlers[event_type].append({
            "handler": handler,
            "agent": agent,
            "registered_at": datetime.now()
        })

    # ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
    EVENT_TYPES = {
        "code.committed": "ì½”ë“œ ì»¤ë°‹ ì´ë²¤íŠ¸",
        "test.failed": "í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì´ë²¤íŠ¸",
        "security.vulnerability": "ë³´ì•ˆ ì·¨ì•½ì  ë°œê²¬",
        "performance.degradation": "ì„±ëŠ¥ ì €í•˜ ê°ì§€",
        "deployment.started": "ë°°í¬ ì‹œì‘",
        "deployment.completed": "ë°°í¬ ì™„ë£Œ"
    }
```

## ğŸ¯ ìµœì í™” ì „ëµ

### 1. ë©”ì‹œì§€ ë°°ì¹­ (Message Batching)

```python
class MessageBatcher:
    """ë©”ì‹œì§€ ë°°ì¹­ ì²˜ë¦¬ ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.batch_queue = asyncio.Queue()
        self.batch_size = 10
        self.batch_timeout = 5.0  # seconds

    async def add_to_batch(self, message: AgentMessage, receiver: str):
        """ë°°ì¹˜ì— ë©”ì‹œì§€ ì¶”ê°€"""

        batch_item = {
            "message": message,
            "receiver": receiver,
            "added_at": datetime.now()
        }

        await self.batch_queue.put(batch_item)

    async def process_batches(self):
        """ë°°ì¹˜ ì²˜ë¦¬"""

        while True:
            batch = []
            deadline = datetime.now() + timedelta(seconds=self.batch_timeout)

            # ë°°ì¹˜ í¬ê¸° ë˜ëŠ” íƒ€ì„ì•„ì›ƒê¹Œì§€ ìˆ˜ì§‘
            while len(batch) < self.batch_size and datetime.now() < deadline:
                try:
                    timeout = (deadline - datetime.now()).total_seconds()
                    item = await asyncio.wait_for(
                        self.batch_queue.get(), timeout=timeout
                    )
                    batch.append(item)
                except asyncio.TimeoutError:
                    break

            if batch:
                await self.send_batch(batch)

    async def send_batch(self, batch: list):
        """ë°°ì¹˜ ì „ì†¡"""

        # ìˆ˜ì‹ ìë³„ ê·¸ë£¹í™”
        grouped_messages = {}
        for item in batch:
            receiver = item["receiver"]
            if receiver not in grouped_messages:
                grouped_messages[receiver] = []
            grouped_messages[receiver].append(item["message"])

        # ê·¸ë£¹ë³„ë¡œ ì „ì†¡
        for receiver, messages in grouped_messages.items():
            batch_message = AgentMessage()
            batch_message.header["message_type"] = "batch"
            batch_message.payload["messages"] = [
                msg.to_toon() for msg in messages
            ]

            await self.transport_layer.send(receiver, batch_message)
```

### 2. ìš°ì„ ìˆœìœ„ í (Priority Queuing)

```python
class PriorityMessageQueue:
    """ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë©”ì‹œì§€ í"""

    def __init__(self):
        self.queues = {
            "critical": asyncio.Queue(),
            "high": asyncio.Queue(),
            "normal": asyncio.Queue(),
            "low": asyncio.Queue()
        }
        self.processing_order = ["critical", "high", "normal", "low"]

    async def enqueue(self, message: AgentMessage):
        """ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ë©”ì‹œì§€ íì— ì¶”ê°€"""

        priority = message.header["priority"]
        await self.queues[priority].put(message)

    async def dequeue(self) -> Optional[AgentMessage]:
        """ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ë©”ì‹œì§€ íì—ì„œ ì¡°íšŒ"""

        for priority in self.processing_order:
            queue = self.queues[priority]
            if not queue.empty():
                return await queue.get()

        return None  # íê°€ ë¹„ì–´ìˆìŒ
```

---

## ğŸ¯ í•µì‹¬ takeaways

1. **í‘œì¤€í™”ëœ í”„ë¡œí† ì½œ**: ìš”ì²­-ì‘ë‹µ, ë°œí–‰-êµ¬ë…, ìŠ¤íŠ¸ë¦¬ë° í”„ë¡œí† ì½œ
2. **ì»¨í…ìŠ¤íŠ¸ ìµœì í™”**: ì¦ë¶„ ì—…ë°ì´íŠ¸, ì§€ëŠ¥í˜• ìºì‹±, í† í° íš¨ìœ¨ì„±
3. **ë³´ì•ˆ í†µì‹ **: ì—ì´ì „íŠ¸ ì¸ì¦, ë©”ì‹œì§€ ì•”í˜¸í™”, ê¶Œí•œ ê´€ë¦¬
4. **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­, íš¨ìœ¨ì„± ë¶„ì„, ê°œì„  ì¶”ì²œ
5. **ë‹¤ì–‘í•œ í†µì‹  íŒ¨í„´**: íŒŒì´í”„ë¼ì¸, í”¼ì–´ íˆ¬ í”¼ì–´, ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ 

MoAI-ADKì˜ í†µì‹  í”„ë¡œí† ì½œì€ ì—ì´ì „íŠ¸ ê°„ **íš¨ìœ¨ì ì´ê³  ì•ˆì „í•œ ë°ì´í„° êµí™˜**ì„ í†µí•´ ë³µì¡í•œ í˜‘ì—… ì‘ì—…ì„ **ìµœëŒ€ 40% ë” ë¹ ë¥´ê²Œ** ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.