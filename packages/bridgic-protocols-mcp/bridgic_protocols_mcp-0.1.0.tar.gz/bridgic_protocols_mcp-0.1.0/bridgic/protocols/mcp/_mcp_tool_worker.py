from typing import Any, Dict, Optional, Union
from typing_extensions import override
from mcp.types import CallToolResult

from bridgic.core.automa.worker import Worker
from bridgic.protocols.mcp._mcp_server_connection import McpServerConnection
from bridgic.protocols.mcp._mcp_server_connection_manager import McpServerConnectionManager
from bridgic.protocols.mcp._error import McpServerConnectionError


class McpToolWorker(Worker):
    """
    A worker that executes an MCP tool on a connected MCP server.
    
    This worker receives tool arguments as keyword arguments and calls the
    corresponding tool on the MCP server, returning the result.
    """

    _tool_name: str
    """The name of the MCP tool to call."""

    _server_connection: Optional[McpServerConnection]
    """The connection to the MCP server that provides this tool."""

    _server_connection_name: Optional[str]
    """The name of the server connection, used for lookup after deserialization."""

    def __init__(
        self,
        tool_name: str,
        server_connection: Union[str, McpServerConnection],
    ):
        super().__init__()
        self._tool_name = tool_name

        # Try to associate with the real connection object.
        if isinstance(server_connection, str):
            self._server_connection = McpServerConnectionManager.get_connection(server_connection)
            self._server_connection_name = server_connection
        elif isinstance(server_connection, McpServerConnection):
            self._server_connection = server_connection
            self._server_connection_name = server_connection.name
        else:
            raise TypeError(f"Invalid type for server connection: {type(server_connection)}")

    @property
    def tool_name(self) -> str:
        """Get the name of the tool."""
        return self._tool_name

    @property
    def server_connection(self) -> McpServerConnection:
        """
        Get the server connection, loading it from the server connection manager if necessary.

        This property implements lazy loading of the server connection. If the connection 
        is not available (e.g., after deserialization), it will be retrieved from the 
        server connection manager by its name.

        Returns
        -------
        McpServerConnection
            The server connection instance.

        Raises
        ------
        McpServerConnectionError
            If the connection cannot be found in the manager.
        """
        if self._server_connection is None:
            if self._server_connection_name is None:
                raise McpServerConnectionError(
                    f"Cannot load server connection for McpToolWorker '{self._tool_name}': "
                    f"connection name is not available."
                )

            try:
                connection = McpServerConnectionManager.get_connection(self._server_connection_name)
            except KeyError as e:
                raise McpServerConnectionError(
                    f"Failed to load the server connection for McpToolWorker \"{self._tool_name}\", because the "
                    f"connection named \"{self._server_connection_name}\" was not found in any connection manager. "
                    f"You must create a McpServerConnection with name \"{self._server_connection_name}\" and "
                    f"ensure it is properly registered in a connection manager before using this worker."
                ) from e

            self._server_connection = connection

        return self._server_connection

    async def arun(self, **kwargs: Dict[str, Any]) -> CallToolResult:
        """
        Asynchronously execute the MCP tool with the provided arguments.

        Parameters
        ----------
        **kwargs : Dict[str, Any]
            The arguments to pass to the tool. These are typically provided
            from the tool call arguments generated by the LLM.

        Returns
        -------
        CallToolResult
            The result of the tool call from the MCP server, containing content
            and optionally structured content.

        Raises
        ------
        RuntimeError
            If the connection is not established and cannot be established.
        """
        result = await self.server_connection.acall_tool(
            tool_name=self._tool_name,
            arguments=kwargs if kwargs else None,
        )
        return result

    @override
    def dump_to_dict(self) -> Dict[str, Any]:
        state_dict = super().dump_to_dict()
        state_dict["tool_name"] = self._tool_name
        state_dict["server_connection_name"] = self._server_connection_name
        return state_dict

    @override
    def load_from_dict(self, state_dict: Dict[str, Any]) -> None:
        super().load_from_dict(state_dict)
        self._tool_name = state_dict.get("tool_name")
        connection_name = state_dict.get("server_connection_name", None)

        if connection_name is None:
            raise McpServerConnectionError(
                f"Cannot load server connection for McpToolWorker \"{self._tool_name}\", because "
                f"its connection name is not available."
            )

        # Try to reload the server connection from the global manager.
        try:
            self._server_connection = McpServerConnectionManager.get_connection(connection_name)
            self._server_connection_name = connection_name
        except KeyError as e:
            raise McpServerConnectionError(
                f"Failed to load the server connection for McpToolWorker \"{self._tool_name}\", because the "
                f"connection named \"{connection_name}\" was not found in any connection manager. "
                f"You must create a McpServerConnection with name \"{connection_name}\" and "
                f"ensure it is properly registered in a connection manager before using this worker."
            ) from e

