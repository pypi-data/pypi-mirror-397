from collections.abc import Callable
from typing import Concatenate, no_type_check, ParamSpec, Self, TYPE_CHECKING, TypeVar

import numpy as np
import numpy.typing as npt
from jaxtyping import Integer

from ._struct import Struct


_Params = ParamSpec("_Params")
_Return = TypeVar("_Return")


def _distribution(
    distribution: Callable[Concatenate[np.random.Generator, _Params], _Return],
) -> Callable[Concatenate["PRNGKey", _Params], _Return]:
    def impl(
        self: "PRNGKey", /, *args: _Params.args, **kwargs: _Params.kwargs
    ) -> _Return:
        if type(self._seed) is not np.int64:
            raise TypeError("Seed sequence has already been consumed.")
        generator = np.random.default_rng(self._seed)
        self._seed = None
        return distribution(generator, *args, **kwargs)

    # Not using `functools.wraps` because we want the right `__module__` and
    # `__qualname__`.
    # Not setting `__signature__` and `__annotations__` because `Generator.foo` does not
    # have any.
    impl.__name__ = distribution.__name__
    impl.__qualname__ = "PRNGKey." + distribution.__name__

    return impl


if not TYPE_CHECKING:
    _distribution = no_type_check(
        _distribution
    )  # typeguard doesn't support `Concatenate`.


class _FoldInUsedSeed(Struct):
    seed: np.int64


# Not a `Struct`, due to its linear typing.
class PRNGKey:
    """A PRNG key for sampling of randomness. Like `np.random.SeedSequence`, but without
    mutable state.

    This is a linear type, meaning that it can only be used once. This is important to
    prevent accidental key re-use, which would produce the same randomness.

    API:

    - `duplicate`, `fold_in`, `split`: these manipulate keys themselves. `split` is by
        far the most common one to use; the others are used rarely.
    - `permutation`, `integers`, ...: all the distributions available on
        `np.random.Generator`.

    !!! Example

        ```python
        key = PRNGKey(1337)
        while True:
            key, subkey = key.split(2)
            index = subkey.integers(len(dataset))
            element = dataset[index]
            yield element
        ```
    """

    def __init__(self, seed: Integer[npt.ArrayLike, ""]):
        """Initializes a new PRNG key.

        **Arguments:**

        - `seed`: integer seed. The random values obtained are a deterministic function
            of this seed.
        """
        # Make a copy to prevent external references mutating this.
        seed = np.int64(np.array(seed))
        # Note that we actually set `self._seed = None` after use, and not simply some
        # extra flag `self._used = True`.
        # The latter way puts the burden on later method calls to remember to check the
        # value of `self._used`. In contrast, setting it None far more reliable: it
        # ensures that we cannot even accidentally use a consumed seed.
        self._seed: np.int64 | _FoldInUsedSeed | None = seed
        self._seed_str = str(seed.item())

    def __init_subclass__(cls):
        raise TypeError("PRNGKey is final; it cannot be subclassed.")

    def __repr__(self):
        if self._seed is None:
            return f"PRNGKey<seed={self._seed_str}, used>"
        elif type(self._seed) is _FoldInUsedSeed:
            return f"PRNGKey<seed={self._seed_str}, used for fold_in>"
        else:
            return f"PRNGKey<seed={self._seed_str}>"

    def duplicate(self) -> Self:
        """Duplicates this key without breaking linearity.

        (This should be used very rarely.)
        """
        if type(self._seed) is not np.int64:
            raise TypeError("Seed sequence has already been consumed.")
        return PRNGKey(self._seed)  # pyright: ignore[reportReturnType]

    def fold_in(self, value: int) -> Self:
        """Generates a new PRNGKey whose randomness is a deterministic function of both
        `value` and the current seed.

        The randomness will be uncorrelated with both the randomness generated from the
        current key, and the randomness generated by folding in any other choice of
        `value`.
        """
        if self._seed is None:
            raise TypeError("Seed sequence has already been consumed.")
        # Notably we are not repeatedly using `SeedSequence(..., spawn_key=...)` or
        # `SeedSequence.spawn`, as these have performance problems. Instead, we keep our
        # randomness in the integer seeds.
        #
        # (On performance: `spawn_key` is a `tuple[int, ...]` of
        # `(child_index, grandchild_index, ... etc)`. When `spawn`ing, this entire tuple
        # is copied in order to append a new index to the end of it! This ends up being
        # dreadfully slow when done repeatedly.)
        elif isinstance(self._seed, _FoldInUsedSeed):
            old_seed = self._seed.seed
        else:
            old_seed = self._seed
        [new_seed] = np.random.SeedSequence(
            old_seed, spawn_key=(value,)
        ).generate_state(1)
        self._seed = _FoldInUsedSeed(old_seed)
        return PRNGKey(new_seed)  # pyright: ignore[reportReturnType]

    def split(self, num_splits: int) -> tuple[Self, ...]:
        """Splits this key into `num_splits` many sub-keys."""
        if type(self._seed) is not np.int64:
            raise TypeError("Seed sequence has already been consumed.")
        out = tuple(self.duplicate().fold_in(i) for i in range(num_splits))
        self._seed = None
        return out

    # These are ordered the same as in the numpy documentation

    # Simple
    integers = _distribution(np.random.Generator.integers)
    random = _distribution(np.random.Generator.random)
    choice = _distribution(np.random.Generator.choice)
    bytes = _distribution(np.random.Generator.bytes)

    # Permutations
    shuffle = _distribution(np.random.Generator.shuffle)
    permutation = _distribution(np.random.Generator.permutation)
    permuted = _distribution(np.random.Generator.permuted)

    # Distributions
    beta = _distribution(np.random.Generator.beta)
    binomial = _distribution(np.random.Generator.binomial)
    chisquare = _distribution(np.random.Generator.chisquare)
    dirichlet = _distribution(np.random.Generator.dirichlet)
    exponential = _distribution(np.random.Generator.exponential)
    f = _distribution(np.random.Generator.f)
    gamma = _distribution(np.random.Generator.gamma)
    geometric = _distribution(np.random.Generator.geometric)
    gumbel = _distribution(np.random.Generator.gumbel)
    hypergeometric = _distribution(np.random.Generator.hypergeometric)
    laplace = _distribution(np.random.Generator.laplace)
    logistic = _distribution(np.random.Generator.logistic)
    lognormal = _distribution(np.random.Generator.lognormal)
    logseries = _distribution(np.random.Generator.logseries)
    multinomial = _distribution(np.random.Generator.multinomial)
    multivariate_hypergeometric = _distribution(
        np.random.Generator.multivariate_hypergeometric
    )
    multivariate_normal = _distribution(np.random.Generator.multivariate_normal)
    negative_binomial = _distribution(np.random.Generator.negative_binomial)
    noncentral_chisquare = _distribution(np.random.Generator.noncentral_chisquare)
    noncentral_f = _distribution(np.random.Generator.noncentral_f)
    normal = _distribution(np.random.Generator.normal)
    pareto = _distribution(np.random.Generator.pareto)
    poisson = _distribution(np.random.Generator.poisson)
    power = _distribution(np.random.Generator.power)
    rayleigh = _distribution(np.random.Generator.rayleigh)
    standard_cauchy = _distribution(np.random.Generator.standard_cauchy)
    standard_exponential = _distribution(np.random.Generator.standard_exponential)
    standard_gamma = _distribution(np.random.Generator.standard_gamma)
    standard_normal = _distribution(np.random.Generator.standard_normal)
    standard_t = _distribution(np.random.Generator.standard_t)
    triangular = _distribution(np.random.Generator.triangular)
    uniform = _distribution(np.random.Generator.uniform)
    vonmises = _distribution(np.random.Generator.vonmises)
    wald = _distribution(np.random.Generator.wald)
    weibull = _distribution(np.random.Generator.weibull)
    zipf = _distribution(np.random.Generator.zipf)
