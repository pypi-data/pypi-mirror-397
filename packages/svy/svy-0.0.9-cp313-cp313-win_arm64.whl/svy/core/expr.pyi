from dataclasses import dataclass
from typing import Any, Iterable, Mapping

import polars as pl

from _typeshed import Incomplete

log: Incomplete

def to_polars_expr(x: Any) -> pl.Expr: ...
@dataclass(frozen=True)
class Expr:
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __truediv__(self, other): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __rmul__(self, other): ...
    def __rtruediv__(self, other): ...
    def __rpow__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def __invert__(self): ...
    def alias(self, name: str) -> Expr: ...
    def fill_null(self, x: Any) -> Expr: ...
    def log(self) -> Expr: ...
    def exp(self) -> Expr: ...
    def round(self, n: int = 0) -> Expr: ...
    def cast(self, dtype) -> Expr: ...
    def clip(self, min=None, max=None) -> Expr: ...
    def is_in(self, values: Iterable[Any]) -> Expr: ...
    isin = is_in
    def is_null(self) -> Expr: ...
    def is_not_null(self) -> Expr: ...
    def between(self, low: Any, high: Any, closed: str = "both") -> Expr: ...
    def contains(self, pat: str) -> Expr: ...
    def startswith(self, pref: str) -> Expr: ...
    def endswith(self, suff: str) -> Expr: ...

def col(name: str) -> Expr: ...
def lit(value: Any) -> Expr: ...
def when(condition: Expr): ...

SAFE_FUNCS: Mapping[str, Any]
