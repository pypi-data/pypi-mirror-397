
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.lang
import java.util
import jpype
import moa.capabilities
import moa.classifiers
import moa.classifiers.core.driftdetection
import moa.core
import moa.options
import moa.tasks
import typing



class Heros(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier, moa.capabilities.CapabilitiesHandler):
    poolOption: com.github.javacliparser.ListOption = ...
    numInstancesToTrainAllModelsOption: com.github.javacliparser.IntOption = ...
    evaluateNotAllModelsOption: com.github.javacliparser.FlagOption = ...
    aggregationOption: com.github.javacliparser.IntOption = ...
    dynamicResourceCosts: com.github.javacliparser.FlagOption = ...
    policyOption: moa.options.ClassOption = ...
    deltaOption: com.github.javacliparser.FloatOption = ...
    resetLearnerAfterDriftOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def getCapabilities(self) -> moa.capabilities.Capabilities: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    def getResourceCostsOfEachModel(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class PoolItem(java.lang.Comparable['Heros.PoolItem']):
        def __init__(self, heros: 'Heros', classifier: moa.classifiers.Classifier, aDWIN: moa.classifiers.core.driftdetection.ADWIN, float: float, boolean: bool, boolean2: bool): ...
        def compareTo(self, poolItem: 'Heros.PoolItem') -> int: ...
        def getEstimation(self) -> float: ...
        def getNumTrainingSteps(self) -> int: ...
        def getResourceCost(self) -> float: ...
        def setResourceCost(self, float: float) -> None: ...
        def setResourceNormFactor(self, float: float) -> None: ...
        def updateAfterTraining(self, float: float) -> None: ...
        def updateEstimator(self, instance: com.yahoo.labs.samoa.instances.Instance, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...

class Policy:
    numModelsToTrainOption: typing.ClassVar[com.github.javacliparser.IntOption] = ...
    epsilonOption: typing.ClassVar[com.github.javacliparser.FloatOption] = ...
    random: typing.ClassVar[java.util.Random] = ...
    def extractArgMax(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[int]: ...
    def getDistinctRandomIndices(self, int: int, int2: int) -> java.util.Set[int]: ...
    def pull(self, poolItemArray: typing.Union[typing.List[Heros.PoolItem], jpype.JArray]) -> typing.MutableSequence[int]: ...
    def pullWithPolicy(self, poolItemArray: typing.Union[typing.List[Heros.PoolItem], jpype.JArray]) -> typing.MutableSequence[int]: ...

class CandPolicy(moa.options.AbstractOptionHandler, Policy):
    def __init__(self): ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def pullWithPolicy(self, poolItemArray: typing.Union[typing.List[Heros.PoolItem], jpype.JArray]) -> typing.MutableSequence[int]: ...

class ZetaPolicy(moa.options.AbstractOptionHandler, Policy):
    zetaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def pullWithPolicy(self, poolItemArray: typing.Union[typing.List[Heros.PoolItem], jpype.JArray]) -> typing.MutableSequence[int]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.meta.heros")``.

    CandPolicy: typing.Type[CandPolicy]
    Heros: typing.Type[Heros]
    Policy: typing.Type[Policy]
    ZetaPolicy: typing.Type[ZetaPolicy]
