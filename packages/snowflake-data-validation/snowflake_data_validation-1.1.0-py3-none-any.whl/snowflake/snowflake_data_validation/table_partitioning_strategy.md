# Table Partitioning Strategy

## Overview

The `row_partitioning_strategy.py` module provides functionality to **divide large tables into smaller, manageable partitions** for data validation purposes. This is particularly useful when validating tables with millions of rows where processing the entire table at once would be impractical or resource-intensive.

## How It Works

The partitioning process follows these steps:

### 1. Count Total Rows
First, the module queries the source table to get the total row count:

```sql
SELECT COUNT(*) FROM {table_fully_qualified_name}
```

### 2. Calculate Rows Per Partition
The total rows are divided evenly across the requested number of partitions:

```python
number_of_rows_per_partition = table_row_count // number_of_partitions
```

### 3. Find Partition Boundaries
Using a CTE (Common Table Expression), the module assigns row numbers to each record ordered by the partition column, then selects the boundary values using an `IN` clause:

```sql
WITH DV_PARTITIONS AS (
    SELECT
        ROW_NUMBER() OVER (ORDER BY {partition_column}) AS ROW_NUMBER_IDX,
        {partition_column}
    FROM {table_fully_qualified_name}
)
SELECT {partition_column}
FROM DV_PARTITIONS
WHERE ROW_NUMBER_IDX IN (1, 2501, 5001, 7501, 10000)
```

The indexes collection is generated by `_generate_indexes_collection()`, which calculates the starting row index for each partition, plus the final row for the last partition boundary.

### 4. Generate WHERE Clauses
For each partition, a `WHERE` clause is generated to filter rows within that range:

| Partition | WHERE Clause Example |
|-----------|---------------------|
| First     | `id >= 1 AND id < 1000` |
| Middle    | `id >= 1000 AND id < 2000` |
| Last      | `id >= 2000 AND id <= 3000` (uses `<=` to include final row) |

### 5. Create Table Configurations
New `TableConfiguration` objects are created for each partition, each with:
- The source `where_clause` using original column names
- A `target_where_clause` with column mappings applied (for cross-platform validation)

## Visual Example

Given a table with **10,000 rows** and requesting **4 partitions**:

```
┌─────────────────────────────────────────────────────────┐
│                    Original Table                        │
│                    (10,000 rows)                         │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
    ┌──────────┬──────────┬──────────┬──────────┐
    │Partition │Partition │Partition │Partition │
    │    1     │    2     │    3     │    4     │
    │2,500 rows│2,500 rows│2,500 rows│2,500 rows│
    │ id >= 1  │id >= 2500│id >= 5000│id >= 7500│
    │id < 2500 │id < 5000 │id < 7500 │id <= 10000│
    └──────────┴──────────┴──────────┴──────────┘
```

## Key Parameters

| Parameter | Description |
|-----------|-------------|
| `platform` | The source platform (e.g., Snowflake, Teradata) |
| `credentials_connection` | Connection credentials for the source database |
| `partition_column` | Column used to divide the table (should be indexed/ordered) |
| `number_of_partitions` | How many partitions to create |
| `is_str_partition_column` | Whether the partition column is a string type (affects quoting) |
| `table_configuration` | The original table configuration to partition |

## String vs Numeric Partition Columns

The module handles both string and numeric partition columns:

- **Numeric columns**: `id >= 100 AND id < 200`
- **String columns**: `name >= 'Alice' AND name < 'Bob'`

## Output

The function returns a **string** containing all the partitioned table configurations, each ready to be used independently for data validation.
