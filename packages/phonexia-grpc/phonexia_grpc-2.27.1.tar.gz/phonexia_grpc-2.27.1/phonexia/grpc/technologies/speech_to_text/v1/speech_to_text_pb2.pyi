"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2025 Phonexia s.r.o.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Phonexia 6 generation Speech To Text gRPC API.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import phonexia.grpc.common.core_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ResultType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ResultTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ResultType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RESULT_TYPE_ONE_BEST: _ResultType.ValueType  # 0
    """Default one-best transcription result."""
    RESULT_TYPE_N_BEST: _ResultType.ValueType  # 1
    """N-best alternative transcription results."""
    RESULT_TYPE_CONFUSION_NETWORK: _ResultType.ValueType  # 2
    """Confusion network with word alternatives."""

class ResultType(_ResultType, metaclass=_ResultTypeEnumTypeWrapper):
    """Enum defining the types of results that can be returned in TranscribeResult."""

RESULT_TYPE_ONE_BEST: ResultType.ValueType  # 0
"""Default one-best transcription result."""
RESULT_TYPE_N_BEST: ResultType.ValueType  # 1
"""N-best alternative transcription results."""
RESULT_TYPE_CONFUSION_NETWORK: ResultType.ValueType  # 2
"""Confusion network with word alternatives."""
Global___ResultType: typing_extensions.TypeAlias = ResultType

class _ItemType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ItemTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ItemType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ITEM_TYPE_WORD: _ItemType.ValueType  # 0
    """<code>ITEM_TYPE_WORD</code> indicates a word.
    The <code>text</code> field of the item contains the word.
    """
    ITEM_TYPE_SILENCE: _ItemType.ValueType  # 1
    """<code>ITEM_TYPE_SILENCE</code> indicates a silence in the recording.
    The <code>text</code> field of the item contains "&lt;silence/&gt;".
    """
    ITEM_TYPE_SEGMENT_START: _ItemType.ValueType  # 2
    """<code>ITEM_TYPE_SEGMENT_START</code> indicates the start of a segment.
    A segment is a part of the recording that contains speech,
    as determined by the Voice Activity Detector (VAD).
    The <code>text</code> field of the item contains "&lt;segment&gt;".
    """
    ITEM_TYPE_SEGMENT_END: _ItemType.ValueType  # 3
    """<code>ITEM_TYPE_SEGMENT_END</code> indicates the end of a segment.
    A segment is a part of the recording that contains speech,
    as determined by the Voice Activity Detector (VAD).
    The <code>text</code> field of the item contains "&lt;/segment&gt;".
    """
    ITEM_TYPE_NULL: _ItemType.ValueType  # 4
    """<code>ITEM_TYPE_NULL</code> represents an empty alternative in a confusion network.
    The <code>text</code> field of the item contains "<null/>".
    """

class ItemType(_ItemType, metaclass=_ItemTypeEnumTypeWrapper): ...

ITEM_TYPE_WORD: ItemType.ValueType  # 0
"""<code>ITEM_TYPE_WORD</code> indicates a word.
The <code>text</code> field of the item contains the word.
"""
ITEM_TYPE_SILENCE: ItemType.ValueType  # 1
"""<code>ITEM_TYPE_SILENCE</code> indicates a silence in the recording.
The <code>text</code> field of the item contains "&lt;silence/&gt;".
"""
ITEM_TYPE_SEGMENT_START: ItemType.ValueType  # 2
"""<code>ITEM_TYPE_SEGMENT_START</code> indicates the start of a segment.
A segment is a part of the recording that contains speech,
as determined by the Voice Activity Detector (VAD).
The <code>text</code> field of the item contains "&lt;segment&gt;".
"""
ITEM_TYPE_SEGMENT_END: ItemType.ValueType  # 3
"""<code>ITEM_TYPE_SEGMENT_END</code> indicates the end of a segment.
A segment is a part of the recording that contains speech,
as determined by the Voice Activity Detector (VAD).
The <code>text</code> field of the item contains "&lt;/segment&gt;".
"""
ITEM_TYPE_NULL: ItemType.ValueType  # 4
"""<code>ITEM_TYPE_NULL</code> represents an empty alternative in a confusion network.
The <code>text</code> field of the item contains "<null/>".
"""
Global___ItemType: typing_extensions.TypeAlias = ItemType

@typing.final
class TranscribeRequest(google.protobuf.message.Message):
    """The top-level message sent by the client for the <code>Transcribe</code>
    method.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUDIO_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    @property
    def audio(self) -> phonexia.grpc.common.core_pb2.Audio:
        """The audio data to process. There is no minimum audio length limit.
        Returns EMPTY_FIELD bad parameter error if audio field is missing in the first request message.
        """

    @property
    def config(self) -> Global___TranscribeConfig:
        """Speech to text transcription configuration."""

    def __init__(
        self,
        *,
        audio: phonexia.grpc.common.core_pb2.Audio | None = ...,
        config: Global___TranscribeConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_config", b"_config", "audio", b"audio", "config", b"config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_config", b"_config", "audio", b"audio", "config", b"config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_config", b"_config"]) -> typing.Literal["config"] | None: ...

Global___TranscribeRequest: typing_extensions.TypeAlias = TranscribeRequest

@typing.final
class TranscribeConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREFERRED_PHRASES_FIELD_NUMBER: builtins.int
    ADDITIONAL_WORDS_FIELD_NUMBER: builtins.int
    RESULT_TYPES_FIELD_NUMBER: builtins.int
    @property
    def preferred_phrases(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Phrases that are preferred in transcription over other variants. Phrase consists of words spelled using graphemes
        separated by space. Graphemes that are not valid for transcription language might be used. However, the word must
        be added to <code>additional_words</code> and contains at least one pronunciation.
        Use <code>ListAllowedSymbols</code> to get allowed graphemes.
        All words from preferred phrases are automatically added to the model's dictionary and included in
        <code>TranscribeResponse.result.additional_words</code>.

        Returns UNSUPPORTED_GRAPHEME bad parameter error if a phrase contains unsupported characters.
        """

    @property
    def additional_words(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___RequestedAdditionalWord]:
        """Words that are added to the default transcription dictionary.
        See RequestedAdditionalWord for field-specific validation rules.
        """

    @property
    def result_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[Global___ResultType.ValueType]:
        """Types of results to return in the response.
        If not specified, <code>RESULT_TYPE_ONE_BEST</code> will be used.
        """

    def __init__(
        self,
        *,
        preferred_phrases: collections.abc.Iterable[builtins.str] | None = ...,
        additional_words: collections.abc.Iterable[Global___RequestedAdditionalWord] | None = ...,
        result_types: collections.abc.Iterable[Global___ResultType.ValueType] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["additional_words", b"additional_words", "preferred_phrases", b"preferred_phrases", "result_types", b"result_types"]) -> None: ...

Global___TranscribeConfig: typing_extensions.TypeAlias = TranscribeConfig

@typing.final
class RequestedAdditionalWord(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SPELLING_FIELD_NUMBER: builtins.int
    PRONUNCIATIONS_FIELD_NUMBER: builtins.int
    spelling: builtins.str
    """Word spelled using graphemes. Graphemes that are not valid for transcription
    language might be used. However, in such case, at least one pronunciation must
    be provided. Multiple words can be separated by word separator.
    Use <code>ListAllowedSymbols</code> to get allowed graphemes and word separator.

    Returns EMPTY_FIELD bad parameter error if spelling is empty.
    Returns UNSUPPORTED_GRAPHEME bad parameter error if spelling contains unsupported characters
    (only when no pronunciations are provided).
    """
    @property
    def pronunciations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Pronunciations specified using transcription language's valid phonemes.
        Individual phonemes must be separated by space. If no pronunciation is provided,
        at least one is generated by the language model. Use <code>ListAllowedSymbols</code> to get allowed phonemes.
        At least 3 phonemes are required.

        Returns EMPTY_FIELD bad parameter error if pronunciation is empty.
        Returns UNSUPPORTED_PHONEME bad parameter error if pronunciation contains unsupported phonemes.
        Returns PRONUNCIATION_TOO_SHORT bad parameter error if pronunciation contains fewer than 3 phonemes.
        """

    def __init__(
        self,
        *,
        spelling: builtins.str = ...,
        pronunciations: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pronunciations", b"pronunciations", "spelling", b"spelling"]) -> None: ...

Global___RequestedAdditionalWord: typing_extensions.TypeAlias = RequestedAdditionalWord

@typing.final
class Word(google.protobuf.message.Message):
    """Individual word with timestamps."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEXT_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    text: builtins.str
    """Text of the word."""
    type: Global___ItemType.ValueType
    """Type of the word. It might be <code>ITEM_TYPE_WORD</code> or <code>ITEM_TYPE_SILENCE</code>.
    <code>ITEM_TYPE_SEGMENT_START</code>, <code>ITEM_TYPE_SEGMENT_END</code> and <code>ITEM_TYPE_NULL</code> are not allowed here.
    When type is <code>ITEM_TYPE_SILENCE</code>, text contains "&lt;silence/&gt;", otherwise text contains the word.
    Words of <code>ITEM_TYPE_SILENCE</code> are only included in OneBest if their duration is greater than 180ms.
    """
    @property
    def start_time(self) -> google.protobuf.duration_pb2.Duration:
        """Start time of the word."""

    @property
    def end_time(self) -> google.protobuf.duration_pb2.Duration:
        """End time of the word."""

    def __init__(
        self,
        *,
        text: builtins.str = ...,
        start_time: google.protobuf.duration_pb2.Duration | None = ...,
        end_time: google.protobuf.duration_pb2.Duration | None = ...,
        type: Global___ItemType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time", "text", b"text", "type", b"type"]) -> None: ...

Global___Word: typing_extensions.TypeAlias = Word

@typing.final
class OneBestSegment(google.protobuf.message.Message):
    """Segment of the one-best output."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEXT_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    WORDS_FIELD_NUMBER: builtins.int
    text: builtins.str
    """Text content of the whole segment."""
    @property
    def start_time(self) -> google.protobuf.duration_pb2.Duration:
        """Start time of the segment."""

    @property
    def end_time(self) -> google.protobuf.duration_pb2.Duration:
        """End time of the segment."""

    @property
    def words(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Word]:
        """Detailed word-level segmentation of the segment."""

    def __init__(
        self,
        *,
        text: builtins.str = ...,
        start_time: google.protobuf.duration_pb2.Duration | None = ...,
        end_time: google.protobuf.duration_pb2.Duration | None = ...,
        words: collections.abc.Iterable[Global___Word] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time", "text", b"text", "words", b"words"]) -> None: ...

Global___OneBestSegment: typing_extensions.TypeAlias = OneBestSegment

@typing.final
class OneBest(google.protobuf.message.Message):
    """The one-best output from Speech to Text."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENTS_FIELD_NUMBER: builtins.int
    @property
    def segments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___OneBestSegment]:
        """List of transcription segments"""

    def __init__(
        self,
        *,
        segments: collections.abc.Iterable[Global___OneBestSegment] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["segments", b"segments"]) -> None: ...

Global___OneBest: typing_extensions.TypeAlias = OneBest

@typing.final
class NBestSegmentAlternative(google.protobuf.message.Message):
    """Alternative of a segment."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEXT_FIELD_NUMBER: builtins.int
    CONFIDENCE_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    text: builtins.str
    """The text of the segment."""
    confidence: builtins.float
    """Confidence of the segment."""
    @property
    def start_time(self) -> google.protobuf.duration_pb2.Duration:
        """Start time of the segment."""

    @property
    def end_time(self) -> google.protobuf.duration_pb2.Duration:
        """End time of the segment."""

    def __init__(
        self,
        *,
        text: builtins.str = ...,
        confidence: builtins.float = ...,
        start_time: google.protobuf.duration_pb2.Duration | None = ...,
        end_time: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["confidence", b"confidence", "end_time", b"end_time", "start_time", b"start_time", "text", b"text"]) -> None: ...

Global___NBestSegmentAlternative: typing_extensions.TypeAlias = NBestSegmentAlternative

@typing.final
class NBestSegment(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENT_ALTERNATIVES_FIELD_NUMBER: builtins.int
    @property
    def segment_alternatives(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___NBestSegmentAlternative]:
        """The alternatives of the segment."""

    def __init__(
        self,
        *,
        segment_alternatives: collections.abc.Iterable[Global___NBestSegmentAlternative] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["segment_alternatives", b"segment_alternatives"]) -> None: ...

Global___NBestSegment: typing_extensions.TypeAlias = NBestSegment

@typing.final
class NBest(google.protobuf.message.Message):
    """The n-best output from Speech to Text."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENTS_FIELD_NUMBER: builtins.int
    @property
    def segments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___NBestSegment]:
        """List of segments."""

    def __init__(
        self,
        *,
        segments: collections.abc.Iterable[Global___NBestSegment] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["segments", b"segments"]) -> None: ...

Global___NBest: typing_extensions.TypeAlias = NBest

@typing.final
class ConfusionNetworkWordAlternative(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEXT_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    CONFIDENCE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    text: builtins.str
    """Text of the word."""
    confidence: builtins.float
    """Confidence of the word."""
    type: Global___ItemType.ValueType
    """Type of the word. When type is <code>ITEM_TYPE_WORD</code> then text contains the word. In other cases text contains:
    <code>ITEM_TYPE_SILENCE</code> - "&lt;silence/&gt;"
    <code>ITEM_TYPE_SEGMENT_START</code> - "&lt;segment&gt;"
    <code>ITEM_TYPE_SEGMENT_END</code> - "&lt;/segment&gt;"
    <code>ITEM_TYPE_NULL</code> - "&lt;null/&gt;"
    """
    @property
    def start_time(self) -> google.protobuf.duration_pb2.Duration:
        """Start time of the segment."""

    @property
    def end_time(self) -> google.protobuf.duration_pb2.Duration:
        """End time of the segment."""

    def __init__(
        self,
        *,
        text: builtins.str = ...,
        start_time: google.protobuf.duration_pb2.Duration | None = ...,
        end_time: google.protobuf.duration_pb2.Duration | None = ...,
        confidence: builtins.float = ...,
        type: Global___ItemType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["confidence", b"confidence", "end_time", b"end_time", "start_time", b"start_time", "text", b"text", "type", b"type"]) -> None: ...

Global___ConfusionNetworkWordAlternative: typing_extensions.TypeAlias = ConfusionNetworkWordAlternative

@typing.final
class ConfusionNetworkWord(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WORD_ALTERNATIVES_FIELD_NUMBER: builtins.int
    @property
    def word_alternatives(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ConfusionNetworkWordAlternative]:
        """Words in the time slot represent different
        variants of the word in the given time moment.
        """

    def __init__(
        self,
        *,
        word_alternatives: collections.abc.Iterable[Global___ConfusionNetworkWordAlternative] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["word_alternatives", b"word_alternatives"]) -> None: ...

Global___ConfusionNetworkWord: typing_extensions.TypeAlias = ConfusionNetworkWord

@typing.final
class ConfusionNetwork(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WORDS_FIELD_NUMBER: builtins.int
    @property
    def words(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ConfusionNetworkWord]:
        """The confusion network."""

    def __init__(
        self,
        *,
        words: collections.abc.Iterable[Global___ConfusionNetworkWord] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["words", b"words"]) -> None: ...

Global___ConfusionNetwork: typing_extensions.TypeAlias = ConfusionNetwork

@typing.final
class TranscribeResult(google.protobuf.message.Message):
    """Result of the Speech to Text."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ONE_BEST_FIELD_NUMBER: builtins.int
    N_BEST_FIELD_NUMBER: builtins.int
    CONFUSION_NETWORK_FIELD_NUMBER: builtins.int
    ADDITIONAL_WORDS_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    language: builtins.str
    """Language of the transcript."""
    @property
    def one_best(self) -> Global___OneBest:
        """The one-best output from Speech to Text."""

    @property
    def n_best(self) -> Global___NBest:
        """The n-best output from Speech to Text."""

    @property
    def confusion_network(self) -> Global___ConfusionNetwork:
        """The confusion network output from Speech to Text."""

    @property
    def additional_words(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ResultingAdditionalWord]:
        """Words that were used to extend model's dictionary during transcription.
        This list is the result of their processing. If they were originally part
        of a preferred phrase, they are explicitly listed here. Furthermore, the model
        might have generated pronunciation for unknown words that were missing one.
        Lastly, if user provided a word that's already present in the model
        dictionary, all the known pronunciations were added to it.
        """

    def __init__(
        self,
        *,
        one_best: Global___OneBest | None = ...,
        n_best: Global___NBest | None = ...,
        confusion_network: Global___ConfusionNetwork | None = ...,
        additional_words: collections.abc.Iterable[Global___ResultingAdditionalWord] | None = ...,
        language: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_confusion_network", b"_confusion_network", "_n_best", b"_n_best", "_one_best", b"_one_best", "confusion_network", b"confusion_network", "n_best", b"n_best", "one_best", b"one_best"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_confusion_network", b"_confusion_network", "_n_best", b"_n_best", "_one_best", b"_one_best", "additional_words", b"additional_words", "confusion_network", b"confusion_network", "language", b"language", "n_best", b"n_best", "one_best", b"one_best"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_confusion_network", b"_confusion_network"]) -> typing.Literal["confusion_network"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_n_best", b"_n_best"]) -> typing.Literal["n_best"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_one_best", b"_one_best"]) -> typing.Literal["one_best"] | None: ...

Global___TranscribeResult: typing_extensions.TypeAlias = TranscribeResult

@typing.final
class ResultingAdditionalWord(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SPELLING_FIELD_NUMBER: builtins.int
    PRONUNCIATIONS_FIELD_NUMBER: builtins.int
    spelling: builtins.str
    """Word spelling as originally provided by the user."""
    @property
    def pronunciations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ResultingPronunciation]:
        """Word pronunciation after being processed by the language model."""

    def __init__(
        self,
        *,
        spelling: builtins.str = ...,
        pronunciations: collections.abc.Iterable[Global___ResultingPronunciation] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pronunciations", b"pronunciations", "spelling", b"spelling"]) -> None: ...

Global___ResultingAdditionalWord: typing_extensions.TypeAlias = ResultingAdditionalWord

@typing.final
class ResultingPronunciation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PRONUNCIATION_FIELD_NUMBER: builtins.int
    OUT_OF_VOCABULARY_FIELD_NUMBER: builtins.int
    pronunciation: builtins.str
    """Pronunciation specified using transcription language's valid phonemes."""
    out_of_vocabulary: builtins.bool
    """Indication of whether the pronunciation is previously unknown to the model."""
    def __init__(
        self,
        *,
        pronunciation: builtins.str = ...,
        out_of_vocabulary: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["out_of_vocabulary", b"out_of_vocabulary", "pronunciation", b"pronunciation"]) -> None: ...

Global___ResultingPronunciation: typing_extensions.TypeAlias = ResultingPronunciation

@typing.final
class TranscribeResponse(google.protobuf.message.Message):
    """TranscribeResponse is the top-level response message returned by the <code>Transcribe</code> method.
    It encapsulates segments containing the transcription results.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_FIELD_NUMBER: builtins.int
    PROCESSED_AUDIO_LENGTH_FIELD_NUMBER: builtins.int
    @property
    def result(self) -> Global___TranscribeResult:
        """Transcription result for the processed audio."""

    @property
    def processed_audio_length(self) -> google.protobuf.duration_pb2.Duration:
        """Total duration of the processed audio."""

    def __init__(
        self,
        *,
        result: Global___TranscribeResult | None = ...,
        processed_audio_length: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length", "result", b"result"]) -> None: ...

Global___TranscribeResponse: typing_extensions.TypeAlias = TranscribeResponse

@typing.final
class ListAllowedSymbolsRequest(google.protobuf.message.Message):
    """Request message for retrieving the set of allowed graphemes and phonemes."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___ListAllowedSymbolsRequest: typing_extensions.TypeAlias = ListAllowedSymbolsRequest

@typing.final
class ListAllowedSymbolsResponse(google.protobuf.message.Message):
    """Response message containing the allowed graphemes and phonemes."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GRAPHEMES_FIELD_NUMBER: builtins.int
    PHONEMES_FIELD_NUMBER: builtins.int
    WORD_SEPARATOR_FIELD_NUMBER: builtins.int
    word_separator: builtins.str
    """Word separator used in <code>TranscribeConfig.additional_words.spelling</code>"""
    @property
    def graphemes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The list of allowed graphemes. Graphemes are characters used in
        <code>TranscribeConfig.preferred_phrases</code> and
        <code>RequestedAdditionalWord.spelling</code>.
        """

    @property
    def phonemes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """List of allowed phonemes.
        Phonemes are symbols used in the <code>RequestedAdditionalWord.pronunciations</code> field.
        Each phoneme is represented as a space-separated string and may consist of multiple characters.
        """

    def __init__(
        self,
        *,
        graphemes: collections.abc.Iterable[builtins.str] | None = ...,
        phonemes: collections.abc.Iterable[builtins.str] | None = ...,
        word_separator: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["graphemes", b"graphemes", "phonemes", b"phonemes", "word_separator", b"word_separator"]) -> None: ...

Global___ListAllowedSymbolsResponse: typing_extensions.TypeAlias = ListAllowedSymbolsResponse
