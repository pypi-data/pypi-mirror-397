"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2025 Phonexia s.r.o.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Phonexia Audio Quality Estimation gRPC API.
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.message
import phonexia.grpc.common.core_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class EstimateRequest(google.protobuf.message.Message):
    """The top-level message sent by the client for the <code>Estimate</code>
    method.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUDIO_FIELD_NUMBER: builtins.int
    @property
    def audio(self) -> phonexia.grpc.common.core_pb2.Audio:
        """Audio data for which Audio Quality Estimation should be performed.
        At least 1 millisecond of audio is required, otherwise the result will not contain
        any estimations.
        """

    def __init__(
        self,
        *,
        audio: phonexia.grpc.common.core_pb2.Audio | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["audio", b"audio"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["audio", b"audio"]) -> None: ...

Global___EstimateRequest: typing_extensions.TypeAlias = EstimateRequest

@typing.final
class EstimateResult(google.protobuf.message.Message):
    """The collection of all Audio Quality Estimation result types."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PESQ_ESTIMATION_FIELD_NUMBER: builtins.int
    SIGNAL_NOISE_RATIO_FIELD_NUMBER: builtins.int
    AUDIO_LENGTH_FIELD_NUMBER: builtins.int
    MAX_AMPLITUDE_FIELD_NUMBER: builtins.int
    MIN_AMPLITUDE_FIELD_NUMBER: builtins.int
    PEAK_AMPLITUDE_FIELD_NUMBER: builtins.int
    MEAN_AMPLITUDE_FIELD_NUMBER: builtins.int
    SAMPLING_RATE_FIELD_NUMBER: builtins.int
    pesq_estimation: builtins.float
    """Estimation of Perceptual Evaluation of Speech Quality."""
    signal_noise_ratio: builtins.float
    """Signal to Noise Ratio in decibels based on waveform distribution."""
    audio_length: builtins.float
    """Total length of the audio in seconds."""
    max_amplitude: builtins.float
    """Maximum amplitude of the signal, typically a positive number in the interval of
    [-1, 1].
    """
    min_amplitude: builtins.float
    """Minimum amplitude of the signal, typically a negative number in the interval of
    [-1, 1].
    """
    peak_amplitude: builtins.float
    """Maximum absolute value of the signal (i.e., the higher of the absolute values of
    `max_amplitude` and `min_amplitude`).
    """
    mean_amplitude: builtins.float
    """Arithmetic mean of the sample amplitudes."""
    sampling_rate: builtins.int
    """Sampling rate in hertz of the audio."""
    def __init__(
        self,
        *,
        pesq_estimation: builtins.float | None = ...,
        signal_noise_ratio: builtins.float | None = ...,
        audio_length: builtins.float | None = ...,
        max_amplitude: builtins.float | None = ...,
        min_amplitude: builtins.float | None = ...,
        peak_amplitude: builtins.float | None = ...,
        mean_amplitude: builtins.float | None = ...,
        sampling_rate: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_audio_length", b"_audio_length", "_max_amplitude", b"_max_amplitude", "_mean_amplitude", b"_mean_amplitude", "_min_amplitude", b"_min_amplitude", "_peak_amplitude", b"_peak_amplitude", "_pesq_estimation", b"_pesq_estimation", "_sampling_rate", b"_sampling_rate", "_signal_noise_ratio", b"_signal_noise_ratio", "audio_length", b"audio_length", "max_amplitude", b"max_amplitude", "mean_amplitude", b"mean_amplitude", "min_amplitude", b"min_amplitude", "peak_amplitude", b"peak_amplitude", "pesq_estimation", b"pesq_estimation", "sampling_rate", b"sampling_rate", "signal_noise_ratio", b"signal_noise_ratio"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_audio_length", b"_audio_length", "_max_amplitude", b"_max_amplitude", "_mean_amplitude", b"_mean_amplitude", "_min_amplitude", b"_min_amplitude", "_peak_amplitude", b"_peak_amplitude", "_pesq_estimation", b"_pesq_estimation", "_sampling_rate", b"_sampling_rate", "_signal_noise_ratio", b"_signal_noise_ratio", "audio_length", b"audio_length", "max_amplitude", b"max_amplitude", "mean_amplitude", b"mean_amplitude", "min_amplitude", b"min_amplitude", "peak_amplitude", b"peak_amplitude", "pesq_estimation", b"pesq_estimation", "sampling_rate", b"sampling_rate", "signal_noise_ratio", b"signal_noise_ratio"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_audio_length", b"_audio_length"]) -> typing.Literal["audio_length"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_max_amplitude", b"_max_amplitude"]) -> typing.Literal["max_amplitude"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_mean_amplitude", b"_mean_amplitude"]) -> typing.Literal["mean_amplitude"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_min_amplitude", b"_min_amplitude"]) -> typing.Literal["min_amplitude"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_peak_amplitude", b"_peak_amplitude"]) -> typing.Literal["peak_amplitude"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_pesq_estimation", b"_pesq_estimation"]) -> typing.Literal["pesq_estimation"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_sampling_rate", b"_sampling_rate"]) -> typing.Literal["sampling_rate"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_signal_noise_ratio", b"_signal_noise_ratio"]) -> typing.Literal["signal_noise_ratio"] | None: ...

Global___EstimateResult: typing_extensions.TypeAlias = EstimateResult

@typing.final
class EstimateResponse(google.protobuf.message.Message):
    """The top-level message returned to the client by the <code>Estimate</code>
    method.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_FIELD_NUMBER: builtins.int
    PROCESSED_AUDIO_LENGTH_FIELD_NUMBER: builtins.int
    @property
    def result(self) -> Global___EstimateResult:
        """Audio Quality Estimation result."""

    @property
    def processed_audio_length(self) -> google.protobuf.duration_pb2.Duration:
        """Total length of the processed audio.
        Set only if this is the last response in the stream.
        """

    def __init__(
        self,
        *,
        result: Global___EstimateResult | None = ...,
        processed_audio_length: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length", "result", b"result"]) -> None: ...

Global___EstimateResponse: typing_extensions.TypeAlias = EstimateResponse
